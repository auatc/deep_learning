api_element,cq,suggest_sen,kwd
String.substring(int beginIndex),Did you cause the error java.lang.IndexOutOfBoundsException?, - if beginIndex is negative or larger than the length of this String object. you will cause the error java.lang.IndexOutOfBoundsException.,['java.lang.IndexOutOfBoundsException']
Math.incrementExact(long a),Did you cause the error java.lang.ArithmeticException?, - if the result overflows a long you will cause the error java.lang.ArithmeticException.,['java.lang.ArithmeticException']
Scanner.hasNextBigInteger(int radix),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
NavigableMap.tailMap(K fromKey),Did you cause the error java.lang.ClassCastException?," - if fromKey is not compatible with this map's comparator (or, if the map has no comparator, if fromKey does not implement Comparable). Implementations may, but are not required to, throw this exception if fromKey cannot be compared to keys currently in the map. you will cause the error java.lang.ClassCastException.",['java.lang.ClassCastException']
NavigableMap.tailMap(K fromKey),Did you cause the error java.lang.NullPointerException?," - if fromKey is null and this map uses natural ordering, or its comparator does not permit null keys you will cause the error java.lang.NullPointerException.",['java.lang.NullPointerException']
NavigableMap.tailMap(K fromKey),Did you cause the error java.lang.IllegalArgumentException?," - if this map itself has a restricted range, and fromKey lies outside the bounds of the range you will cause the error java.lang.IllegalArgumentException.",['java.lang.IllegalArgumentException']
Class.getGenericSuperclass(),Did you cause the error java.lang.reflect.GenericSignatureFormatError?, - if the generic class signature does not conform to the format specified in The Java™ Virtual Machine Specification you will cause the error java.lang.reflect.GenericSignatureFormatError.,['java.lang.reflect.GenericSignatureFormatError']
Class.getGenericSuperclass(),Did you cause the error java.lang.TypeNotPresentException?, - if the generic superclass refers to a non-existent type declaration you will cause the error java.lang.TypeNotPresentException.,['java.lang.TypeNotPresentException']
Class.getGenericSuperclass(),Did you cause the error java.lang.reflect.MalformedParameterizedTypeException?, - if the generic superclass refers to a parameterized type that cannot be instantiated for any reason you will cause the error java.lang.reflect.MalformedParameterizedTypeException.,['java.lang.reflect.MalformedParameterizedTypeException']
Date.before(Date when),Did you cause the error java.lang.NullPointerException?, - if when is null. you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Class.getGenericInterfaces(),Did you cause the error java.lang.reflect.GenericSignatureFormatError?, - if the generic class signature does not conform to the format specified in The Java™ Virtual Machine Specification you will cause the error java.lang.reflect.GenericSignatureFormatError.,['java.lang.reflect.GenericSignatureFormatError']
Class.getGenericInterfaces(),Did you cause the error java.lang.TypeNotPresentException?, - if any of the generic superinterfaces refers to a non-existent type declaration you will cause the error java.lang.TypeNotPresentException.,['java.lang.TypeNotPresentException']
Class.getGenericInterfaces(),Did you cause the error java.lang.reflect.MalformedParameterizedTypeException?, - if any of the generic superinterfaces refer to a parameterized type that cannot be instantiated for any reason you will cause the error java.lang.reflect.MalformedParameterizedTypeException.,['java.lang.reflect.MalformedParameterizedTypeException']
Scanner.nextDouble(),Did you cause the error java.util.InputMismatchException?," - if the next token does not match the Float regular expression, or is out of range you will cause the error java.util.InputMismatchException.",['java.util.InputMismatchException']
Scanner.nextDouble(),Did you cause the error java.util.NoSuchElementException?, - if the input is exhausted you will cause the error java.util.NoSuchElementException.,['java.util.NoSuchElementException']
Scanner.nextDouble(),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
Scanner.nextBoolean(),Did you cause the error java.util.InputMismatchException?, - if the next token is not a valid boolean you will cause the error java.util.InputMismatchException.,['java.util.InputMismatchException']
Scanner.nextBoolean(),Did you cause the error java.util.NoSuchElementException?, - if input is exhausted you will cause the error java.util.NoSuchElementException.,['java.util.NoSuchElementException']
Scanner.nextBoolean(),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
String.codePointAt(int index),Did you cause the error java.lang.IndexOutOfBoundsException?, - if the index argument is negative or not less than the length of this string. you will cause the error java.lang.IndexOutOfBoundsException.,['java.lang.IndexOutOfBoundsException']
Currency.getInstance(Locale locale),Did you cause the error java.lang.NullPointerException?, - if locale or its country code is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Currency.getInstance(Locale locale),Did you cause the error java.lang.IllegalArgumentException?, - if the country of the given locale is not a supported ISO 3166 country code. you will cause the error java.lang.IllegalArgumentException.,['java.lang.IllegalArgumentException']
Scanner.hasNextBoolean(),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
"NavigableSet.subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)",Did you cause the error java.lang.ClassCastException?,toElement - high endpoint of the returned set you will cause the error java.lang.ClassCastException.,['java.lang.ClassCastException']
"NavigableSet.subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)",Did you cause the error java.lang.NullPointerException?,toInclusive - true if the high endpoint is to be included in the returned view you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
"NavigableSet.subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)",Did you cause the error java.lang.IllegalArgumentException?,"a view of the portion of this set whose elements range from fromElement, inclusive, to toElement, exclusive you will cause the error java.lang.IllegalArgumentException.",['java.lang.IllegalArgumentException']
"NavigableSet.subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)",Did you cause the error java.lang.ClassCastException?," - if fromElement and toElement cannot be compared to one another using this set's comparator (or, if the set has no comparator, using natural ordering). Implementations may, but are not required to, throw this exception if fromElement or toElement cannot be compared to elements currently in the set. you will cause the error java.lang.ClassCastException.",['java.lang.ClassCastException']
"NavigableSet.subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)",Did you cause the error java.lang.NullPointerException?, - if fromElement or toElement is null and this set does not permit null elements you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
"NavigableSet.subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)",Did you cause the error java.lang.IllegalArgumentException?," - if fromElement is greater than toElement; or if this set itself has a restricted range, and fromElement or toElement lies outside the bounds of the range. you will cause the error java.lang.IllegalArgumentException.",['java.lang.IllegalArgumentException']
Scanner.hasNextBigInteger(),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
Scanner.hasNextShort(),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
Math.toIntExact(long value),Did you cause the error java.lang.ArithmeticException?, - if the argument overflows an int you will cause the error java.lang.ArithmeticException.,['java.lang.ArithmeticException']
Scanner.skip(String pattern),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
Map.Entry.getValue(),Did you cause the error java.lang.IllegalStateException?," - implementations may, but are not required to, throw this exception if the entry has been removed from the backing map. you will cause the error java.lang.IllegalStateException.",['java.lang.IllegalStateException']
Spliterator.getComparator(),Did you cause the error java.lang.IllegalStateException?, - if the spliterator does not report a characteristic of SORTED. you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
Short.valueOf(String s),Did you cause the error java.lang.NumberFormatException?, - If the String does not contain a parsable short. you will cause the error java.lang.NumberFormatException.,['java.lang.NumberFormatException']
Scanner.hasNextShort(int radix),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
Readable.read(CharBuffer cb),Did you cause the error java.io.IOException?, - if an I/O error occurs you will cause the error java.io.IOException.,['java.io.IOException']
Readable.read(CharBuffer cb),Did you cause the error java.lang.NullPointerException?, - if cb is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Readable.read(CharBuffer cb),Did you cause the error java.nio.ReadOnlyBufferException?, - if cb is a read only buffer you will cause the error java.nio.ReadOnlyBufferException.,['java.nio.ReadOnlyBufferException']
PrimitiveIterator.OfInt.nextInt(),Did you cause the error java.util.NoSuchElementException?, - if the iteration has no more elements you will cause the error java.util.NoSuchElementException.,['java.util.NoSuchElementException']
Objects.requireNonNull(T obj),Did you cause the error java.lang.NullPointerException?, - if obj is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Character.toChars(int codePoint),Did you cause the error java.lang.IllegalArgumentException?, - if the specified codePoint is not a valid Unicode code point. you will cause the error java.lang.IllegalArgumentException.,['java.lang.IllegalArgumentException']
PrimitiveIterator.OfLong.nextLong(),Did you cause the error java.util.NoSuchElementException?, - if the iteration has no more elements you will cause the error java.util.NoSuchElementException.,['java.util.NoSuchElementException']
NavigableMap.headMap(K toKey),Did you cause the error java.lang.ClassCastException?," - if toKey is not compatible with this map's comparator (or, if the map has no comparator, if toKey does not implement Comparable). Implementations may, but are not required to, throw this exception if toKey cannot be compared to keys currently in the map. you will cause the error java.lang.ClassCastException.",['java.lang.ClassCastException']
NavigableMap.headMap(K toKey),Did you cause the error java.lang.NullPointerException?," - if toKey is null and this map uses natural ordering, or its comparator does not permit null keys you will cause the error java.lang.NullPointerException.",['java.lang.NullPointerException']
NavigableMap.headMap(K toKey),Did you cause the error java.lang.IllegalArgumentException?," - if this map itself has a restricted range, and toKey lies outside the bounds of the range you will cause the error java.lang.IllegalArgumentException.",['java.lang.IllegalArgumentException']
GenericDeclaration.getTypeParameters(),Did you cause the error java.lang.reflect.GenericSignatureFormatError?, - if the generic signature of this generic declaration does not conform to the format specified in The Java™ Virtual Machine Specification you will cause the error java.lang.reflect.GenericSignatureFormatError.,['java.lang.reflect.GenericSignatureFormatError']
ClassLoader.getParent(),Did you cause the error java.lang.SecurityException?, - If a security manager exists and its checkPermission method doesn't allow access to this class loader's parent class loader. you will cause the error java.lang.SecurityException.,['java.lang.SecurityException']
BitSet.flip(int bitIndex),Did you cause the error java.lang.IndexOutOfBoundsException?, - if the specified index is negative you will cause the error java.lang.IndexOutOfBoundsException.,['java.lang.IndexOutOfBoundsException']
Collections.reverse(List<?> list),Did you cause the error java.lang.UnsupportedOperationException?, - if the specified list or its list-iterator does not support the set operation. you will cause the error java.lang.UnsupportedOperationException.,['java.lang.UnsupportedOperationException']
Scanner.nextLong(),Did you cause the error java.util.InputMismatchException?," - if the next token does not match the Integer regular expression, or is out of range you will cause the error java.util.InputMismatchException.",['java.util.InputMismatchException']
Scanner.nextLong(),Did you cause the error java.util.NoSuchElementException?, - if input is exhausted you will cause the error java.util.NoSuchElementException.,['java.util.NoSuchElementException']
Scanner.nextLong(),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
UUID.node(),Did you cause the error java.lang.UnsupportedOperationException?, - If this UUID is not a version 1 UUID you will cause the error java.lang.UnsupportedOperationException.,['java.lang.UnsupportedOperationException']
Integer.valueOf(String s),Did you cause the error java.lang.NumberFormatException?, - if the string cannot be parsed as an integer. you will cause the error java.lang.NumberFormatException.,['java.lang.NumberFormatException']
Scanner.hasNextByte(int radix),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
"Collections.newSetFromMap(Map<E,Boolean> map)",Did you cause the error java.lang.IllegalArgumentException?, - if map is not empty you will cause the error java.lang.IllegalArgumentException.,['java.lang.IllegalArgumentException']
Scanner.match(),Did you cause the error java.lang.IllegalStateException?, - If no match result is available you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
Scanner.hasNext(String pattern),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
Class.getEnclosingClass(),Did you cause the error java.lang.SecurityException?," - If a security manager, s, is present and the caller's class loader is not the same as or an ancestor of the class loader for the enclosing class and invocation of s.checkPackageAccess() denies access to the package of the enclosing class you will cause the error java.lang.SecurityException.",['java.lang.SecurityException']
Properties.load(InputStream inStream),Did you cause the error java.io.IOException?, - if an error occurred when reading from the input stream. you will cause the error java.io.IOException.,['java.io.IOException']
Properties.load(InputStream inStream),Did you cause the error java.lang.IllegalArgumentException?, - if the input stream contains a malformed Unicode escape sequence. you will cause the error java.lang.IllegalArgumentException.,['java.lang.IllegalArgumentException']
Scanner.hasNextDouble(),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
StringBuffer.substring(int start),Did you cause the error java.lang.StringIndexOutOfBoundsException?," - if start is less than zero, or greater than the length of this object. you will cause the error java.lang.StringIndexOutOfBoundsException.",['java.lang.StringIndexOutOfBoundsException']
SplittableRandom.doubles(long streamSize),Did you cause the error java.lang.IllegalArgumentException?, - if streamSize is less than zero you will cause the error java.lang.IllegalArgumentException.,['java.lang.IllegalArgumentException']
Character.getName(int codePoint),Did you cause the error java.lang.IllegalArgumentException?, - if the specified codePoint is not a valid Unicode code point. you will cause the error java.lang.IllegalArgumentException.,['java.lang.IllegalArgumentException']
Scanner.next(String pattern),Did you cause the error java.util.NoSuchElementException?, - if no such tokens are available you will cause the error java.util.NoSuchElementException.,['java.util.NoSuchElementException']
Scanner.next(String pattern),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
Deque.removeFirstOccurrence(Object o),Did you cause the error java.lang.ClassCastException?, - if the class of the specified element is incompatible with this deque (optional) you will cause the error java.lang.ClassCastException.,['java.lang.ClassCastException']
Deque.removeFirstOccurrence(Object o),Did you cause the error java.lang.NullPointerException?, - if the specified element is null and this deque does not permit null elements (optional) you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
String.codePointBefore(int index),Did you cause the error java.lang.IndexOutOfBoundsException?, - if the index argument is less than 1 or greater than the length of this string. you will cause the error java.lang.IndexOutOfBoundsException.,['java.lang.IndexOutOfBoundsException']
Class.forName(String className),Did you cause the error java.lang.LinkageError?, - if the linkage fails you will cause the error java.lang.LinkageError.,['java.lang.LinkageError']
Class.forName(String className),Did you cause the error java.lang.ExceptionInInitializerError?, - if the initialization provoked by this method fails you will cause the error java.lang.ExceptionInInitializerError.,['java.lang.ExceptionInInitializerError']
Class.forName(String className),Did you cause the error java.lang.ClassNotFoundException?, - if the class cannot be located you will cause the error java.lang.ClassNotFoundException.,['java.lang.ClassNotFoundException']
Scanner.nextShort(),Did you cause the error java.util.InputMismatchException?," - if the next token does not match the Integer regular expression, or is out of range you will cause the error java.util.InputMismatchException.",['java.util.InputMismatchException']
Scanner.nextShort(),Did you cause the error java.util.NoSuchElementException?, - if input is exhausted you will cause the error java.util.NoSuchElementException.,['java.util.NoSuchElementException']
Scanner.nextShort(),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
Scanner.nextLong(int radix),Did you cause the error java.util.InputMismatchException?," - if the next token does not match the Integer regular expression, or is out of range you will cause the error java.util.InputMismatchException.",['java.util.InputMismatchException']
Scanner.nextLong(int radix),Did you cause the error java.util.NoSuchElementException?, - if input is exhausted you will cause the error java.util.NoSuchElementException.,['java.util.NoSuchElementException']
Scanner.nextLong(int radix),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
PrimitiveIterator.forEachRemaining(IntConsumer action),Did you cause the error java.lang.NullPointerException?, - if the specified action is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Locale.Builder.setLocale(Locale locale),Did you cause the error java.util.IllformedLocaleException?, - if locale has any ill-formed fields. you will cause the error java.util.IllformedLocaleException.,['java.util.IllformedLocaleException']
Locale.Builder.setLocale(Locale locale),Did you cause the error java.lang.NullPointerException?, - if locale is null. you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Spliterator.forEachRemaining(Consumer<? super T> action),Did you cause the error java.lang.NullPointerException?, - if the specified action is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
ClassLoader.getSystemClassLoader(),Did you cause the error java.lang.SecurityException?, - If a security manager exists and its checkPermission method doesn't allow access to the system class loader. you will cause the error java.lang.SecurityException.,['java.lang.SecurityException']
ClassLoader.getSystemClassLoader(),Did you cause the error java.lang.IllegalStateException?," - If invoked recursively during the construction of the class loader specified by the ""java.system.class.loader"" property. you will cause the error java.lang.IllegalStateException.",['java.lang.IllegalStateException']
ClassLoader.getSystemClassLoader(),Did you cause the error java.lang.Error?," - If the system property ""java.system.class.loader"" is defined but the named class could not be loaded, the provider class does not define the required constructor, or an exception is thrown by that constructor when it is invoked. The underlying cause of the error can be retrieved via the Throwable.getCause() method. you will cause the error java.lang.Error.",['java.lang.Error']
IntSummaryStatistics.combine(IntSummaryStatistics other),Did you cause the error java.lang.NullPointerException?, - if other is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Math.incrementExact(int a),Did you cause the error java.lang.ArithmeticException?, - if the result overflows an int you will cause the error java.lang.ArithmeticException.,['java.lang.ArithmeticException']
SplittableRandom.nextDouble(double bound),Did you cause the error java.lang.IllegalArgumentException?, - if bound is not positive you will cause the error java.lang.IllegalArgumentException.,['java.lang.IllegalArgumentException']
BitSet.previousClearBit(int fromIndex),Did you cause the error java.lang.IndexOutOfBoundsException?, - if the specified index is less than -1 you will cause the error java.lang.IndexOutOfBoundsException.,['java.lang.IndexOutOfBoundsException']
Flushable.flush(),Did you cause the error java.util.FormatterClosedException?, - If this formatter has been closed by invoking its close() method you will cause the error java.util.FormatterClosedException.,['java.util.FormatterClosedException']
Spliterators.iterator(Spliterator.OfLong spliterator),Did you cause the error java.lang.NullPointerException?, - if the given spliterator is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Collections.shuffle(List<?> list),Did you cause the error java.lang.UnsupportedOperationException?, - if the specified list or its list-iterator does not support the set operation. you will cause the error java.lang.UnsupportedOperationException.,['java.lang.UnsupportedOperationException']
Class.newInstance(),Did you cause the error java.lang.IllegalAccessException?, - if the class or its nullary constructor is not accessible. you will cause the error java.lang.IllegalAccessException.,['java.lang.IllegalAccessException']
Class.newInstance(),Did you cause the error java.lang.InstantiationException?," - if this Class represents an abstract class, an interface, an array class, a primitive type, or void; or if the class has no nullary constructor; or if the instantiation fails for some other reason. you will cause the error java.lang.InstantiationException.",['java.lang.InstantiationException']
Class.newInstance(),Did you cause the error java.lang.ExceptionInInitializerError?, - if the initialization provoked by this method fails. you will cause the error java.lang.ExceptionInInitializerError.,['java.lang.ExceptionInInitializerError']
Class.newInstance(),Did you cause the error java.lang.SecurityException?," - If a security manager, s, is present and the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of s.checkPackageAccess() denies access to the package of this class. you will cause the error java.lang.SecurityException.",['java.lang.SecurityException']
"NavigableMap.subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)",Did you cause the error java.lang.ClassCastException?,toKey - high endpoint of the keys in the returned map you will cause the error java.lang.ClassCastException.,['java.lang.ClassCastException']
"NavigableMap.subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)",Did you cause the error java.lang.NullPointerException?,toInclusive - true if the high endpoint is to be included in the returned view you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
"NavigableMap.subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)",Did you cause the error java.lang.IllegalArgumentException?,a view of the portion of this map whose keys range from fromKey to toKey you will cause the error java.lang.IllegalArgumentException.,['java.lang.IllegalArgumentException']
"NavigableMap.subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)",Did you cause the error java.lang.ClassCastException?," - if fromKey and toKey cannot be compared to one another using this map's comparator (or, if the map has no comparator, using natural ordering). Implementations may, but are not required to, throw this exception if fromKey or toKey cannot be compared to keys currently in the map. you will cause the error java.lang.ClassCastException.",['java.lang.ClassCastException']
"NavigableMap.subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)",Did you cause the error java.lang.NullPointerException?," - if fromKey or toKey is null and this map uses natural ordering, or its comparator does not permit null keys you will cause the error java.lang.NullPointerException.",['java.lang.NullPointerException']
"NavigableMap.subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)",Did you cause the error java.lang.IllegalArgumentException?," - if fromKey is greater than toKey; or if this map itself has a restricted range, and fromKey or toKey lies outside the bounds of the range you will cause the error java.lang.IllegalArgumentException.",['java.lang.IllegalArgumentException']
StringBuilder.deleteCharAt(int index),Did you cause the error java.lang.StringIndexOutOfBoundsException?, - if the index is negative or greater than or equal to length(). you will cause the error java.lang.StringIndexOutOfBoundsException.,['java.lang.StringIndexOutOfBoundsException']
Spliterator.tryAdvance(Consumer<? super T> action),Did you cause the error java.lang.NullPointerException?, - if the specified action is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Scanner.nextShort(int radix),Did you cause the error java.util.InputMismatchException?," - if the next token does not match the Integer regular expression, or is out of range you will cause the error java.util.InputMismatchException.",['java.util.InputMismatchException']
Scanner.nextShort(int radix),Did you cause the error java.util.NoSuchElementException?, - if input is exhausted you will cause the error java.util.NoSuchElementException.,['java.util.NoSuchElementException']
Scanner.nextShort(int radix),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
Scanner.nextBigDecimal(),Did you cause the error java.util.InputMismatchException?," - if the next token does not match the Decimal regular expression, or is out of range you will cause the error java.util.InputMismatchException.",['java.util.InputMismatchException']
Scanner.nextBigDecimal(),Did you cause the error java.util.NoSuchElementException?, - if the input is exhausted you will cause the error java.util.NoSuchElementException.,['java.util.NoSuchElementException']
Scanner.nextBigDecimal(),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
Scanner.hasNextInt(int radix),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
"Spliterator.OfPrimitive<T,T_CONS,T_SPLITR.forEachRemaining(T CONS action)",Did you cause the error java.lang.NullPointerException?, - if the specified action is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Integer.parseInt(String s),Did you cause the error java.lang.NumberFormatException?, - if the string does not contain a parsable integer. you will cause the error java.lang.NumberFormatException.,['java.lang.NumberFormatException']
ListIterator.set(E e),Did you cause the error java.lang.UnsupportedOperationException?, - if the set operation is not supported by this list iterator you will cause the error java.lang.UnsupportedOperationException.,['java.lang.UnsupportedOperationException']
ListIterator.set(E e),Did you cause the error java.lang.ClassCastException?, - if the class of the specified element prevents it from being added to this list you will cause the error java.lang.ClassCastException.,['java.lang.ClassCastException']
ListIterator.set(E e),Did you cause the error java.lang.IllegalArgumentException?, - if some aspect of the specified element prevents it from being added to this list you will cause the error java.lang.IllegalArgumentException.,['java.lang.IllegalArgumentException']
ListIterator.set(E e),Did you cause the error java.lang.IllegalStateException?," - if neither next nor previous have been called, or remove or add have been called after the last call to next or previous you will cause the error java.lang.IllegalStateException.",['java.lang.IllegalStateException']
Deque.offer(E e),Did you cause the error java.lang.NullPointerException?, - if the specified element is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
ThreadLocal.withInitial(Supplier<? extends S> supplier),Did you cause the error java.lang.NullPointerException?, - if the specified supplier is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Formatter.out(),Did you cause the error java.util.FormatterClosedException?, - If this formatter has been closed by invoking its close() method you will cause the error java.util.FormatterClosedException.,['java.util.FormatterClosedException']
Scanner.hasNext(Pattern pattern),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
Short.parseShort(String s),Did you cause the error java.lang.NumberFormatException?, - If the string does not contain a parsable short. you will cause the error java.lang.NumberFormatException.,['java.lang.NumberFormatException']
Hashtable.contains(Object value),Did you cause the error java.lang.NullPointerException?, - if the value is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Package.isCompatibleWith(String desired),Did you cause the error java.lang.NumberFormatException?, - if the desired or current version is not of the correct dotted form. you will cause the error java.lang.NumberFormatException.,['java.lang.NumberFormatException']
Spliterators.iterator(Spliterator.OfDouble spliterator),Did you cause the error java.lang.NullPointerException?, - if the given spliterator is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Scanner.nextInt(),Did you cause the error java.util.InputMismatchException?," - if the next token does not match the Integer regular expression, or is out of range you will cause the error java.util.InputMismatchException.",['java.util.InputMismatchException']
Scanner.nextInt(),Did you cause the error java.util.NoSuchElementException?, - if input is exhausted you will cause the error java.util.NoSuchElementException.,['java.util.NoSuchElementException']
Scanner.nextInt(),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
Scanner.hasNextLine(),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
ClassLoader.getSystemResources(String name),Did you cause the error java.io.IOException?, - If I/O errors occur you will cause the error java.io.IOException.,['java.io.IOException']
UUID.clockSequence(),Did you cause the error java.lang.UnsupportedOperationException?, - If this UUID is not a version 1 UUID you will cause the error java.lang.UnsupportedOperationException.,['java.lang.UnsupportedOperationException']
Iterator.forEachRemaining(Consumer<? super E> action),Did you cause the error java.lang.NullPointerException?, - if the specified action is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Spliterators.iterator(Spliterator.OfInt spliterator),Did you cause the error java.lang.NullPointerException?, - if the given spliterator is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Comparator.thenComparing(Comparator<? super T> other),Did you cause the error java.lang.NullPointerException?, - if the argument is null. you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Scanner.hasNextByte(),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
Stack.peek(),Did you cause the error java.util.EmptyStackException?, - if this stack is empty. you will cause the error java.util.EmptyStackException.,['java.util.EmptyStackException']
Observable.addObserver(Observer o),Did you cause the error java.lang.NullPointerException?, - if the parameter o is null. you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Scanner.nextLine(),Did you cause the error java.util.NoSuchElementException?, - if no line was found you will cause the error java.util.NoSuchElementException.,['java.util.NoSuchElementException']
Scanner.nextLine(),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
Math.negateExact(int a),Did you cause the error java.lang.ArithmeticException?, - if the result overflows an int you will cause the error java.lang.ArithmeticException.,['java.lang.ArithmeticException']
SplittableRandom.longs(long streamSize),Did you cause the error java.lang.IllegalArgumentException?, - if streamSize is less than zero you will cause the error java.lang.IllegalArgumentException.,['java.lang.IllegalArgumentException']
Scanner.findInLine(String pattern),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
Locale.Builder.setScript(String script),Did you cause the error java.util.IllformedLocaleException?, - if script is ill-formed you will cause the error java.util.IllformedLocaleException.,['java.util.IllformedLocaleException']
Character.UnicodeScript.valueOf(String name),Did you cause the error java.lang.IllegalArgumentException?, - if this enum type has no constant with the specified name you will cause the error java.lang.IllegalArgumentException.,['java.lang.IllegalArgumentException']
Character.UnicodeScript.valueOf(String name),Did you cause the error java.lang.NullPointerException?, - if the argument is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
AutoCloseable.close(),Did you cause the error java.lang.Exception?, - if this resource cannot be closed you will cause the error java.lang.Exception.,['java.lang.Exception']
UUID.timestamp(),Did you cause the error java.lang.UnsupportedOperationException?, - If this UUID is not a version 1 UUID you will cause the error java.lang.UnsupportedOperationException.,['java.lang.UnsupportedOperationException']
ClassLoader.findResources(String name),Did you cause the error java.io.IOException?, - If I/O errors occur you will cause the error java.io.IOException.,['java.io.IOException']
Scanner.hasNextLong(),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
Class.cast(Object obj),Did you cause the error java.lang.ClassCastException?, - if the object is not null and is not assignable to the type T. you will cause the error java.lang.ClassCastException.,['java.lang.ClassCastException']
BitSet.nextClearBit(int fromIndex),Did you cause the error java.lang.IndexOutOfBoundsException?, - if the specified index is negative you will cause the error java.lang.IndexOutOfBoundsException.,['java.lang.IndexOutOfBoundsException']
StringJoiner.setEmptyValue(CharSequence emptyValue),Did you cause the error java.lang.NullPointerException?, - when the emptyValue parameter is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Spliterators.iterator(Spliterator<? extends T> spliterator),Did you cause the error java.lang.NullPointerException?, - if the given spliterator is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
ListIterator.add(E e),Did you cause the error java.lang.UnsupportedOperationException?, - if the add method is not supported by this list iterator you will cause the error java.lang.UnsupportedOperationException.,['java.lang.UnsupportedOperationException']
ListIterator.add(E e),Did you cause the error java.lang.ClassCastException?, - if the class of the specified element prevents it from being added to this list you will cause the error java.lang.ClassCastException.,['java.lang.ClassCastException']
ListIterator.add(E e),Did you cause the error java.lang.IllegalArgumentException?, - if some aspect of this element prevents it from being added to this list you will cause the error java.lang.IllegalArgumentException.,['java.lang.IllegalArgumentException']
"List.subList(int fromIndex, int toIndex)",Did you cause the error java.lang.IndexOutOfBoundsException?,a view of the specified range within this List you will cause the error java.lang.IndexOutOfBoundsException.,['java.lang.IndexOutOfBoundsException']
"List.subList(int fromIndex, int toIndex)",Did you cause the error java.lang.IllegalArgumentException?,IndexOutOfBoundsException - if an endpoint index value is out of range (fromIndex < 0 || toIndex > size) you will cause the error java.lang.IllegalArgumentException.,['java.lang.IllegalArgumentException']
"List.subList(int fromIndex, int toIndex)",Did you cause the error java.lang.IndexOutOfBoundsException?,IllegalArgumentException - if the endpoint indices are out of order (fromIndex > toIndex) you will cause the error java.lang.IndexOutOfBoundsException.,['java.lang.IndexOutOfBoundsException']
Class.asSubclass(Class<U> clazz),Did you cause the error java.lang.ClassCastException?," - if this Class object does not represent a subclass of the specified class (here ""subclass"" includes the class itself). you will cause the error java.lang.ClassCastException.",['java.lang.ClassCastException']
Dictionary.remove(Object key),Did you cause the error java.lang.NullPointerException?, - if key is null. you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
"CharSequence.subSequence(int start, int end)",Did you cause the error java.lang.IndexOutOfBoundsException?,the specified subsequence. you will cause the error java.lang.IndexOutOfBoundsException.,['java.lang.IndexOutOfBoundsException']
"CharSequence.subSequence(int start, int end)",Did you cause the error java.lang.IndexOutOfBoundsException?," - if start or end are negative, if end is greater than length(), or if start is greater than end you will cause the error java.lang.IndexOutOfBoundsException.",['java.lang.IndexOutOfBoundsException']
Scanner.useRadix(int radix),Did you cause the error java.lang.IllegalArgumentException?, - if radix is out of range you will cause the error java.lang.IllegalArgumentException.,['java.lang.IllegalArgumentException']
Currency.getInstance(String currencyCode),Did you cause the error java.lang.NullPointerException?, - if currencyCode is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Currency.getInstance(String currencyCode),Did you cause the error java.lang.IllegalArgumentException?, - if currencyCode is not a supported ISO 4217 code. you will cause the error java.lang.IllegalArgumentException.,['java.lang.IllegalArgumentException']
Locale.Builder.setLanguage(String language),Did you cause the error java.util.IllformedLocaleException?, - if language is ill-formed you will cause the error java.util.IllformedLocaleException.,['java.util.IllformedLocaleException']
Map.Entry.getKey(),Did you cause the error java.lang.IllegalStateException?," - implementations may, but are not required to, throw this exception if the entry has been removed from the backing map. you will cause the error java.lang.IllegalStateException.",['java.lang.IllegalStateException']
Scanner.skip(Pattern pattern),Did you cause the error java.util.NoSuchElementException?, - if the specified pattern is not found you will cause the error java.util.NoSuchElementException.,['java.util.NoSuchElementException']
Scanner.skip(Pattern pattern),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
Properties.load(Reader reader),Did you cause the error java.io.IOException?, - if an error occurred when reading from the input stream. you will cause the error java.io.IOException.,['java.io.IOException']
Properties.load(Reader reader),Did you cause the error java.lang.IllegalArgumentException?, - if a malformed Unicode escape appears in the input. you will cause the error java.lang.IllegalArgumentException.,['java.lang.IllegalArgumentException']
ClassLoader.loadClass(String name),Did you cause the error java.lang.ClassNotFoundException?, - If the class was not found you will cause the error java.lang.ClassNotFoundException.,['java.lang.ClassNotFoundException']
ProcessBuilder.Redirect.from(File file),Did you cause the error java.lang.NullPointerException?, - if the specified file is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Scanner.nextByte(int radix),Did you cause the error java.util.InputMismatchException?," - if the next token does not match the Integer regular expression, or is out of range you will cause the error java.util.InputMismatchException.",['java.util.InputMismatchException']
Scanner.nextByte(int radix),Did you cause the error java.util.NoSuchElementException?, - if input is exhausted you will cause the error java.util.NoSuchElementException.,['java.util.NoSuchElementException']
Scanner.nextByte(int radix),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
Currency.getSymbol(Locale locale),Did you cause the error java.lang.NullPointerException?, - if locale is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Formatter.BigDecimalLayoutForm.valueOf(String name),Did you cause the error java.lang.IllegalArgumentException?, - if this enum type has no constant with the specified name you will cause the error java.lang.IllegalArgumentException.,['java.lang.IllegalArgumentException']
Formatter.BigDecimalLayoutForm.valueOf(String name),Did you cause the error java.lang.NullPointerException?, - if the argument is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Scanner.nextBigInteger(int radix),Did you cause the error java.util.InputMismatchException?," - if the next token does not match the Integer regular expression, or is out of range you will cause the error java.util.InputMismatchException.",['java.util.InputMismatchException']
Scanner.nextBigInteger(int radix),Did you cause the error java.util.NoSuchElementException?, - if the input is exhausted you will cause the error java.util.NoSuchElementException.,['java.util.NoSuchElementException']
Scanner.nextBigInteger(int radix),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
Character.UnicodeScript.forName(String scriptName),Did you cause the error java.lang.IllegalArgumentException?, - if scriptName is an invalid name you will cause the error java.lang.IllegalArgumentException.,['java.lang.IllegalArgumentException']
Character.UnicodeScript.forName(String scriptName),Did you cause the error java.lang.NullPointerException?, - if scriptName is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Scanner.nextBigInteger(),Did you cause the error java.util.InputMismatchException?," - if the next token does not match the Integer regular expression, or is out of range you will cause the error java.util.InputMismatchException.",['java.util.InputMismatchException']
Scanner.nextBigInteger(),Did you cause the error java.util.NoSuchElementException?, - if the input is exhausted you will cause the error java.util.NoSuchElementException.,['java.util.NoSuchElementException']
Scanner.nextBigInteger(),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
StringJoiner.merge(StringJoiner other),Did you cause the error java.lang.NullPointerException?, - if the other StringJoiner is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Locale.Builder.setVariant(String variant),Did you cause the error java.util.IllformedLocaleException?, - if variant is ill-formed you will cause the error java.util.IllformedLocaleException.,['java.util.IllformedLocaleException']
ProcessBuilder.Redirect.appendTo(File file),Did you cause the error java.lang.NullPointerException?, - if the specified file is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Currency.getDisplayName(Locale locale),Did you cause the error java.lang.NullPointerException?, - if locale is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Scanner.hasNextInt(),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
SplittableRandom.ints(long streamSize),Did you cause the error java.lang.IllegalArgumentException?, - if streamSize is less than zero you will cause the error java.lang.IllegalArgumentException.,['java.lang.IllegalArgumentException']
Class.getEnclosingConstructor(),Did you cause the error java.lang.SecurityException?," - If a security manager, s, is present and any of the following conditions is met: the caller's class loader is not the same as the class loader of the enclosing class and invocation of s.checkPermission method with RuntimePermission(""accessDeclaredMembers"") denies access to the constructors within the enclosing class the caller's class loader is not the same as or an ancestor of the class loader for the enclosing class and invocation of s.checkPackageAccess() denies access to the package of the enclosing class you will cause the error java.lang.SecurityException.",['java.lang.SecurityException']
SecurityManager.checkPermission(Permission perm),Did you cause the error java.lang.SecurityException?, - if access is not permitted based on the current security policy. you will cause the error java.lang.SecurityException.,['java.lang.SecurityException']
SecurityManager.checkPermission(Permission perm),Did you cause the error java.lang.NullPointerException?, - if the permission argument is null. you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Scanner.nextInt(int radix),Did you cause the error java.util.InputMismatchException?," - if the next token does not match the Integer regular expression, or is out of range you will cause the error java.util.InputMismatchException.",['java.util.InputMismatchException']
Scanner.nextInt(int radix),Did you cause the error java.util.NoSuchElementException?, - if input is exhausted you will cause the error java.util.NoSuchElementException.,['java.util.NoSuchElementException']
Scanner.nextInt(int radix),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
ProcessBuilder.Redirect.Type.valueOf(String name),Did you cause the error java.lang.IllegalArgumentException?, - if this enum type has no constant with the specified name you will cause the error java.lang.IllegalArgumentException.,['java.lang.IllegalArgumentException']
ProcessBuilder.Redirect.Type.valueOf(String name),Did you cause the error java.lang.NullPointerException?, - if the argument is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
ProcessBuilder.Redirect.to(File file),Did you cause the error java.lang.NullPointerException?, - if the specified file is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
UUID.fromString(String name),Did you cause the error java.lang.IllegalArgumentException?, - If name does not conform to the string representation as described in toString() you will cause the error java.lang.IllegalArgumentException.,['java.lang.IllegalArgumentException']
BitSet.get(int bitIndex),Did you cause the error java.lang.IndexOutOfBoundsException?, - if the specified index is negative you will cause the error java.lang.IndexOutOfBoundsException.,['java.lang.IndexOutOfBoundsException']
Formatter.locale(),Did you cause the error java.util.FormatterClosedException?, - If this formatter has been closed by invoking its close() method you will cause the error java.util.FormatterClosedException.,['java.util.FormatterClosedException']
Scanner.hasNextLong(int radix),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
Scanner.findInLine(Pattern pattern),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
Scanner.hasNextFloat(),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
Integer.parseUnsignedInt(String s),Did you cause the error java.lang.NumberFormatException?, - if the string does not contain a parsable unsigned integer. you will cause the error java.lang.NumberFormatException.,['java.lang.NumberFormatException']
SplittableRandom.nextInt(int bound),Did you cause the error java.lang.IllegalArgumentException?, - if bound is not positive you will cause the error java.lang.IllegalArgumentException.,['java.lang.IllegalArgumentException']
Class.getEnclosingMethod(),Did you cause the error java.lang.SecurityException?," - If a security manager, s, is present and any of the following conditions is met: the caller's class loader is not the same as the class loader of the enclosing class and invocation of s.checkPermission method with RuntimePermission(""accessDeclaredMembers"") denies access to the methods within the enclosing class the caller's class loader is not the same as or an ancestor of the class loader for the enclosing class and invocation of s.checkPackageAccess() denies access to the package of the enclosing class you will cause the error java.lang.SecurityException.",['java.lang.SecurityException']
Scanner.next(Pattern pattern),Did you cause the error java.util.NoSuchElementException?, - if no more tokens are available you will cause the error java.util.NoSuchElementException.,['java.util.NoSuchElementException']
Scanner.next(Pattern pattern),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
StringBuffer.deleteCharAt(int index),Did you cause the error java.lang.StringIndexOutOfBoundsException?, - if the index is negative or greater than or equal to length(). you will cause the error java.lang.StringIndexOutOfBoundsException.,['java.lang.StringIndexOutOfBoundsException']
Iterable.forEach(Consumer<? super T> action),Did you cause the error java.lang.NullPointerException?, - if the specified action is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Scanner.nextByte(),Did you cause the error java.util.InputMismatchException?," - if the next token does not match the Integer regular expression, or is out of range you will cause the error java.util.InputMismatchException.",['java.util.InputMismatchException']
Scanner.nextByte(),Did you cause the error java.util.NoSuchElementException?, - if input is exhausted you will cause the error java.util.NoSuchElementException.,['java.util.NoSuchElementException']
Scanner.nextByte(),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
Math.negateExact(long a),Did you cause the error java.lang.ArithmeticException?, - if the result overflows a long you will cause the error java.lang.ArithmeticException.,['java.lang.ArithmeticException']
OptionalInt.orElseGet(IntSupplier other),Did you cause the error java.lang.NullPointerException?, - if value is not present and other is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Date.after(Date when),Did you cause the error java.lang.NullPointerException?, - if when is null. you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Date.from(Instant instant),Did you cause the error java.lang.NullPointerException?, - if instant is null. you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Date.from(Instant instant),Did you cause the error java.lang.IllegalArgumentException?, - if the instant is too large to represent as a Date you will cause the error java.lang.IllegalArgumentException.,['java.lang.IllegalArgumentException']
BitSet.previousSetBit(int fromIndex),Did you cause the error java.lang.IndexOutOfBoundsException?, - if the specified index is less than -1 you will cause the error java.lang.IndexOutOfBoundsException.,['java.lang.IndexOutOfBoundsException']
Comparable.compareTo(Date anotherDate),Did you cause the error java.lang.NullPointerException?, - if anotherDate is null. you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
BitSet.nextSetBit(int fromIndex),Did you cause the error java.lang.IndexOutOfBoundsException?, - if the specified index is negative you will cause the error java.lang.IndexOutOfBoundsException.,['java.lang.IndexOutOfBoundsException']
ClassLoader.findClass(String name),Did you cause the error java.lang.ClassNotFoundException?, - If the class could not be found you will cause the error java.lang.ClassNotFoundException.,['java.lang.ClassNotFoundException']
"Enum.putAll(Map<? extends K,? extends V> m)",Did you cause the error java.lang.NullPointerException?," - the specified map is null, or if one or more keys in the specified map are null you will cause the error java.lang.NullPointerException.",['java.lang.NullPointerException']
Locale.Builder.setRegion(String region),Did you cause the error java.util.IllformedLocaleException?, - if region is ill-formed you will cause the error java.util.IllformedLocaleException.,['java.util.IllformedLocaleException']
Math.decrementExact(int a),Did you cause the error java.lang.ArithmeticException?, - if the result overflows an int you will cause the error java.lang.ArithmeticException.,['java.lang.ArithmeticException']
Comparable.compareTo(T o),Did you cause the error java.lang.NullPointerException?, - if the specified object is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Comparable.compareTo(T o),Did you cause the error java.lang.ClassCastException?, - if the specified object's type prevents it from being compared to this object. you will cause the error java.lang.ClassCastException.,['java.lang.ClassCastException']
Locale.FilteringMode.valueOf(String name),Did you cause the error java.lang.IllegalArgumentException?, - if this enum type has no constant with the specified name you will cause the error java.lang.IllegalArgumentException.,['java.lang.IllegalArgumentException']
Locale.FilteringMode.valueOf(String name),Did you cause the error java.lang.NullPointerException?, - if the argument is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Scanner.nextFloat(),Did you cause the error java.util.InputMismatchException?," - if the next token does not match the Float regular expression, or is out of range you will cause the error java.util.InputMismatchException.",['java.util.InputMismatchException']
Scanner.nextFloat(),Did you cause the error java.util.NoSuchElementException?, - if input is exhausted you will cause the error java.util.NoSuchElementException.,['java.util.NoSuchElementException']
Scanner.nextFloat(),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
Deque.removeLastOccurrence(Object o),Did you cause the error java.lang.ClassCastException?, - if the class of the specified element is incompatible with this deque (optional) you will cause the error java.lang.ClassCastException.,['java.lang.ClassCastException']
Deque.removeLastOccurrence(Object o),Did you cause the error java.lang.NullPointerException?, - if the specified element is null and this deque does not permit null elements (optional) you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
"Spliterator.OfPrimitive<T,T_CONS,T_SPLITR.tryAdvance(T CONS action)",Did you cause the error java.lang.NullPointerException?, - if the specified action is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
System.inheritedChannel(),Did you cause the error java.io.IOException?, - If an I/O error occurs you will cause the error java.io.IOException.,['java.io.IOException']
System.inheritedChannel(),Did you cause the error java.lang.SecurityException?, - If a security manager is present and it does not permit access to the channel. you will cause the error java.lang.SecurityException.,['java.lang.SecurityException']
Scanner.hasNextBigDecimal(),Did you cause the error java.lang.IllegalStateException?, - if this scanner is closed you will cause the error java.lang.IllegalStateException.,['java.lang.IllegalStateException']
OptionalInt.ifPresent(IntConsumer consumer),Did you cause the error java.lang.NullPointerException?, - if value is present and consumer is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Calendar.Builder.setFields(int... fieldValuePairs),Did you cause the error java.lang.NullPointerException?, - if fieldValuePairs is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Calendar.Builder.setFields(int... fieldValuePairs),Did you cause the error java.lang.IllegalArgumentException?," - if any of fields are invalid, or if fieldValuePairs.length is an odd number. you will cause the error java.lang.IllegalArgumentException.",['java.lang.IllegalArgumentException']
Calendar.Builder.setFields(int... fieldValuePairs),Did you cause the error java.lang.IllegalStateException?," - if the instant value has been set, or if fields have been set too many (approximately Integer.MAX_VALUE) times. you will cause the error java.lang.IllegalStateException.",['java.lang.IllegalStateException']
Stack.pop(),Did you cause the error java.util.EmptyStackException?, - if this stack is empty. you will cause the error java.util.EmptyStackException.,['java.util.EmptyStackException']
PrimitiveIterator.forEachRemaining(LongConsumer action),Did you cause the error java.lang.NullPointerException?, - if the specified action is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
Math.decrementExact(long a),Did you cause the error java.lang.ArithmeticException?, - if the result overflows a long you will cause the error java.lang.ArithmeticException.,['java.lang.ArithmeticException']
Locale.Category.valueOf(String name),Did you cause the error java.lang.IllegalArgumentException?, - if this enum type has no constant with the specified name you will cause the error java.lang.IllegalArgumentException.,['java.lang.IllegalArgumentException']
Locale.Category.valueOf(String name),Did you cause the error java.lang.NullPointerException?, - if the argument is null you will cause the error java.lang.NullPointerException.,['java.lang.NullPointerException']
SplittableRandom.nextLong(long bound),Did you cause the error java.lang.IllegalArgumentException?, - if bound is not positive you will cause the error java.lang.IllegalArgumentException.,['java.lang.IllegalArgumentException']
Properties.list(PrintStream out),Did you cause the error java.lang.ClassCastException?, - if any key in this property list is not a string. you will cause the error java.lang.ClassCastException.,['java.lang.ClassCastException']
ListIterator.previous(),Did you cause the error java.util.NoSuchElementException?, - if the iteration has no previous element you will cause the error java.util.NoSuchElementException.,['java.util.NoSuchElementException']
Appendable.append(char c),what's the return of Appendable.append(char c)?,the return of Appendable.append(char c) should be a reference to this object..,"['return', 'Appendable.append(char c)']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
Object.equals(Object obj),what's the return of Object.equals(Object obj)?,"the return of Object.equals(Object obj) should be true if the objects are the same;
          false otherwise..","['return', 'Object.equals(Object obj)']"
Object.equals(Object obj),what's the parameter of Object.equals(Object obj)?,the parameter of Object.equals(Object obj) should be  the object to compare with..,"['parameter', 'Object.equals(Object obj)']"
Number.intValue(),what's the return of Number.intValue()?,the return of Number.intValue() should be the value of this Short as an int after a widening primitive conversion..,"['return', 'Number.intValue()']"
Number.longValue(),what's the return of Number.longValue()?,the return of Number.longValue() should be the value of this Short as a long after a widening primitive conversion..,"['return', 'Number.longValue()']"
Number.floatValue(),what's the return of Number.floatValue()?,the return of Number.floatValue() should be the value of this Short as a float after a widening primitive conversion..,"['return', 'Number.floatValue()']"
Number.doubleValue(),what's the return of Number.doubleValue()?,the return of Number.doubleValue() should be the value of this Short as a double after a widening primitive conversion..,"['return', 'Number.doubleValue()']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
Object.equals(Object obj),what's the return of Object.equals(Object obj)?,"the return of Object.equals(Object obj) should be true if the objects are the same;
          false otherwise..","['return', 'Object.equals(Object obj)']"
Object.equals(Object obj),what's the parameter of Object.equals(Object obj)?,the parameter of Object.equals(Object obj) should be  the object to compare with..,"['parameter', 'Object.equals(Object obj)']"
Character.valueOf(char c),what's the return of Character.valueOf(char c)?,"the return of Character.valueOf(char c) should be a Character instance representing the specified char value. If a new Character instance is not required, this method should generally be used in preference to the constructor Character(char), as this method is likely to yield significantly better space and time performance by caching frequently requested values. This method will always cache values in the range '\u0000' to '\u007F', inclusive, and may cache other values outside of this range..","['return', 'Character.valueOf(char c)']"
Character.charValue(),what's the return of Character.charValue()?,the return of Character.charValue() should be the value of this Character object..,"['return', 'Character.charValue()']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
Character.hashCode(char value),what's the return of Character.hashCode(char value)?,the return of Character.hashCode(char value) should be a hash code for a char value; compatible with Character.hashCode()..,"['return', 'Character.hashCode(char value)']"
Object.equals(Object obj),what's the return of Object.equals(Object obj)?,"the return of Object.equals(Object obj) should be true if the objects are the same;
          false otherwise..","['return', 'Object.equals(Object obj)']"
Object.equals(Object obj),what's the parameter of Object.equals(Object obj)?,the parameter of Object.equals(Object obj) should be  the object to compare with..,"['parameter', 'Object.equals(Object obj)']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
Character.toString(char c),what's the return of Character.toString(char c)?,the return of Character.toString(char c) should be a String object representing the specified char. The result is a string of length 1 consisting solely of the specified char..,"['return', 'Character.toString(char c)']"
Character.isValidCodePoint(int codePoint),what's the return of Character.isValidCodePoint(int codePoint)?,"the return of Character.isValidCodePoint(int codePoint) should be true if the specified code point value is between
         MIN_CODE_POINT and
         MAX_CODE_POINT inclusive;
         false otherwise..","['return', 'Character.isValidCodePoint(int codePoint)']"
Character.isBmpCodePoint(int codePoint),what's the return of Character.isBmpCodePoint(int codePoint)?,"the return of Character.isBmpCodePoint(int codePoint) should be true if the specified code point is between
         MIN_VALUE and MAX_VALUE inclusive;
         false otherwise..","['return', 'Character.isBmpCodePoint(int codePoint)']"
Character.isSupplementaryCodePoint(int codePoint),what's the return of Character.isSupplementaryCodePoint(int codePoint)?,"the return of Character.isSupplementaryCodePoint(int codePoint) should be true if the specified code point is between
         MIN_SUPPLEMENTARY_CODE_POINT and
         MAX_CODE_POINT inclusive;
         false otherwise..","['return', 'Character.isSupplementaryCodePoint(int codePoint)']"
Character.isHighSurrogate(char ch),what's the return of Character.isHighSurrogate(char ch)?,"the return of Character.isHighSurrogate(char ch) should be true if the char value is between
         MIN_HIGH_SURROGATE and
         MAX_HIGH_SURROGATE inclusive;
         false otherwise..","['return', 'Character.isHighSurrogate(char ch)']"
Character.isLowSurrogate(char ch),what's the return of Character.isLowSurrogate(char ch)?,"the return of Character.isLowSurrogate(char ch) should be true if the char value is between
         MIN_LOW_SURROGATE and
         MAX_LOW_SURROGATE inclusive;
         false otherwise..","['return', 'Character.isLowSurrogate(char ch)']"
Character.isSurrogate(char ch),what's the return of Character.isSurrogate(char ch)?,"the return of Character.isSurrogate(char ch) should be true if the char value is between
         MIN_SURROGATE and
         MAX_SURROGATE inclusive;
         false otherwise..","['return', 'Character.isSurrogate(char ch)']"
"Character.isSurrogatePair(char high, char low)","what's the return of Character.isSurrogatePair(char high, char low)?","the return of Character.isSurrogatePair(char high, char low) should be low - the low-surrogate code value to be tested.","['return', 'Character.isSurrogatePair(char high, char low)']"
Character.charCount(int codePoint),what's the return of Character.charCount(int codePoint)?,the return of Character.charCount(int codePoint) should be 2 if the character is a valid supplementary character; 1 otherwise..,"['return', 'Character.charCount(int codePoint)']"
"Character.toCodePoint(char high, char low)","what's the return of Character.toCodePoint(char high, char low)?","the return of Character.toCodePoint(char high, char low) should be low - the low-surrogate code unit.","['return', 'Character.toCodePoint(char high, char low)']"
"Character.codePointAt(CharSequence seq, int index)","what's the return of Character.codePointAt(CharSequence seq, int index)?","the return of Character.codePointAt(CharSequence seq, int index) should be the code point at the given index of the CharSequence. If the char value at the given index in the CharSequence is in the high-surrogate range, the following index is less than the length of the CharSequence, and the char value at the following index is in the low-surrogate range, then the supplementary code point corresponding to this surrogate pair is returned. Otherwise, the char value at the given index is returned..","['return', 'Character.codePointAt(CharSequence seq, int index)']"
"Character.codePointAt(CharSequence seq, int index)","what's the parameter of Character.codePointAt(CharSequence seq, int index)?","the parameter of Character.codePointAt(CharSequence seq, int index) should be  a sequence of char values (Unicode code
 units).","['parameter', 'Character.codePointAt(CharSequence seq, int index)']"
"Character.codePointAt(char[] a, int index)","what's the return of Character.codePointAt(char[] a, int index)?","the return of Character.codePointAt(char[] a, int index) should be the code point at the given index of the char array. If the char value at the given index in the char array is in the high-surrogate range, the following index is less than the length of the char array, and the char value at the following index is in the low-surrogate range, then the supplementary code point corresponding to this surrogate pair is returned. Otherwise, the char value at the given index is returned..","['return', 'Character.codePointAt(char[] a, int index)']"
"Character.codePointAt(char[] a, int index, int limit)","what's the return of Character.codePointAt(char[] a, int index, int limit)?","the return of Character.codePointAt(char[] a, int index, int limit) should be the code point at the given index of the char array, where only array elements with index less than limit can be used. If the char value at the given index in the char array is in the high-surrogate range, the following index is less than the limit, and the char value at the following index is in the low-surrogate range, then the supplementary code point corresponding to this surrogate pair is returned. Otherwise, the char value at the given index is returned..","['return', 'Character.codePointAt(char[] a, int index, int limit)']"
"Character.codePointBefore(CharSequence seq, int index)","what's the return of Character.codePointBefore(CharSequence seq, int index)?","the return of Character.codePointBefore(CharSequence seq, int index) should be the code point preceding the given index of the CharSequence. If the char value at (index - 1) in the CharSequence is in the low-surrogate range, (index - 2) is not negative, and the char value at (index - 2) in the CharSequence is in the high-surrogate range, then the supplementary code point corresponding to this surrogate pair is returned. Otherwise, the char value at (index - 1) is returned..","['return', 'Character.codePointBefore(CharSequence seq, int index)']"
"Character.codePointBefore(CharSequence seq, int index)","what's the parameter of Character.codePointBefore(CharSequence seq, int index)?","the parameter of Character.codePointBefore(CharSequence seq, int index) should be  the CharSequence instance.","['parameter', 'Character.codePointBefore(CharSequence seq, int index)']"
"Character.codePointBefore(char[] a, int index)","what's the return of Character.codePointBefore(char[] a, int index)?","the return of Character.codePointBefore(char[] a, int index) should be the code point preceding the given index of the char array. If the char value at (index - 1) in the char array is in the low-surrogate range, (index - 2) is not negative, and the char value at (index - 2) in the char array is in the high-surrogate range, then the supplementary code point corresponding to this surrogate pair is returned. Otherwise, the char value at (index - 1) is returned..","['return', 'Character.codePointBefore(char[] a, int index)']"
"Character.codePointBefore(char[] a, int index, int start)","what's the return of Character.codePointBefore(char[] a, int index, int start)?","the return of Character.codePointBefore(char[] a, int index, int start) should be the code point preceding the given index of the char array, where only array elements with index greater than or equal to start can be used. If the char value at (index - 1) in the char array is in the low-surrogate range, (index - 2) is not less than start, and the char value at (index - 2) in the char array is in the high-surrogate range, then the supplementary code point corresponding to this surrogate pair is returned. Otherwise, the char value at (index - 1) is returned..","['return', 'Character.codePointBefore(char[] a, int index, int start)']"
Character.highSurrogate(int codePoint),what's the return of Character.highSurrogate(int codePoint)?,"the return of Character.highSurrogate(int codePoint) should be the leading surrogate (a high surrogate code unit) of the surrogate pair representing the specified supplementary character (Unicode code point) in the UTF-16 encoding. If the specified character is not a supplementary character, an unspecified char is returned..","['return', 'Character.highSurrogate(int codePoint)']"
Character.lowSurrogate(int codePoint),what's the return of Character.lowSurrogate(int codePoint)?,"the return of Character.lowSurrogate(int codePoint) should be the trailing surrogate (a low surrogate code unit) of the surrogate pair representing the specified supplementary character (Unicode code point) in the UTF-16 encoding. If the specified character is not a supplementary character, an unspecified char is returned..","['return', 'Character.lowSurrogate(int codePoint)']"
"Character.toChars(int codePoint, char[] dst, int dstIndex)","what's the return of Character.toChars(int codePoint, char[] dst, int dstIndex)?","the return of Character.toChars(int codePoint, char[] dst, int dstIndex) should be dst - an array of char in which the
 codePoint's UTF-16 value is stored..","['return', 'Character.toChars(int codePoint, char[] dst, int dstIndex)']"
Character.toChars(int codePoint),what's the return of Character.toChars(int codePoint)?,"the return of Character.toChars(int codePoint) should be a char array having
         codePoint's UTF-16 representation..","['return', 'Character.toChars(int codePoint)']"
"Character.codePointCount(CharSequence seq, int beginIndex, int endIndex)","what's the return of Character.codePointCount(CharSequence seq, int beginIndex, int endIndex)?","the return of Character.codePointCount(CharSequence seq, int beginIndex, int endIndex) should be the number of Unicode code points in the text range of the specified char sequence. The text range begins at the specified beginIndex and extends to the char at index endIndex - 1. Thus the length (in chars) of the text range is endIndex-beginIndex. Unpaired surrogates within the text range count as one code point each..","['return', 'Character.codePointCount(CharSequence seq, int beginIndex, int endIndex)']"
"Character.codePointCount(CharSequence seq, int beginIndex, int endIndex)","what's the parameter of Character.codePointCount(CharSequence seq, int beginIndex, int endIndex)?","the parameter of Character.codePointCount(CharSequence seq, int beginIndex, int endIndex) should be  the char sequence.","['parameter', 'Character.codePointCount(CharSequence seq, int beginIndex, int endIndex)']"
"Character.codePointCount(char[] a, int offset, int count)","what's the return of Character.codePointCount(char[] a, int offset, int count)?","the return of Character.codePointCount(char[] a, int offset, int count) should be the number of Unicode code points in a subarray of the char array argument. The offset argument is the index of the first char of the subarray and the count argument specifies the length of the subarray in chars. Unpaired surrogates within the subarray count as one code point each..","['return', 'Character.codePointCount(char[] a, int offset, int count)']"
"Character.offsetByCodePoints(CharSequence seq, int index, int codePointOffset)","what's the return of Character.offsetByCodePoints(CharSequence seq, int index, int codePointOffset)?","the return of Character.offsetByCodePoints(CharSequence seq, int index, int codePointOffset) should be the index within the given char sequence that is offset from the given index by codePointOffset code points. Unpaired surrogates within the text range given by index and codePointOffset count as one code point each..","['return', 'Character.offsetByCodePoints(CharSequence seq, int index, int codePointOffset)']"
"Character.offsetByCodePoints(CharSequence seq, int index, int codePointOffset)","what's the parameter of Character.offsetByCodePoints(CharSequence seq, int index, int codePointOffset)?","the parameter of Character.offsetByCodePoints(CharSequence seq, int index, int codePointOffset) should be  the char sequence.","['parameter', 'Character.offsetByCodePoints(CharSequence seq, int index, int codePointOffset)']"
"Character.offsetByCodePoints(char[] a, int start, int count, int index, int codePointOffset)","what's the return of Character.offsetByCodePoints(char[] a, int start, int count, int index, int codePointOffset)?","the return of Character.offsetByCodePoints(char[] a, int start, int count, int index, int codePointOffset) should be the index within the given char subarray that is offset from the given index by codePointOffset code points. The start and count arguments specify a subarray of the char array. Unpaired surrogates within the text range given by index and codePointOffset count as one code point each..","['return', 'Character.offsetByCodePoints(char[] a, int start, int count, int index, int codePointOffset)']"
Character.isLowerCase(char ch),what's the return of Character.isLowerCase(char ch)?,"the return of Character.isLowerCase(char ch) should be true if the character is lowercase;
          false otherwise..","['return', 'Character.isLowerCase(char ch)']"
Character.isLowerCase(int codePoint),what's the return of Character.isLowerCase(int codePoint)?,"the return of Character.isLowerCase(int codePoint) should be true if the character is lowercase;
          false otherwise..","['return', 'Character.isLowerCase(int codePoint)']"
Character.isUpperCase(char ch),what's the return of Character.isUpperCase(char ch)?,"the return of Character.isUpperCase(char ch) should be true if the character is uppercase;
          false otherwise..","['return', 'Character.isUpperCase(char ch)']"
Character.isUpperCase(int codePoint),what's the return of Character.isUpperCase(int codePoint)?,"the return of Character.isUpperCase(int codePoint) should be true if the character is uppercase;
          false otherwise..","['return', 'Character.isUpperCase(int codePoint)']"
Character.isTitleCase(char ch),what's the return of Character.isTitleCase(char ch)?,"the return of Character.isTitleCase(char ch) should be true if the character is titlecase;
          false otherwise..","['return', 'Character.isTitleCase(char ch)']"
Character.isTitleCase(int codePoint),what's the return of Character.isTitleCase(int codePoint)?,"the return of Character.isTitleCase(int codePoint) should be true if the character is titlecase;
          false otherwise..","['return', 'Character.isTitleCase(int codePoint)']"
Character.isDigit(char ch),what's the return of Character.isDigit(char ch)?,"the return of Character.isDigit(char ch) should be true if the character is a digit;
          false otherwise..","['return', 'Character.isDigit(char ch)']"
Character.isDigit(int codePoint),what's the return of Character.isDigit(int codePoint)?,"the return of Character.isDigit(int codePoint) should be true if the character is a digit;
          false otherwise..","['return', 'Character.isDigit(int codePoint)']"
Character.isDefined(char ch),what's the return of Character.isDefined(char ch)?,"the return of Character.isDefined(char ch) should be true if the character has a defined meaning
          in Unicode; false otherwise..","['return', 'Character.isDefined(char ch)']"
Character.isDefined(int codePoint),what's the return of Character.isDefined(int codePoint)?,"the return of Character.isDefined(int codePoint) should be true if the character has a defined meaning
          in Unicode; false otherwise..","['return', 'Character.isDefined(int codePoint)']"
Character.isLetter(char ch),what's the return of Character.isLetter(char ch)?,"the return of Character.isLetter(char ch) should be true if the character is a letter;
          false otherwise..","['return', 'Character.isLetter(char ch)']"
Character.isLetter(int codePoint),what's the return of Character.isLetter(int codePoint)?,"the return of Character.isLetter(int codePoint) should be true if the character is a letter;
          false otherwise..","['return', 'Character.isLetter(int codePoint)']"
Character.isLetterOrDigit(char ch),what's the return of Character.isLetterOrDigit(char ch)?,"the return of Character.isLetterOrDigit(char ch) should be true if the character is a letter or digit;
          false otherwise..","['return', 'Character.isLetterOrDigit(char ch)']"
Character.isLetterOrDigit(int codePoint),what's the return of Character.isLetterOrDigit(int codePoint)?,"the return of Character.isLetterOrDigit(int codePoint) should be true if the character is a letter or digit;
          false otherwise..","['return', 'Character.isLetterOrDigit(int codePoint)']"
Character.isJavaLetter(char ch),what's the return of Character.isJavaLetter(char ch)?,"the return of Character.isJavaLetter(char ch) should be true if the character may start a Java
          identifier; false otherwise..","['return', 'Character.isJavaLetter(char ch)']"
Character.isJavaLetterOrDigit(char ch),what's the return of Character.isJavaLetterOrDigit(char ch)?,"the return of Character.isJavaLetterOrDigit(char ch) should be true if the character may be part of a
          Java identifier; false otherwise..","['return', 'Character.isJavaLetterOrDigit(char ch)']"
Character.isAlphabetic(int codePoint),what's the return of Character.isAlphabetic(int codePoint)?,"the return of Character.isAlphabetic(int codePoint) should be true if the character is a Unicode alphabet
          character, false otherwise..","['return', 'Character.isAlphabetic(int codePoint)']"
Character.isIdeographic(int codePoint),what's the return of Character.isIdeographic(int codePoint)?,"the return of Character.isIdeographic(int codePoint) should be true if the character is a Unicode ideograph
          character, false otherwise..","['return', 'Character.isIdeographic(int codePoint)']"
Character.isJavaIdentifierStart(char ch),what's the return of Character.isJavaIdentifierStart(char ch)?,"the return of Character.isJavaIdentifierStart(char ch) should be true if the character may start a Java identifier;
          false otherwise..","['return', 'Character.isJavaIdentifierStart(char ch)']"
Character.isJavaIdentifierStart(int codePoint),what's the return of Character.isJavaIdentifierStart(int codePoint)?,"the return of Character.isJavaIdentifierStart(int codePoint) should be true if the character may start a Java identifier;
          false otherwise..","['return', 'Character.isJavaIdentifierStart(int codePoint)']"
Character.isJavaIdentifierPart(char ch),what's the return of Character.isJavaIdentifierPart(char ch)?,"the return of Character.isJavaIdentifierPart(char ch) should be true if the character may be part of a
          Java identifier; false otherwise..","['return', 'Character.isJavaIdentifierPart(char ch)']"
Character.isJavaIdentifierPart(int codePoint),what's the return of Character.isJavaIdentifierPart(int codePoint)?,"the return of Character.isJavaIdentifierPart(int codePoint) should be true if the character may be part of a
          Java identifier; false otherwise..","['return', 'Character.isJavaIdentifierPart(int codePoint)']"
Character.isUnicodeIdentifierStart(char ch),what's the return of Character.isUnicodeIdentifierStart(char ch)?,"the return of Character.isUnicodeIdentifierStart(char ch) should be true if the character may start a Unicode
          identifier; false otherwise..","['return', 'Character.isUnicodeIdentifierStart(char ch)']"
Character.isUnicodeIdentifierStart(int codePoint),what's the return of Character.isUnicodeIdentifierStart(int codePoint)?,"the return of Character.isUnicodeIdentifierStart(int codePoint) should be true if the character may start a Unicode
          identifier; false otherwise..","['return', 'Character.isUnicodeIdentifierStart(int codePoint)']"
Character.isUnicodeIdentifierPart(char ch),what's the return of Character.isUnicodeIdentifierPart(char ch)?,"the return of Character.isUnicodeIdentifierPart(char ch) should be true if the character may be part of a
          Unicode identifier; false otherwise..","['return', 'Character.isUnicodeIdentifierPart(char ch)']"
Character.isUnicodeIdentifierPart(int codePoint),what's the return of Character.isUnicodeIdentifierPart(int codePoint)?,"the return of Character.isUnicodeIdentifierPart(int codePoint) should be true if the character may be part of a
          Unicode identifier; false otherwise..","['return', 'Character.isUnicodeIdentifierPart(int codePoint)']"
Character.isIdentifierIgnorable(char ch),what's the return of Character.isIdentifierIgnorable(char ch)?,"the return of Character.isIdentifierIgnorable(char ch) should be true if the character is an ignorable control
          character that may be part of a Java or Unicode identifier;
           false otherwise..","['return', 'Character.isIdentifierIgnorable(char ch)']"
Character.isIdentifierIgnorable(int codePoint),what's the return of Character.isIdentifierIgnorable(int codePoint)?,"the return of Character.isIdentifierIgnorable(int codePoint) should be true if the character is an ignorable control
          character that may be part of a Java or Unicode identifier;
          false otherwise..","['return', 'Character.isIdentifierIgnorable(int codePoint)']"
Character.toLowerCase(char ch),what's the return of Character.toLowerCase(char ch)?,"the return of Character.toLowerCase(char ch) should be the lowercase equivalent of the character, if any;
          otherwise, the character itself..","['return', 'Character.toLowerCase(char ch)']"
Character.toLowerCase(int codePoint),what's the return of Character.toLowerCase(int codePoint)?,"the return of Character.toLowerCase(int codePoint) should be the lowercase equivalent of the character (Unicode code
          point), if any; otherwise, the character itself..","['return', 'Character.toLowerCase(int codePoint)']"
Character.toUpperCase(char ch),what's the return of Character.toUpperCase(char ch)?,"the return of Character.toUpperCase(char ch) should be the uppercase equivalent of the character, if any;
          otherwise, the character itself..","['return', 'Character.toUpperCase(char ch)']"
Character.toUpperCase(int codePoint),what's the return of Character.toUpperCase(int codePoint)?,"the return of Character.toUpperCase(int codePoint) should be the uppercase equivalent of the character, if any;
          otherwise, the character itself..","['return', 'Character.toUpperCase(int codePoint)']"
Character.toTitleCase(char ch),what's the return of Character.toTitleCase(char ch)?,"the return of Character.toTitleCase(char ch) should be the titlecase equivalent of the character, if any;
          otherwise, the character itself..","['return', 'Character.toTitleCase(char ch)']"
Character.toTitleCase(int codePoint),what's the return of Character.toTitleCase(int codePoint)?,"the return of Character.toTitleCase(int codePoint) should be the titlecase equivalent of the character, if any;
          otherwise, the character itself..","['return', 'Character.toTitleCase(int codePoint)']"
"Character.digit(char ch, int radix)","what's the return of Character.digit(char ch, int radix)?","the return of Character.digit(char ch, int radix) should be the numeric value of the character ch in the specified radix. The method isDigit is true of the character and the Unicode decimal digit value of the character (or its single-character decomposition) is less than the specified radix. In this case the decimal digit value is returned. The character is one of the uppercase Latin letters 'A' through 'Z' and its code is less than radix + 'A' - 10. In this case, ch - 'A' + 10 is returned. The character is one of the lowercase Latin letters 'a' through 'z' and its code is less than radix + 'a' - 10. In this case, ch - 'a' + 10 is returned. The character is one of the fullwidth uppercase Latin letters A ('\uFF21') through Z ('\uFF3A') and its code is less than radix + '\uFF21' - 10. In this case, ch - '\uFF21' + 10 is returned. The character is one of the fullwidth lowercase Latin letters a ('\uFF41') through z ('\uFF5A') and its code is less than radix + '\uFF41' - 10. In this case, ch - '\uFF41' + 10 is returned..","['return', 'Character.digit(char ch, int radix)']"
"Character.digit(int codePoint, int radix)","what's the return of Character.digit(int codePoint, int radix)?","the return of Character.digit(int codePoint, int radix) should be the numeric value of the specified character (Unicode code point) in the specified radix. The method isDigit(codePoint) is true of the character and the Unicode decimal digit value of the character (or its single-character decomposition) is less than the specified radix. In this case the decimal digit value is returned. The character is one of the uppercase Latin letters 'A' through 'Z' and its code is less than radix + 'A' - 10. In this case, codePoint - 'A' + 10 is returned. The character is one of the lowercase Latin letters 'a' through 'z' and its code is less than radix + 'a' - 10. In this case, codePoint - 'a' + 10 is returned. The character is one of the fullwidth uppercase Latin letters A ('\uFF21') through Z ('\uFF3A') and its code is less than radix + '\uFF21' - 10. In this case, codePoint - '\uFF21' + 10 is returned. The character is one of the fullwidth lowercase Latin letters a ('\uFF41') through z ('\uFF5A') and its code is less than radix + '\uFF41'- 10. In this case, codePoint - '\uFF41' + 10 is returned..","['return', 'Character.digit(int codePoint, int radix)']"
Character.getNumericValue(char ch),what's the return of Character.getNumericValue(char ch)?,"the return of Character.getNumericValue(char ch) should be the int value that the specified Unicode character represents. For example, the character '\u216C' (the roman numeral fifty) will return an int with a value of 50..","['return', 'Character.getNumericValue(char ch)']"
Character.getNumericValue(int codePoint),what's the return of Character.getNumericValue(int codePoint)?,"the return of Character.getNumericValue(int codePoint) should be the int value that the specified character (Unicode code point) represents. For example, the character '\u216C' (the Roman numeral fifty) will return an int with a value of 50..","['return', 'Character.getNumericValue(int codePoint)']"
Character.isSpace(char ch),what's the return of Character.isSpace(char ch)?,"the return of Character.isSpace(char ch) should be true if the character is ISO-LATIN-1 white
             space; false otherwise..","['return', 'Character.isSpace(char ch)']"
Character.isSpaceChar(char ch),what's the return of Character.isSpaceChar(char ch)?,"the return of Character.isSpaceChar(char ch) should be true if the character is a space character;
          false otherwise..","['return', 'Character.isSpaceChar(char ch)']"
Character.isSpaceChar(int codePoint),what's the return of Character.isSpaceChar(int codePoint)?,"the return of Character.isSpaceChar(int codePoint) should be true if the character is a space character;
          false otherwise..","['return', 'Character.isSpaceChar(int codePoint)']"
Character.isWhitespace(char ch),what's the return of Character.isWhitespace(char ch)?,"the return of Character.isWhitespace(char ch) should be true if the character is a Java whitespace
          character; false otherwise..","['return', 'Character.isWhitespace(char ch)']"
Character.isWhitespace(int codePoint),what's the return of Character.isWhitespace(int codePoint)?,"the return of Character.isWhitespace(int codePoint) should be true if the character is a Java whitespace
          character; false otherwise..","['return', 'Character.isWhitespace(int codePoint)']"
Character.isISOControl(char ch),what's the return of Character.isISOControl(char ch)?,"the return of Character.isISOControl(char ch) should be true if the character is an ISO control character;
          false otherwise..","['return', 'Character.isISOControl(char ch)']"
Character.isISOControl(int codePoint),what's the return of Character.isISOControl(int codePoint)?,"the return of Character.isISOControl(int codePoint) should be true if the character is an ISO control character;
          false otherwise..","['return', 'Character.isISOControl(int codePoint)']"
Character.getType(char ch),what's the return of Character.getType(char ch)?,the return of Character.getType(char ch) should be a value indicating a character's general category..,"['return', 'Character.getType(char ch)']"
Character.getType(int codePoint),what's the return of Character.getType(int codePoint)?,the return of Character.getType(int codePoint) should be a value indicating a character's general category..,"['return', 'Character.getType(int codePoint)']"
"Character.forDigit(int digit, int radix)","what's the return of Character.forDigit(int digit, int radix)?","the return of Character.forDigit(int digit, int radix) should be radix - the radix..","['return', 'Character.forDigit(int digit, int radix)']"
Character.getDirectionality(char ch),what's the return of Character.getDirectionality(char ch)?,the return of Character.getDirectionality(char ch) should be the Unicode directionality property for the given character. Character directionality is used to calculate the visual ordering of text. The directionality value of undefined char values is DIRECTIONALITY_UNDEFINED..,"['return', 'Character.getDirectionality(char ch)']"
Character.getDirectionality(int codePoint),what's the return of Character.getDirectionality(int codePoint)?,the return of Character.getDirectionality(int codePoint) should be the Unicode directionality property for the given character (Unicode code point). Character directionality is used to calculate the visual ordering of text. The directionality value of undefined character is DIRECTIONALITY_UNDEFINED..,"['return', 'Character.getDirectionality(int codePoint)']"
Character.isMirrored(char ch),what's the return of Character.isMirrored(char ch)?,"the return of Character.isMirrored(char ch) should be true if the char is mirrored, false
         if the char is not mirrored or is not defined..","['return', 'Character.isMirrored(char ch)']"
Character.isMirrored(int codePoint),what's the return of Character.isMirrored(int codePoint)?,"the return of Character.isMirrored(int codePoint) should be true if the character is mirrored, false
          if the character is not mirrored or is not defined..","['return', 'Character.isMirrored(int codePoint)']"
Comparable.compareTo(Character anotherCharacter),what's the return of Comparable.compareTo(Character anotherCharacter)?,"the return of Comparable.compareTo(Character anotherCharacter) should be the value 0 if the argument Character
          is equal to this Character; a value less than
          0 if this Character is numerically less
          than the Character argument; and a value greater than
          0 if this Character is numerically greater
          than the Character argument (unsigned comparison).
          Note that this is strictly a numerical comparison; it is not
          locale-dependent..","['return', 'Comparable.compareTo(Character anotherCharacter)']"
Comparable.compareTo(Character anotherCharacter),what's the parameter of Comparable.compareTo(Character anotherCharacter)?,the parameter of Comparable.compareTo(Character anotherCharacter) should be  the Character to be compared..,"['parameter', 'Comparable.compareTo(Character anotherCharacter)']"
"Character.compare(char x, char y)","what's the return of Character.compare(char x, char y)?","the return of Character.compare(char x, char y) should be y - the second char to compare.","['return', 'Character.compare(char x, char y)']"
Character.reverseBytes(char ch),what's the return of Character.reverseBytes(char ch)?,the return of Character.reverseBytes(char ch) should be the value obtained by reversing the order of the bytes in the specified char value..,"['return', 'Character.reverseBytes(char ch)']"
Character.getName(int codePoint),what's the return of Character.getName(int codePoint)?,"the return of Character.getName(int codePoint) should be the Unicode name of the specified character codePoint, or null if the code point is unassigned. Character.UnicodeBlock.of(codePoint).toString().replace('_', ' ') + "" "" + Integer.toHexString(codePoint).toUpperCase(Locale.ENGLISH);.","['return', 'Character.getName(int codePoint)']"
Object.equals(Object obj),what's the return of Object.equals(Object obj)?,"the return of Object.equals(Object obj) should be true if the objects are the same;
          false otherwise..","['return', 'Object.equals(Object obj)']"
Object.equals(Object obj),what's the parameter of Object.equals(Object obj)?,the parameter of Object.equals(Object obj) should be  the object to compare with..,"['parameter', 'Object.equals(Object obj)']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
Character.UnicodeScript.values(),what's the return of Character.UnicodeScript.values()?,"the return of Character.UnicodeScript.values() should be an array containing the constants of this enum type, in the order they are declared. This method may be used to iterate over the constants as follows: for (Character.UnicodeScript c : Character.UnicodeScript.values()) System.out.println(c);.","['return', 'Character.UnicodeScript.values()']"
Character.UnicodeScript.valueOf(String name),what's the return of Character.UnicodeScript.valueOf(String name)?,the return of Character.UnicodeScript.valueOf(String name) should be the enum constant of this type with the specified name. The string must match exactly an identifier used to declare an enum constant in this type. (Extraneous whitespace characters are not permitted.).,"['return', 'Character.UnicodeScript.valueOf(String name)']"
Character.UnicodeScript.valueOf(String name),what's the parameter of Character.UnicodeScript.valueOf(String name)?,the parameter of Character.UnicodeScript.valueOf(String name) should be  the name of the enum constant to be returned..,"['parameter', 'Character.UnicodeScript.valueOf(String name)']"
Character.UnicodeScript.of(int codePoint),what's the return of Character.UnicodeScript.of(int codePoint)?,the return of Character.UnicodeScript.of(int codePoint) should be the enum constant representing the Unicode script of which the given character (Unicode code point) is assigned to..,"['return', 'Character.UnicodeScript.of(int codePoint)']"
Character.UnicodeScript.forName(String scriptName),what's the return of Character.UnicodeScript.forName(String scriptName)?,the return of Character.UnicodeScript.forName(String scriptName) should be the UnicodeScript constant with the given Unicode script name or the script name alias. Script names and their aliases are determined by The Unicode Standard. The files Scripts<version>.txt and PropertyValueAliases<version>.txt define script names and the script name aliases for a particular version of the standard. The Character class specifies the version of the standard that it supports..,"['return', 'Character.UnicodeScript.forName(String scriptName)']"
Character.UnicodeScript.forName(String scriptName),what's the parameter of Character.UnicodeScript.forName(String scriptName)?,the parameter of Character.UnicodeScript.forName(String scriptName) should be  A UnicodeScript name..,"['parameter', 'Character.UnicodeScript.forName(String scriptName)']"
CharSequence.length(),what's the return of CharSequence.length()?,the return of CharSequence.length() should be the length of this string. The length is equal to the number of Unicode code units in the string..,"['return', 'CharSequence.length()']"
CharSequence.charAt(int index),what's the return of CharSequence.charAt(int index)?,"the return of CharSequence.charAt(int index) should be the char value at the specified index. An index ranges from 0 to length() - 1. The first char value of the sequence is at index 0, the next at index 1, and so on, as for array indexing..","['return', 'CharSequence.charAt(int index)']"
"CharSequence.subSequence(int start, int end)","what's the return of CharSequence.subSequence(int start, int end)?","the return of CharSequence.subSequence(int start, int end) should be a new character sequence that is a subsequence of this sequence. sb.subSequence(begin,&nbsp;end) behaves in exactly the same way as the invocation sb.substring(begin,&nbsp;end) This method is provided so that this class can implement the CharSequence interface..","['return', 'CharSequence.subSequence(int start, int end)']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
CharSequence.chars(),what's the return of CharSequence.chars()?,the return of CharSequence.chars() should be a stream of int zero-extending the char values from this sequence. Any char which maps to a surrogate code point is passed through uninterpreted..,"['return', 'CharSequence.chars()']"
CharSequence.codePoints(),what's the return of CharSequence.codePoints()?,"the return of CharSequence.codePoints() should be a stream of code point values from this sequence. Any surrogate pairs encountered in the sequence are combined as if by Character.toCodePoint and the result is passed to the stream. Any other code units, including ordinary BMP characters, unpaired surrogates, and undefined code units, are zero-extended to int values which are then passed to the stream..","['return', 'CharSequence.codePoints()']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
Class.toGenericString(),what's the return of Class.toGenericString()?,"the return of Class.toGenericString() should be a string describing this Class, including information about modifiers and type parameters. The string is formatted as a list of type modifiers, if any, followed by the kind of type (empty string for primitive types and class, enum, interface, or @interface, as appropriate), followed by the type's name, followed by an angle-bracketed comma-separated list of the type's type parameters, if any. A space is used to separate modifiers from one another and to separate any modifiers from the kind of type. The modifiers occur in canonical order. If there are no type parameters, the type parameter list is elided..","['return', 'Class.toGenericString()']"
Class.forName(String className),what's the return of Class.forName(String className)?,"the return of Class.forName(String className) should be the Class object associated with the class or interface with the given string name. Invoking this method is equivalent to: Class.forName(className, true, currentLoader) where currentLoader denotes the defining class loader of the current class. Class t = Class.forName(""java.lang.Thread"").","['return', 'Class.forName(String className)']"
Class.forName(String className),what's the parameter of Class.forName(String className)?,the parameter of Class.forName(String className) should be  the fully qualified name of the desired class..,"['parameter', 'Class.forName(String className)']"
"Class.forName(String name, boolean initialize, ClassLoader loader)","what's the return of Class.forName(String name, boolean initialize, ClassLoader loader)?","the return of Class.forName(String name, boolean initialize, ClassLoader loader) should be the Class object associated with the class or interface with the given string name, using the given class loader. Given the fully qualified name for a class or interface (in the same format returned by getName) this method attempts to locate, load, and link the class or interface. The specified class loader is used to load the class or interface. If the parameter loader is null, the class is loaded through the bootstrap class loader. The class is initialized only if the initialize parameter is true and if it has not been initialized earlier. Class.forName(""Foo"") is equivalent to: Class.forName(""Foo"", true, this.getClass().getClassLoader()) Note that this method throws errors related to loading, linking or initializing as specified in Sections 12.2, 12.3 and 12.4 of The Java Language Specification. Note that this method does not check whether the requested class is accessible to its caller..","['return', 'Class.forName(String name, boolean initialize, ClassLoader loader)']"
"Class.forName(String name, boolean initialize, ClassLoader loader)","what's the parameter of Class.forName(String name, boolean initialize, ClassLoader loader)?","the parameter of Class.forName(String name, boolean initialize, ClassLoader loader) should be  fully qualified name of the desired class.","['parameter', 'Class.forName(String name, boolean initialize, ClassLoader loader)']"
"Class.forName(String name, boolean initialize, ClassLoader loader)","what's the parameter of Class.forName(String name, boolean initialize, ClassLoader loader)?","the parameter of Class.forName(String name, boolean initialize, ClassLoader loader) should be  fully qualified name of the desired class.","['parameter', 'Class.forName(String name, boolean initialize, ClassLoader loader)']"
Class.newInstance(),what's the return of Class.newInstance()?,"the return of Class.newInstance() should be a newly allocated instance of the class represented by this
          object..","['return', 'Class.newInstance()']"
Class.isInstance(Object obj),what's the return of Class.isInstance(Object obj)?,the return of Class.isInstance(Object obj) should be true if obj is an instance of this class.,"['return', 'Class.isInstance(Object obj)']"
Class.isInstance(Object obj),what's the parameter of Class.isInstance(Object obj)?,the parameter of Class.isInstance(Object obj) should be  the object to check.,"['parameter', 'Class.isInstance(Object obj)']"
Class.isAssignableFrom(Class<?> cls),what's the return of Class.isAssignableFrom(Class<?> cls)?,"the return of Class.isAssignableFrom(Class<?> cls) should be the boolean value indicating whether objects of the
 type cls can be assigned to objects of this class.","['return', 'Class.isAssignableFrom(Class<?> cls)']"
Class.isInterface(),what's the return of Class.isInterface()?,"the return of Class.isInterface() should be true if this object represents an interface;
          false otherwise..","['return', 'Class.isInterface()']"
Class.isArray(),what's the return of Class.isArray()?,"the return of Class.isArray() should be true if this object represents an array class;
          false otherwise..","['return', 'Class.isArray()']"
Class.isPrimitive(),what's the return of Class.isPrimitive()?,the return of Class.isPrimitive() should be true if and only if this class represents a primitive type.,"['return', 'Class.isPrimitive()']"
Class.isAnnotation(),what's the return of Class.isAnnotation()?,"the return of Class.isAnnotation() should be true if this Class object represents an annotation type. Note that if this method returns true, isInterface() would also return true, as all annotation types are also interfaces..","['return', 'Class.isAnnotation()']"
Class.isSynthetic(),what's the return of Class.isSynthetic()?,the return of Class.isSynthetic() should be true if this class is a synthetic class; returns false otherwise..,"['return', 'Class.isSynthetic()']"
Class.getName(),what's the return of Class.getName()?,"the return of Class.getName() should be the name of the entity (class, interface, array class, primitive type, or void) represented by this Class object, as a String. Element Type Encoding boolean Z byte B char C class or interface Lclassname; double D float F int I long J short S String.class.getName() returns ""java.lang.String"" byte.class.getName() returns ""byte"" (new Object[3]).getClass().getName() returns ""[Ljava.lang.Object;"" (new int[3][4][5][6][7][8][9]).getClass().getName() returns ""[[[[[[[I"".","['return', 'Class.getName()']"
Class.getClassLoader(),what's the return of Class.getClassLoader()?,the return of Class.getClassLoader() should be the class loader for the class. Some implementations may use null to represent the bootstrap class loader. This method will return null in such implementations if this class was loaded by the bootstrap class loader..,"['return', 'Class.getClassLoader()']"
GenericDeclaration.getTypeParameters(),what's the return of GenericDeclaration.getTypeParameters()?,"the return of GenericDeclaration.getTypeParameters() should be an array of TypeVariable objects that represent the type variables declared by the generic declaration represented by this GenericDeclaration object, in declaration order. Returns an array of length 0 if the underlying generic declaration declares no type variables..","['return', 'GenericDeclaration.getTypeParameters()']"
Class.getSuperclass(),what's the return of Class.getSuperclass()?,"the return of Class.getSuperclass() should be the Class representing the superclass of the entity (class, interface, primitive type or void) represented by this Class. If this Class represents either the Object class, an interface, a primitive type, or void, then null is returned. If this object represents an array class then the Class object representing the Object class is returned..","['return', 'Class.getSuperclass()']"
Class.getGenericSuperclass(),what's the return of Class.getGenericSuperclass()?,"the return of Class.getGenericSuperclass() should be the Type representing the direct superclass of the entity (class, interface, primitive type or void) represented by this Class..","['return', 'Class.getGenericSuperclass()']"
Class.getPackage(),what's the return of Class.getPackage()?,"the return of Class.getPackage() should be the package of the class, or null if no package
         information is available from the archive or codebase..","['return', 'Class.getPackage()']"
Class.getInterfaces(),what's the return of Class.getInterfaces()?,the return of Class.getInterfaces() should be an array of interfaces implemented by this class..,"['return', 'Class.getInterfaces()']"
Class.getGenericInterfaces(),what's the return of Class.getGenericInterfaces()?,the return of Class.getGenericInterfaces() should be the Types representing the interfaces directly implemented by the class or interface represented by this object..,"['return', 'Class.getGenericInterfaces()']"
Class.getComponentType(),what's the return of Class.getComponentType()?,the return of Class.getComponentType() should be the Class representing the component type of an array. If this class does not represent an array class this method returns null..,"['return', 'Class.getComponentType()']"
Class.getModifiers(),what's the return of Class.getModifiers()?,"the return of Class.getModifiers() should be the Java language modifiers for this class or interface, encoded in an integer. The modifiers consist of the Java Virtual Machine's constants for public, protected, private, final, static, abstract and interface; they should be decoded using the methods of class Modifier..","['return', 'Class.getModifiers()']"
Class.getSigners(),what's the return of Class.getSigners()?,"the return of Class.getSigners() should be the signers of this class, or null if there are no signers.  In
          particular, this method returns null if this object represents
          a primitive type or void..","['return', 'Class.getSigners()']"
Class.getEnclosingMethod(),what's the return of Class.getEnclosingMethod()?,"the return of Class.getEnclosingMethod() should be the immediately enclosing method of the underlying class, if
     that class is a local or anonymous class; otherwise null..","['return', 'Class.getEnclosingMethod()']"
Class.getEnclosingConstructor(),what's the return of Class.getEnclosingConstructor()?,"the return of Class.getEnclosingConstructor() should be the immediately enclosing constructor of the underlying class, if
     that class is a local or anonymous class; otherwise null..","['return', 'Class.getEnclosingConstructor()']"
Class.getDeclaringClass(),what's the return of Class.getDeclaringClass()?,the return of Class.getDeclaringClass() should be the declaring class for this class.,"['return', 'Class.getDeclaringClass()']"
Class.getEnclosingClass(),what's the return of Class.getEnclosingClass()?,the return of Class.getEnclosingClass() should be the immediately enclosing class of the underlying class. If the underlying class is a top level class this method returns null..,"['return', 'Class.getEnclosingClass()']"
Class.getSimpleName(),what's the return of Class.getSimpleName()?,the return of Class.getSimpleName() should be the simple name of the underlying class as given in the source code. Returns an empty string if the underlying class is anonymous..,"['return', 'Class.getSimpleName()']"
Type.getTypeName(),what's the return of Type.getTypeName()?,the return of Type.getTypeName() should be an informative string for the name of this type.,"['return', 'Type.getTypeName()']"
Class.getCanonicalName(),what's the return of Class.getCanonicalName()?,"the return of Class.getCanonicalName() should be the canonical name of the underlying class as defined by the Java Language Specification. Returns null if the underlying class does not have a canonical name (i.e., if it is a local or anonymous class or an array whose component type does not have a canonical name)..","['return', 'Class.getCanonicalName()']"
Class.isAnonymousClass(),what's the return of Class.isAnonymousClass()?,the return of Class.isAnonymousClass() should be true if and only if the underlying class is an anonymous class..,"['return', 'Class.isAnonymousClass()']"
Class.isLocalClass(),what's the return of Class.isLocalClass()?,the return of Class.isLocalClass() should be true if and only if the underlying class is a local class..,"['return', 'Class.isLocalClass()']"
Class.isMemberClass(),what's the return of Class.isMemberClass()?,the return of Class.isMemberClass() should be true if and only if the underlying class is a member class..,"['return', 'Class.isMemberClass()']"
Class.getClasses(),what's the return of Class.getClasses()?,"the return of Class.getClasses() should be an array containing Class objects representing all the public classes and interfaces that are members of the class represented by this Class object. This includes public class and interface members inherited from superclasses and public class and interface members declared by the class. This method returns an array of length 0 if this Class object has no public member classes or interfaces. This method also returns an array of length 0 if this Class object represents a primitive type, an array class, or void..","['return', 'Class.getClasses()']"
Class.getFields(),what's the return of Class.getFields()?,the return of Class.getFields() should be an array containing Field objects reflecting all the accessible public fields of the class or interface represented by this Class object..,"['return', 'Class.getFields()']"
Class.getMethods(),what's the return of Class.getMethods()?,"the return of Class.getMethods() should be an array containing Method objects reflecting all the public methods of the class or interface represented by this Class object, including those declared by the class or interface and those inherited from superclasses and superinterfaces..","['return', 'Class.getMethods()']"
Class.getConstructors(),what's the return of Class.getConstructors()?,"the return of Class.getConstructors() should be an array containing Constructor objects reflecting all the public constructors of the class represented by this Class object. An array of length 0 is returned if the class has no public constructors, or if the class is an array class, or if the class reflects a primitive type or void. Note that while this method returns an array of Constructor<T> objects (that is an array of constructors from this class), the return type of this method is Constructor<?>[] and not Constructor<T>[] as might be expected. This less informative return type is necessary since after being returned from this method, the array could be modified to hold Constructor objects for different classes, which would violate the type guarantees of Constructor<T>[]..","['return', 'Class.getConstructors()']"
Class.getField(String name),what's the return of Class.getField(String name)?,"the return of Class.getField(String name) should be a Field object that reflects the specified public member field of the class or interface represented by this Class object. The name parameter is a String specifying the simple name of the desired field. If C declares a public field with the name specified, that is the field to be reflected. If no field was found in step 1 above, this algorithm is applied recursively to each direct superinterface of C. The direct superinterfaces are searched in the order they were declared. If no field was found in steps 1 and 2 above, and C has a superclass S, then this algorithm is invoked recursively upon S. If C has no superclass, then a NoSuchFieldException is thrown..","['return', 'Class.getField(String name)']"
Class.getField(String name),what's the parameter of Class.getField(String name)?,the parameter of Class.getField(String name) should be  the field name.,"['parameter', 'Class.getField(String name)']"
"Class.getMethod(String name, Class<?>... parameterTypes)","what's the return of Class.getMethod(String name, Class<?>... parameterTypes)?","the return of Class.getMethod(String name, Class<?>... parameterTypes) should be a Method object that reflects the specified public member method of the class or interface represented by this Class object. The name parameter is a String specifying the simple name of the desired method. The parameterTypes parameter is an array of Class objects that identify the method's formal parameter types, in declared order. If parameterTypes is null, it is treated as if it were an empty array. C is searched for a matching method, as defined below. If a matching method is found, it is reflected. If no matching method is found by step 1 then: If C is a class other than Object, then this algorithm is invoked recursively on the superclass of C. If C is the class Object, or if C is an interface, then the superinterfaces of C (if any) are searched for a matching method. If any such method is found, it is reflected..","['return', 'Class.getMethod(String name, Class<?>... parameterTypes)']"
"Class.getMethod(String name, Class<?>... parameterTypes)","what's the parameter of Class.getMethod(String name, Class<?>... parameterTypes)?","the parameter of Class.getMethod(String name, Class<?>... parameterTypes) should be  the name of the method.","['parameter', 'Class.getMethod(String name, Class<?>... parameterTypes)']"
Class.getConstructor(Class<?>... parameterTypes),what's the return of Class.getConstructor(Class<?>... parameterTypes)?,"the return of Class.getConstructor(Class<?>... parameterTypes) should be a Constructor object that reflects the specified public constructor of the class represented by this Class object. The parameterTypes parameter is an array of Class objects that identify the constructor's formal parameter types, in declared order. If this Class object represents an inner class declared in a non-static context, the formal parameter types include the explicit enclosing instance as the first parameter..","['return', 'Class.getConstructor(Class<?>... parameterTypes)']"
Class.getDeclaredClasses(),what's the return of Class.getDeclaredClasses()?,"the return of Class.getDeclaredClasses() should be an array of Class objects reflecting all the classes and interfaces declared as members of the class represented by this Class object. This includes public, protected, default (package) access, and private classes and interfaces declared by the class, but excludes inherited classes and interfaces. This method returns an array of length 0 if the class declares no classes or interfaces as members, or if this Class object represents a primitive type, an array class, or void..","['return', 'Class.getDeclaredClasses()']"
Class.getDeclaredFields(),what's the return of Class.getDeclaredFields()?,"the return of Class.getDeclaredFields() should be an array of Field objects reflecting all the fields declared by the class or interface represented by this Class object. This includes public, protected, default (package) access, and private fields, but excludes inherited fields..","['return', 'Class.getDeclaredFields()']"
Class.getDeclaredMethods(),what's the return of Class.getDeclaredMethods()?,"the return of Class.getDeclaredMethods() should be an array containing Method objects reflecting all the declared methods of the class or interface represented by this Class object, including public, protected, default (package) access, and private methods, but excluding inherited methods..","['return', 'Class.getDeclaredMethods()']"
Class.getDeclaredConstructors(),what's the return of Class.getDeclaredConstructors()?,"the return of Class.getDeclaredConstructors() should be an array of Constructor objects reflecting all the constructors declared by the class represented by this Class object. These are public, protected, default (package) access, and private constructors. The elements in the array returned are not sorted and are not in any particular order. If the class has a default constructor, it is included in the returned array. This method returns an array of length 0 if this Class object represents an interface, a primitive type, an array class, or void..","['return', 'Class.getDeclaredConstructors()']"
Class.getDeclaredField(String name),what's the return of Class.getDeclaredField(String name)?,the return of Class.getDeclaredField(String name) should be a Field object that reflects the specified declared field of the class or interface represented by this Class object. The name parameter is a String that specifies the simple name of the desired field..,"['return', 'Class.getDeclaredField(String name)']"
Class.getDeclaredField(String name),what's the parameter of Class.getDeclaredField(String name)?,the parameter of Class.getDeclaredField(String name) should be  the name of the field.,"['parameter', 'Class.getDeclaredField(String name)']"
"Class.getDeclaredMethod(String name, Class<?>... parameterTypes)","what's the return of Class.getDeclaredMethod(String name, Class<?>... parameterTypes)?","the return of Class.getDeclaredMethod(String name, Class<?>... parameterTypes) should be a Method object that reflects the specified declared method of the class or interface represented by this Class object. The name parameter is a String that specifies the simple name of the desired method, and the parameterTypes parameter is an array of Class objects that identify the method's formal parameter types, in declared order. If more than one method with the same parameter types is declared in a class, and one of these methods has a return type that is more specific than any of the others, that method is returned; otherwise one of the methods is chosen arbitrarily. If the name is ""<init>""or ""<clinit>"" a NoSuchMethodException is raised..","['return', 'Class.getDeclaredMethod(String name, Class<?>... parameterTypes)']"
"Class.getDeclaredMethod(String name, Class<?>... parameterTypes)","what's the parameter of Class.getDeclaredMethod(String name, Class<?>... parameterTypes)?","the parameter of Class.getDeclaredMethod(String name, Class<?>... parameterTypes) should be  the name of the method.","['parameter', 'Class.getDeclaredMethod(String name, Class<?>... parameterTypes)']"
Class.getDeclaredConstructor(Class<?>... parameterTypes),what's the return of Class.getDeclaredConstructor(Class<?>... parameterTypes)?,"the return of Class.getDeclaredConstructor(Class<?>... parameterTypes) should be a Constructor object that reflects the specified constructor of the class or interface represented by this Class object. The parameterTypes parameter is an array of Class objects that identify the constructor's formal parameter types, in declared order. If this Class object represents an inner class declared in a non-static context, the formal parameter types include the explicit enclosing instance as the first parameter..","['return', 'Class.getDeclaredConstructor(Class<?>... parameterTypes)']"
Class.getResourceAsStream(String name),what's the return of Class.getResourceAsStream(String name)?,"the return of Class.getResourceAsStream(String name) should be A InputStream object or null if
              no resource with this name is found.","['return', 'Class.getResourceAsStream(String name)']"
Class.getResourceAsStream(String name),what's the parameter of Class.getResourceAsStream(String name)?,the parameter of Class.getResourceAsStream(String name) should be  name of the desired resource.,"['parameter', 'Class.getResourceAsStream(String name)']"
Class.getResource(String name),what's the return of Class.getResource(String name)?,"the return of Class.getResource(String name) should be A  URL object or null if no
              resource with this name is found.","['return', 'Class.getResource(String name)']"
Class.getResource(String name),what's the parameter of Class.getResource(String name)?,the parameter of Class.getResource(String name) should be  name of the desired resource.,"['parameter', 'Class.getResource(String name)']"
Class.getProtectionDomain(),what's the return of Class.getProtectionDomain()?,"the return of Class.getProtectionDomain() should be the ProtectionDomain of this class. If there is a security manager installed, this method first calls the security manager's checkPermission method with a RuntimePermission(""getProtectionDomain"") permission to ensure it's ok to get the ProtectionDomain..","['return', 'Class.getProtectionDomain()']"
Class.desiredAssertionStatus(),what's the return of Class.desiredAssertionStatus()?,"the return of Class.desiredAssertionStatus() should be the assertion status that would be assigned to this class if it were to be initialized at the time this method is invoked. If this class has had its assertion status set, the most recent setting will be returned; otherwise, if any package default assertion status pertains to this class, the most recent setting for the most specific pertinent package default assertion status is returned; otherwise, if this class is not a system class (i.e., it has a class loader) its class loader's default assertion status is returned; otherwise, the system class default assertion status is returned..","['return', 'Class.desiredAssertionStatus()']"
Class.isEnum(),what's the return of Class.isEnum()?,the return of Class.isEnum() should be true if and only if this class was declared as an enum in the source code..,"['return', 'Class.isEnum()']"
Class.getEnumConstants(),what's the return of Class.getEnumConstants()?,the return of Class.getEnumConstants() should be the elements of this enum class or null if this Class object does not represent an enum type..,"['return', 'Class.getEnumConstants()']"
Class.cast(Object obj),what's the return of Class.cast(Object obj)?,"the return of Class.cast(Object obj) should be the object after casting, or null if obj is null.","['return', 'Class.cast(Object obj)']"
Class.cast(Object obj),what's the parameter of Class.cast(Object obj)?,the parameter of Class.cast(Object obj) should be  the object to be cast.,"['parameter', 'Class.cast(Object obj)']"
Class.asSubclass(Class<U> clazz),what's the return of Class.asSubclass(Class<U> clazz)?,"the return of Class.asSubclass(Class<U> clazz) should be this Class object, cast to represent a subclass of
    the specified class object..","['return', 'Class.asSubclass(Class<U> clazz)']"
AnnotatedElement.getAnnotation(Class<A> annotationClass),what's the return of AnnotatedElement.getAnnotation(Class<A> annotationClass)?,"the return of AnnotatedElement.getAnnotation(Class<A> annotationClass) should be this element's annotation for the specified annotation type if
     present on this element, else null.","['return', 'AnnotatedElement.getAnnotation(Class<A> annotationClass)']"
AnnotatedElement.isAnnotationPresent(Class<? extends Annotation> annotationClass),what's the return of AnnotatedElement.isAnnotationPresent(Class<? extends Annotation> annotationClass)?,"the return of AnnotatedElement.isAnnotationPresent(Class<? extends Annotation> annotationClass) should be true if an annotation for the specified type is present on this element, else false. This method is designed primarily for convenient access to marker annotations..","['return', 'AnnotatedElement.isAnnotationPresent(Class<? extends Annotation> annotationClass)']"
AnnotatedElement.getAnnotationsByType(Class<A> annotationClass),what's the return of AnnotatedElement.getAnnotationsByType(Class<A> annotationClass)?,"the return of AnnotatedElement.getAnnotationsByType(Class<A> annotationClass) should be all this element's annotations for the specified annotation type if
     associated with this element, else an array of length zero.","['return', 'AnnotatedElement.getAnnotationsByType(Class<A> annotationClass)']"
AnnotatedElement.getAnnotations(),what's the return of AnnotatedElement.getAnnotations()?,the return of AnnotatedElement.getAnnotations() should be annotations present on this element.,"['return', 'AnnotatedElement.getAnnotations()']"
AnnotatedElement.getDeclaredAnnotation(Class<A> annotationClass),what's the return of AnnotatedElement.getDeclaredAnnotation(Class<A> annotationClass)?,"the return of AnnotatedElement.getDeclaredAnnotation(Class<A> annotationClass) should be this element's annotation for the specified annotation type if
     directly present on this element, else null.","['return', 'AnnotatedElement.getDeclaredAnnotation(Class<A> annotationClass)']"
AnnotatedElement.getDeclaredAnnotationsByType(Class<A> annotationClass),what's the return of AnnotatedElement.getDeclaredAnnotationsByType(Class<A> annotationClass)?,"the return of AnnotatedElement.getDeclaredAnnotationsByType(Class<A> annotationClass) should be all this element's annotations for the specified annotation type if
     directly or indirectly present on this element, else an array of length zero.","['return', 'AnnotatedElement.getDeclaredAnnotationsByType(Class<A> annotationClass)']"
AnnotatedElement.getDeclaredAnnotations(),what's the return of AnnotatedElement.getDeclaredAnnotations()?,the return of AnnotatedElement.getDeclaredAnnotations() should be annotations directly present on this element.,"['return', 'AnnotatedElement.getDeclaredAnnotations()']"
Class.getAnnotatedSuperclass(),what's the return of Class.getAnnotatedSuperclass()?,the return of Class.getAnnotatedSuperclass() should be an AnnotatedType object that represents the use of a type to specify the superclass of the entity represented by this Class object. (The use of type Foo to specify the superclass in '... extends Foo' is distinct from the declaration of type Foo.).,"['return', 'Class.getAnnotatedSuperclass()']"
Class.getAnnotatedInterfaces(),what's the return of Class.getAnnotatedInterfaces()?,the return of Class.getAnnotatedInterfaces() should be an array of AnnotatedType objects that represent the use of types to specify superinterfaces of the entity represented by this Class object. (The use of type Foo to specify a superinterface in '... implements Foo' is distinct from the declaration of type Foo.).,"['return', 'Class.getAnnotatedInterfaces()']"
ClassLoader.loadClass(String name),what's the return of ClassLoader.loadClass(String name)?,the return of ClassLoader.loadClass(String name) should be The resulting Class object.,"['return', 'ClassLoader.loadClass(String name)']"
ClassLoader.loadClass(String name),what's the parameter of ClassLoader.loadClass(String name)?,the parameter of ClassLoader.loadClass(String name) should be  The binary name of the class.,"['parameter', 'ClassLoader.loadClass(String name)']"
"ClassLoader.loadClass(String name, boolean resolve)","what's the return of ClassLoader.loadClass(String name, boolean resolve)?","the return of ClassLoader.loadClass(String name, boolean resolve) should be resolve - If true then resolve the class.","['return', 'ClassLoader.loadClass(String name, boolean resolve)']"
"ClassLoader.loadClass(String name, boolean resolve)","what's the parameter of ClassLoader.loadClass(String name, boolean resolve)?","the parameter of ClassLoader.loadClass(String name, boolean resolve) should be  The binary name of the class.","['parameter', 'ClassLoader.loadClass(String name, boolean resolve)']"
ClassLoader.getClassLoadingLock(String className),what's the return of ClassLoader.getClassLoadingLock(String className)?,"the return of ClassLoader.getClassLoadingLock(String className) should be the lock object for class loading operations. For backward compatibility, the default implementation of this method behaves as follows. If this ClassLoader object is registered as parallel capable, the method returns a dedicated object associated with the specified class name. Otherwise, the method returns this ClassLoader object..","['return', 'ClassLoader.getClassLoadingLock(String className)']"
ClassLoader.getClassLoadingLock(String className),what's the parameter of ClassLoader.getClassLoadingLock(String className)?,the parameter of ClassLoader.getClassLoadingLock(String className) should be  The name of the to.,"['parameter', 'ClassLoader.getClassLoadingLock(String className)']"
ClassLoader.findClass(String name),what's the return of ClassLoader.findClass(String name)?,the return of ClassLoader.findClass(String name) should be The resulting Class object.,"['return', 'ClassLoader.findClass(String name)']"
ClassLoader.findClass(String name),what's the parameter of ClassLoader.findClass(String name)?,the parameter of ClassLoader.findClass(String name) should be  The binary name of the class.,"['parameter', 'ClassLoader.findClass(String name)']"
"ClassLoader.defineClass(byte[] b, int off, int len)","what's the return of ClassLoader.defineClass(byte[] b, int off, int len)?","the return of ClassLoader.defineClass(byte[] b, int off, int len) should be off - The start offset in b of the class data.","['return', 'ClassLoader.defineClass(byte[] b, int off, int len)']"
"ClassLoader.defineClass(String name, byte[] b, int off, int len)","what's the return of ClassLoader.defineClass(String name, byte[] b, int off, int len)?","the return of ClassLoader.defineClass(String name, byte[] b, int off, int len) should be b - The bytes that make up the class data.  The bytes in positions
         off through off+len-1 should have the format
         of a valid class file as defined by
         The Java™ Virtual Machine Specification..","['return', 'ClassLoader.defineClass(String name, byte[] b, int off, int len)']"
"ClassLoader.defineClass(String name, byte[] b, int off, int len)","what's the parameter of ClassLoader.defineClass(String name, byte[] b, int off, int len)?","the parameter of ClassLoader.defineClass(String name, byte[] b, int off, int len) should be  The expected binary name of the class, or
         null if not known.","['parameter', 'ClassLoader.defineClass(String name, byte[] b, int off, int len)']"
"ClassLoader.defineClass(String name, byte[] b, int off, int len, ProtectionDomain protectionDomain)","what's the return of ClassLoader.defineClass(String name, byte[] b, int off, int len, ProtectionDomain protectionDomain)?","the return of ClassLoader.defineClass(String name, byte[] b, int off, int len, ProtectionDomain protectionDomain) should be b - The bytes that make up the class data. The bytes in positions
         off through off+len-1 should have the format
         of a valid class file as defined by
         The Java™ Virtual Machine Specification..","['return', 'ClassLoader.defineClass(String name, byte[] b, int off, int len, ProtectionDomain protectionDomain)']"
"ClassLoader.defineClass(String name, byte[] b, int off, int len, ProtectionDomain protectionDomain)","what's the parameter of ClassLoader.defineClass(String name, byte[] b, int off, int len, ProtectionDomain protectionDomain)?","the parameter of ClassLoader.defineClass(String name, byte[] b, int off, int len, ProtectionDomain protectionDomain) should be  The expected binary name of the class, or
         null if not known.","['parameter', 'ClassLoader.defineClass(String name, byte[] b, int off, int len, ProtectionDomain protectionDomain)']"
"ClassLoader.defineClass(String name, byte[] b, int off, int len, ProtectionDomain protectionDomain)","what's the parameter of ClassLoader.defineClass(String name, byte[] b, int off, int len, ProtectionDomain protectionDomain)?","the parameter of ClassLoader.defineClass(String name, byte[] b, int off, int len, ProtectionDomain protectionDomain) should be  The expected binary name of the class, or
         null if not known.","['parameter', 'ClassLoader.defineClass(String name, byte[] b, int off, int len, ProtectionDomain protectionDomain)']"
"ClassLoader.defineClass(String name, ByteBuffer b, ProtectionDomain protectionDomain)","what's the return of ClassLoader.defineClass(String name, ByteBuffer b, ProtectionDomain protectionDomain)?","the return of ClassLoader.defineClass(String name, ByteBuffer b, ProtectionDomain protectionDomain) should be b - The bytes that make up the class data. The bytes from positions
         b.position() through b.position() + b.limit() -1
          should have the format of a valid class file as defined by
         The Java™ Virtual Machine Specification..","['return', 'ClassLoader.defineClass(String name, ByteBuffer b, ProtectionDomain protectionDomain)']"
"ClassLoader.defineClass(String name, ByteBuffer b, ProtectionDomain protectionDomain)","what's the parameter of ClassLoader.defineClass(String name, ByteBuffer b, ProtectionDomain protectionDomain)?","the parameter of ClassLoader.defineClass(String name, ByteBuffer b, ProtectionDomain protectionDomain) should be  The expected binary name. of the class, or
         null if not known.","['parameter', 'ClassLoader.defineClass(String name, ByteBuffer b, ProtectionDomain protectionDomain)']"
"ClassLoader.defineClass(String name, ByteBuffer b, ProtectionDomain protectionDomain)","what's the parameter of ClassLoader.defineClass(String name, ByteBuffer b, ProtectionDomain protectionDomain)?","the parameter of ClassLoader.defineClass(String name, ByteBuffer b, ProtectionDomain protectionDomain) should be  The expected binary name. of the class, or
         null if not known.","['parameter', 'ClassLoader.defineClass(String name, ByteBuffer b, ProtectionDomain protectionDomain)']"
"ClassLoader.defineClass(String name, ByteBuffer b, ProtectionDomain protectionDomain)","what's the parameter of ClassLoader.defineClass(String name, ByteBuffer b, ProtectionDomain protectionDomain)?","the parameter of ClassLoader.defineClass(String name, ByteBuffer b, ProtectionDomain protectionDomain) should be  The expected binary name. of the class, or
         null if not known.","['parameter', 'ClassLoader.defineClass(String name, ByteBuffer b, ProtectionDomain protectionDomain)']"
ClassLoader.findSystemClass(String name),what's the return of ClassLoader.findSystemClass(String name)?,the return of ClassLoader.findSystemClass(String name) should be The Class object for the specified name.,"['return', 'ClassLoader.findSystemClass(String name)']"
ClassLoader.findSystemClass(String name),what's the parameter of ClassLoader.findSystemClass(String name)?,the parameter of ClassLoader.findSystemClass(String name) should be  The binary name of the class.,"['parameter', 'ClassLoader.findSystemClass(String name)']"
ClassLoader.findLoadedClass(String name),what's the return of ClassLoader.findLoadedClass(String name)?,the return of ClassLoader.findLoadedClass(String name) should be the class with the given binary name if this loader has been recorded by the Java virtual machine as an initiating loader of a class with that binary name. Otherwise null is returned..,"['return', 'ClassLoader.findLoadedClass(String name)']"
ClassLoader.findLoadedClass(String name),what's the parameter of ClassLoader.findLoadedClass(String name)?,the parameter of ClassLoader.findLoadedClass(String name) should be  The binary name of the class.,"['parameter', 'ClassLoader.findLoadedClass(String name)']"
ClassLoader.getResource(String name),what's the return of ClassLoader.getResource(String name)?,"the return of ClassLoader.getResource(String name) should be A URL object for reading the resource, or
          null if the resource could not be found or the invoker
          doesn't have adequate  privileges to get the resource..","['return', 'ClassLoader.getResource(String name)']"
ClassLoader.getResource(String name),what's the parameter of ClassLoader.getResource(String name)?,the parameter of ClassLoader.getResource(String name) should be  The resource name.,"['parameter', 'ClassLoader.getResource(String name)']"
ClassLoader.getResources(String name),what's the return of ClassLoader.getResources(String name)?,"the return of ClassLoader.getResources(String name) should be An enumeration of URL objects for
          the resource.  If no resources could  be found, the enumeration
          will be empty.  Resources that the class loader doesn't have
          access to will not be in the enumeration..","['return', 'ClassLoader.getResources(String name)']"
ClassLoader.getResources(String name),what's the parameter of ClassLoader.getResources(String name)?,the parameter of ClassLoader.getResources(String name) should be  The resource name.,"['parameter', 'ClassLoader.getResources(String name)']"
ClassLoader.findResource(String name),what's the return of ClassLoader.findResource(String name)?,"the return of ClassLoader.findResource(String name) should be A URL object for reading the resource, or
          null if the resource could not be found.","['return', 'ClassLoader.findResource(String name)']"
ClassLoader.findResource(String name),what's the parameter of ClassLoader.findResource(String name)?,the parameter of ClassLoader.findResource(String name) should be  The resource name.,"['parameter', 'ClassLoader.findResource(String name)']"
ClassLoader.findResources(String name),what's the return of ClassLoader.findResources(String name)?,the return of ClassLoader.findResources(String name) should be an enumeration of URL objects representing all the resources with the given name. Class loader implementations should override this method to specify where to load resources from..,"['return', 'ClassLoader.findResources(String name)']"
ClassLoader.findResources(String name),what's the parameter of ClassLoader.findResources(String name)?,the parameter of ClassLoader.findResources(String name) should be  The resource name.,"['parameter', 'ClassLoader.findResources(String name)']"
ClassLoader.registerAsParallelCapable(),what's the return of ClassLoader.registerAsParallelCapable()?,"the return of ClassLoader.registerAsParallelCapable() should be true if the caller is successfully registered as
          parallel capable and false if otherwise..","['return', 'ClassLoader.registerAsParallelCapable()']"
ClassLoader.getSystemResource(String name),what's the return of ClassLoader.getSystemResource(String name)?,"the return of ClassLoader.getSystemResource(String name) should be A URL object for reading the
          resource, or null if the resource could not be found.","['return', 'ClassLoader.getSystemResource(String name)']"
ClassLoader.getSystemResource(String name),what's the parameter of ClassLoader.getSystemResource(String name)?,the parameter of ClassLoader.getSystemResource(String name) should be  The resource name.,"['parameter', 'ClassLoader.getSystemResource(String name)']"
ClassLoader.getSystemResources(String name),what's the return of ClassLoader.getSystemResources(String name)?,"the return of ClassLoader.getSystemResources(String name) should be An enumeration of resource URL
          objects.","['return', 'ClassLoader.getSystemResources(String name)']"
ClassLoader.getSystemResources(String name),what's the parameter of ClassLoader.getSystemResources(String name)?,the parameter of ClassLoader.getSystemResources(String name) should be  The resource name.,"['parameter', 'ClassLoader.getSystemResources(String name)']"
ClassLoader.getResourceAsStream(String name),what's the return of ClassLoader.getResourceAsStream(String name)?,the return of ClassLoader.getResourceAsStream(String name) should be an input stream for reading the specified resource..,"['return', 'ClassLoader.getResourceAsStream(String name)']"
ClassLoader.getResourceAsStream(String name),what's the parameter of ClassLoader.getResourceAsStream(String name)?,the parameter of ClassLoader.getResourceAsStream(String name) should be  The resource name.,"['parameter', 'ClassLoader.getResourceAsStream(String name)']"
ClassLoader.getSystemResourceAsStream(String name),what's the return of ClassLoader.getSystemResourceAsStream(String name)?,"the return of ClassLoader.getSystemResourceAsStream(String name) should be An input stream for reading the resource, or null
          if the resource could not be found.","['return', 'ClassLoader.getSystemResourceAsStream(String name)']"
ClassLoader.getSystemResourceAsStream(String name),what's the parameter of ClassLoader.getSystemResourceAsStream(String name)?,the parameter of ClassLoader.getSystemResourceAsStream(String name) should be  The resource name.,"['parameter', 'ClassLoader.getSystemResourceAsStream(String name)']"
ClassLoader.getParent(),what's the return of ClassLoader.getParent()?,the return of ClassLoader.getParent() should be the parent class loader for delegation. Some implementations may use null to represent the bootstrap class loader. This method will return null in such implementations if this class loader's parent is the bootstrap class loader..,"['return', 'ClassLoader.getParent()']"
ClassLoader.getSystemClassLoader(),what's the return of ClassLoader.getSystemClassLoader()?,"the return of ClassLoader.getSystemClassLoader() should be the system class loader for delegation. This is the default delegation parent for new ClassLoader instances, and is typically the class loader used to start the application..","['return', 'ClassLoader.getSystemClassLoader()']"
"ClassLoader.definePackage(String name, String specTitle, String specVersion, String specVendor, String implTitle, String implVersion, String implVendor, URL sealBase)","what's the return of ClassLoader.definePackage(String name, String specTitle, String specVersion, String specVendor, String implTitle, String implVersion, String implVendor, URL sealBase)?","the return of ClassLoader.definePackage(String name, String specTitle, String specVersion, String specVendor, String implTitle, String implVersion, String implVendor, URL sealBase) should be specTitle - The specification title.","['return', 'ClassLoader.definePackage(String name, String specTitle, String specVersion, String specVendor, String implTitle, String implVersion, String implVendor, URL sealBase)']"
"ClassLoader.definePackage(String name, String specTitle, String specVersion, String specVendor, String implTitle, String implVersion, String implVendor, URL sealBase)","what's the parameter of ClassLoader.definePackage(String name, String specTitle, String specVersion, String specVendor, String implTitle, String implVersion, String implVendor, URL sealBase)?","the parameter of ClassLoader.definePackage(String name, String specTitle, String specVersion, String specVendor, String implTitle, String implVersion, String implVendor, URL sealBase) should be  The package name.","['parameter', 'ClassLoader.definePackage(String name, String specTitle, String specVersion, String specVendor, String implTitle, String implVersion, String implVendor, URL sealBase)']"
"ClassLoader.definePackage(String name, String specTitle, String specVersion, String specVendor, String implTitle, String implVersion, String implVendor, URL sealBase)","what's the parameter of ClassLoader.definePackage(String name, String specTitle, String specVersion, String specVendor, String implTitle, String implVersion, String implVendor, URL sealBase)?","the parameter of ClassLoader.definePackage(String name, String specTitle, String specVersion, String specVendor, String implTitle, String implVersion, String implVendor, URL sealBase) should be  The package name.","['parameter', 'ClassLoader.definePackage(String name, String specTitle, String specVersion, String specVendor, String implTitle, String implVersion, String implVendor, URL sealBase)']"
ClassLoader.getPackage(String name),what's the return of ClassLoader.getPackage(String name)?,the return of ClassLoader.getPackage(String name) should be a Package that has been defined by this class loader or any of its ancestors..,"['return', 'ClassLoader.getPackage(String name)']"
ClassLoader.getPackage(String name),what's the parameter of ClassLoader.getPackage(String name)?,the parameter of ClassLoader.getPackage(String name) should be  The package name.,"['parameter', 'ClassLoader.getPackage(String name)']"
ClassLoader.getPackages(),what's the return of ClassLoader.getPackages()?,the return of ClassLoader.getPackages() should be all of the Packages defined by this class loader and its ancestors..,"['return', 'ClassLoader.getPackages()']"
ClassLoader.findLibrary(String libname),what's the return of ClassLoader.findLibrary(String libname)?,"the return of ClassLoader.findLibrary(String libname) should be the absolute path name of a native library. The VM invokes this method to locate the native libraries that belong to classes loaded with this class loader. If this method returns null, the VM searches the library along the path specified as the ""java.library.path"" property..","['return', 'ClassLoader.findLibrary(String libname)']"
ClassLoader.findLibrary(String libname),what's the parameter of ClassLoader.findLibrary(String libname)?,the parameter of ClassLoader.findLibrary(String libname) should be  The library name.,"['parameter', 'ClassLoader.findLibrary(String libname)']"
"ClassLoader.setPackageAssertionStatus(String packageName, boolean enabled)","what's the parameter of ClassLoader.setPackageAssertionStatus(String packageName, boolean enabled)?","the parameter of ClassLoader.setPackageAssertionStatus(String packageName, boolean enabled) should be  The name of the package whose package default assertion status
         is to be set. A null value indicates the unnamed
         package that is ""current""
         (see section 7.4.2 of
         The Java™ Language Specification.).","['parameter', 'ClassLoader.setPackageAssertionStatus(String packageName, boolean enabled)']"
"ClassLoader.setClassAssertionStatus(String className, boolean enabled)","what's the parameter of ClassLoader.setClassAssertionStatus(String className, boolean enabled)?","the parameter of ClassLoader.setClassAssertionStatus(String className, boolean enabled) should be  The fully qualified class name of the top.","['parameter', 'ClassLoader.setClassAssertionStatus(String className, boolean enabled)']"
Comparable.compareTo(T o),what's the return of Comparable.compareTo(T o)?,"the return of Comparable.compareTo(T o) should be a negative integer, zero, or a positive integer as this object
          is less than, equal to, or greater than the specified object..","['return', 'Comparable.compareTo(T o)']"
Comparable.compareTo(T o),what's the parameter of Comparable.compareTo(T o)?,the parameter of Comparable.compareTo(T o) should be  the object to be compared..,"['parameter', 'Comparable.compareTo(T o)']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
Number.intValue(),what's the return of Number.intValue()?,the return of Number.intValue() should be the value of this Short as an int after a widening primitive conversion..,"['return', 'Number.intValue()']"
Number.longValue(),what's the return of Number.longValue()?,the return of Number.longValue() should be the value of this Short as a long after a widening primitive conversion..,"['return', 'Number.longValue()']"
Number.floatValue(),what's the return of Number.floatValue()?,the return of Number.floatValue() should be the value of this Short as a float after a widening primitive conversion..,"['return', 'Number.floatValue()']"
Number.doubleValue(),what's the return of Number.doubleValue()?,the return of Number.doubleValue() should be the value of this Short as a double after a widening primitive conversion..,"['return', 'Number.doubleValue()']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
Object.equals(Object obj),what's the return of Object.equals(Object obj)?,"the return of Object.equals(Object obj) should be true if the objects are the same;
          false otherwise..","['return', 'Object.equals(Object obj)']"
Object.equals(Object obj),what's the parameter of Object.equals(Object obj)?,the parameter of Object.equals(Object obj) should be  the object to compare with..,"['parameter', 'Object.equals(Object obj)']"
Enum<E.name(),what's the return of Enum<E.name()?,"the return of Enum<E.name() should be the name of this enum constant, exactly as declared in its enum declaration. Most programmers should use the toString() method in preference to this one, as the toString method may return a more user-friendly name. This method is designed primarily for use in specialized situations where correctness depends on getting the exact name, which will not vary from release to release..","['return', 'Enum<E.name()']"
Enum<E.ordinal(),what's the return of Enum<E.ordinal()?,"the return of Enum<E.ordinal() should be the ordinal of this enumeration constant (its position in its enum declaration, where the initial constant is assigned an ordinal of zero). Most programmers will have no use for this method. It is designed for use by sophisticated enum-based data structures, such as EnumSet and EnumMap..","['return', 'Enum<E.ordinal()']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
Object.equals(Object other),what's the return of Object.equals(Object other)?,the return of Object.equals(Object other) should be true if the specified object is equal to this enum constant..,"['return', 'Object.equals(Object other)']"
Object.equals(Object other),what's the parameter of Object.equals(Object other)?,the parameter of Object.equals(Object other) should be  the object to be compared for equality with this object..,"['parameter', 'Object.equals(Object other)']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
Object.clone(),what's the return of Object.clone()?,the return of Object.clone() should be a shallow copy of this AbstractMap instance: the keys and values themselves are not cloned..,"['return', 'Object.clone()']"
Enum.compareTo(E o),what's the return of Enum.compareTo(E o)?,"the return of Enum.compareTo(E o) should be a negative integer, zero, or a positive integer as this object
          is less than, equal to, or greater than the specified object..","['return', 'Enum.compareTo(E o)']"
Enum.compareTo(E o),what's the parameter of Enum.compareTo(E o)?,the parameter of Enum.compareTo(E o) should be  the object to be compared..,"['parameter', 'Enum.compareTo(E o)']"
Enum<E.getDeclaringClass(),what's the return of Enum<E.getDeclaringClass()?,the return of Enum<E.getDeclaringClass() should be the Class object corresponding to this enum constant's enum type. Two enum constants e1 and e2 are of the same enum type if and only if e1.getDeclaringClass() == e2.getDeclaringClass(). (The value returned by this method may differ from the one returned by the Object.getClass() method for enum constants with constant-specific class bodies.).,"['return', 'Enum<E.getDeclaringClass()']"
"Enum<E.valueOf(Class<T> enumType, String name)","what's the return of Enum<E.valueOf(Class<T> enumType, String name)?","the return of Enum<E.valueOf(Class<T> enumType, String name) should be the enum constant of the specified enum type with the specified name. The name must match exactly an identifier used to declare an enum constant in this type. (Extraneous whitespace characters are not permitted.).","['return', 'Enum<E.valueOf(Class<T> enumType, String name)']"
"Enum<E.valueOf(Class<T> enumType, String name)","what's the parameter of Enum<E.valueOf(Class<T> enumType, String name)?","the parameter of Enum<E.valueOf(Class<T> enumType, String name) should be  the Class object of the enum type from which
      to return a constant.","['parameter', 'Enum<E.valueOf(Class<T> enumType, String name)']"
Float.toString(float f),what's the return of Float.toString(float f)?,"the return of Float.toString(float f) should be a string representation of the float argument. All characters mentioned below are ASCII characters. If the argument is NaN, the result is the string ""NaN"". Otherwise, the result is a string that represents the sign and magnitude (absolute value) of the argument. If the sign is negative, the first character of the result is '-' ('\u002D'); if the sign is positive, no sign character appears in the result. As for the magnitude m: If m is infinity, it is represented by the characters ""Infinity""; thus, positive infinity produces the result ""Infinity"" and negative infinity produces the result ""-Infinity"". If m is zero, it is represented by the characters ""0.0""; thus, negative zero produces the result ""-0.0"" and positive zero produces the result ""0.0"". If m is greater than or equal to 10-3 but less than 107, then it is represented as the integer part of m, in decimal form with no leading zeroes, followed by '.' ('\u002E'), followed by one or more decimal digits representing the fractional part of m. If m is less than 10-3 or greater than or equal to 107, then it is represented in so-called ""computerized scientific notation."" Let n be the unique integer such that 10n ≤ m < 10n+1; then let a be the mathematically exact quotient of m and 10n so that 1 ≤ a < 10. The magnitude is then represented as the integer part of a, as a single decimal digit, followed by '.' ('\u002E'), followed by decimal digits representing the fractional part of a, followed by the letter 'E' ('\u0045'), followed by a representation of n as a decimal integer, as produced by the method Integer.toString(int). How many digits must be printed for the fractional part of m or a? There must be at least one digit to represent the fractional part, and beyond that as many, but only as many, more digits as are needed to uniquely distinguish the argument value from adjacent values of type float. That is, suppose that x is the exact mathematical value represented by the decimal representation produced by this method for a finite nonzero argument f. Then f must be the float value nearest to x; or, if two float values are equally close to x, then f must be one of them and the least significant bit of the significand of f must be 0..","['return', 'Float.toString(float f)']"
Float.toHexString(float f),what's the return of Float.toHexString(float f)?,"the return of Float.toHexString(float f) should be a hexadecimal string representation of the float argument. All characters mentioned below are ASCII characters. If the argument is NaN, the result is the string ""NaN"". Otherwise, the result is a string that represents the sign and magnitude (absolute value) of the argument. If the sign is negative, the first character of the result is '-' ('\u002D'); if the sign is positive, no sign character appears in the result. As for the magnitude m: If m is infinity, it is represented by the string ""Infinity""; thus, positive infinity produces the result ""Infinity"" and negative infinity produces the result ""-Infinity"". If m is zero, it is represented by the string ""0x0.0p0""; thus, negative zero produces the result ""-0x0.0p0"" and positive zero produces the result ""0x0.0p0"". If m is a float value with a normalized representation, substrings are used to represent the significand and exponent fields. The significand is represented by the characters ""0x1."" followed by a lowercase hexadecimal representation of the rest of the significand as a fraction. Trailing zeros in the hexadecimal representation are removed unless all the digits are zero, in which case a single zero is used. Next, the exponent is represented by ""p"" followed by a decimal string of the unbiased exponent as if produced by a call to Integer.toString on the exponent value. If m is a float value with a subnormal representation, the significand is represented by the characters ""0x0."" followed by a hexadecimal representation of the rest of the significand as a fraction. Trailing zeros in the hexadecimal representation are removed. Next, the exponent is represented by ""p-126"". Note that there must be at least one nonzero digit in a subnormal significand. Examples Floating-point ValueHexadecimal String 1.0 0x1.0p0 -1.0 -0x1.0p0 2.0 0x1.0p1 3.0 0x1.8p1 0.5 0x1.0p-1 0.25 0x1.0p-2 Float.MAX_VALUE 0x1.fffffep127 Minimum Normal Value 0x1.0p-126 Maximum Subnormal Value 0x0.fffffep-126 Float.MIN_VALUE 0x0.000002p-126.","['return', 'Float.toHexString(float f)']"
Float.valueOf(String s),what's the return of Float.valueOf(String s)?,"the return of Float.valueOf(String s) should be a Float object holding the float value represented by the argument string s. FloatValue: Signopt NaN Signopt Infinity Signopt FloatingPointLiteral Signopt HexFloatingPointLiteral SignedInteger HexFloatingPointLiteral: HexSignificand BinaryExponent FloatTypeSuffixopt HexSignificand: HexNumeral HexNumeral . 0x HexDigitsopt . HexDigits 0X HexDigitsopt . HexDigits BinaryExponent: BinaryExponentIndicator SignedInteger BinaryExponentIndicator: p P where Sign, FloatingPointLiteral, HexNumeral, HexDigits, SignedInteger and FloatTypeSuffix are as defined in the lexical structure sections of The Java™ Language Specification, except that underscores are not accepted between digits. If s does not have the form of a FloatValue, then a NumberFormatException is thrown. Otherwise, s is regarded as representing an exact decimal value in the usual ""computerized scientific notation"" or as an exact hexadecimal value; this exact numerical value is then conceptually converted to an ""infinitely precise"" binary value that is then rounded to type float by the usual round-to-nearest rule of IEEE 754 floating-point arithmetic, which includes preserving the sign of a zero value. Note that the round-to-nearest rule also implies overflow and underflow behaviour; if the exact value of s is large enough in magnitude (greater than or equal to (MAX_VALUE + ulp(MAX_VALUE)/2), rounding to float will result in an infinity and if the exact value of s is small enough in magnitude (less than or equal to MIN_VALUE/2), rounding to float will result in a zero. Finally, after rounding a Float object representing this float value is returned..","['return', 'Float.valueOf(String s)']"
Float.valueOf(float f),what's the return of Float.valueOf(float f)?,"the return of Float.valueOf(float f) should be a Float instance representing the specified float value. If a new Float instance is not required, this method should generally be used in preference to the constructor Float(float), as this method is likely to yield significantly better space and time performance by caching frequently requested values..","['return', 'Float.valueOf(float f)']"
Float.parseFloat(String s),what's the return of Float.parseFloat(String s)?,"the return of Float.parseFloat(String s) should be a new float initialized to the value represented by the specified String, as performed by the valueOf method of class Float..","['return', 'Float.parseFloat(String s)']"
Float.parseFloat(String s),what's the parameter of Float.parseFloat(String s)?,the parameter of Float.parseFloat(String s) should be  the string to be parsed..,"['parameter', 'Float.parseFloat(String s)']"
Float.isNaN(float v),what's the return of Float.isNaN(float v)?,"the return of Float.isNaN(float v) should be true if the specified number is a Not-a-Number (NaN) value, false otherwise..","['return', 'Float.isNaN(float v)']"
Float.isInfinite(float v),what's the return of Float.isInfinite(float v)?,"the return of Float.isInfinite(float v) should be true if the specified number is infinitely large in magnitude, false otherwise..","['return', 'Float.isInfinite(float v)']"
Float.isFinite(float f),what's the return of Float.isFinite(float f)?,the return of Float.isFinite(float f) should be true if the argument is a finite floating-point value; returns false otherwise (for NaN and infinity arguments)..,"['return', 'Float.isFinite(float f)']"
Float.isNaN(),what's the return of Float.isNaN()?,"the return of Float.isNaN() should be true if this Float value is a Not-a-Number (NaN), false otherwise..","['return', 'Float.isNaN()']"
Float.isInfinite(),what's the return of Float.isInfinite()?,"the return of Float.isInfinite() should be true if this Float value is infinitely large in magnitude, false otherwise..","['return', 'Float.isInfinite()']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
Number.intValue(),what's the return of Number.intValue()?,the return of Number.intValue() should be the value of this Short as an int after a widening primitive conversion..,"['return', 'Number.intValue()']"
Number.longValue(),what's the return of Number.longValue()?,the return of Number.longValue() should be the value of this Short as a long after a widening primitive conversion..,"['return', 'Number.longValue()']"
Number.floatValue(),what's the return of Number.floatValue()?,the return of Number.floatValue() should be the value of this Short as a float after a widening primitive conversion..,"['return', 'Number.floatValue()']"
Number.doubleValue(),what's the return of Number.doubleValue()?,the return of Number.doubleValue() should be the value of this Short as a double after a widening primitive conversion..,"['return', 'Number.doubleValue()']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
Float.hashCode(float value),what's the return of Float.hashCode(float value)?,the return of Float.hashCode(float value) should be a hash code for a float value; compatible with Float.hashCode()..,"['return', 'Float.hashCode(float value)']"
Object.equals(Object obj),what's the return of Object.equals(Object obj)?,"the return of Object.equals(Object obj) should be true if the objects are the same;
          false otherwise..","['return', 'Object.equals(Object obj)']"
Object.equals(Object obj),what's the parameter of Object.equals(Object obj)?,the parameter of Object.equals(Object obj) should be  the object to compare with..,"['parameter', 'Object.equals(Object obj)']"
Float.floatToIntBits(float value),what's the return of Float.floatToIntBits(float value)?,"the return of Float.floatToIntBits(float value) should be a representation of the specified floating-point value according to the IEEE 754 floating-point ""single format"" bit layout..","['return', 'Float.floatToIntBits(float value)']"
Float.floatToRawIntBits(float value),what's the return of Float.floatToRawIntBits(float value)?,"the return of Float.floatToRawIntBits(float value) should be a representation of the specified floating-point value according to the IEEE 754 floating-point ""single format"" bit layout, preserving Not-a-Number (NaN) values..","['return', 'Float.floatToRawIntBits(float value)']"
Float.intBitsToFloat(int bits),what's the return of Float.intBitsToFloat(int bits)?,"the return of Float.intBitsToFloat(int bits) should be the float value corresponding to a given bit representation. The argument is considered to be a representation of a floating-point value according to the IEEE 754 floating-point ""single format"" bit layout. int s = ((bits >> 31) == 0) ? 1 : -1; int e = ((bits >> 23) & 0xff); int m = (e == 0) ? (bits & 0x7fffff) << 1 : (bits & 0x7fffff) | 0x800000; Then the floating-point result equals the value of the mathematical expression s·m·2e-150..","['return', 'Float.intBitsToFloat(int bits)']"
Comparable.compareTo(Float anotherFloat),what's the return of Comparable.compareTo(Float anotherFloat)?,"the return of Comparable.compareTo(Float anotherFloat) should be the value 0 if anotherFloat is
          numerically equal to this Float; a value
          less than 0 if this Float
          is numerically less than anotherFloat;
          and a value greater than 0 if this
          Float is numerically greater than
          anotherFloat..","['return', 'Comparable.compareTo(Float anotherFloat)']"
Comparable.compareTo(Float anotherFloat),what's the parameter of Comparable.compareTo(Float anotherFloat)?,the parameter of Comparable.compareTo(Float anotherFloat) should be  the Float to be compared..,"['parameter', 'Comparable.compareTo(Float anotherFloat)']"
"Float.compare(float f1, float f2)","what's the return of Float.compare(float f1, float f2)?","the return of Float.compare(float f1, float f2) should be f2 - the second float to compare..","['return', 'Float.compare(float f1, float f2)']"
"Float.sum(float a, float b)","what's the return of Float.sum(float a, float b)?","the return of Float.sum(float a, float b) should be b - the second operand.","['return', 'Float.sum(float a, float b)']"
"Float.max(float a, float b)","what's the return of Float.max(float a, float b)?","the return of Float.max(float a, float b) should be the greater of two float values as if by calling Math.max..","['return', 'Float.max(float a, float b)']"
"Float.min(float a, float b)","what's the return of Float.min(float a, float b)?","the return of Float.min(float a, float b) should be the smaller of two float values as if by calling Math.min..","['return', 'Float.min(float a, float b)']"
"Integer.toString(int i, int radix)","what's the return of Integer.toString(int i, int radix)?","the return of Integer.toString(int i, int radix) should be a string representation of the first argument in the radix specified by the second argument. 0123456789abcdefghijklmnopqrstuvwxyz These are '\u0030' through '\u0039' and '\u0061' through '\u007A'. If radix is N, then the first N of these characters are used as radix-N digits in the order shown. Thus, the digits for hexadecimal (radix 16) are 0123456789abcdef. If uppercase letters are desired, the String.toUpperCase() method may be called on the result: Integer.toString(n, 16).toUpperCase().","['return', 'Integer.toString(int i, int radix)']"
"Integer.toUnsignedString(int i, int radix)","what's the return of Integer.toUnsignedString(int i, int radix)?","the return of Integer.toUnsignedString(int i, int radix) should be a string representation of the first argument as an unsigned integer value in the radix specified by the second argument..","['return', 'Integer.toUnsignedString(int i, int radix)']"
Integer.toHexString(int i),what's the return of Integer.toHexString(int i)?,"the return of Integer.toHexString(int i) should be a string representation of the integer argument as an unsigned integer in base 16. 0123456789abcdef These are the characters '\u0030' through '\u0039' and '\u0061' through '\u0066'. If uppercase letters are desired, the String.toUpperCase() method may be called on the result: Integer.toHexString(n).toUpperCase().","['return', 'Integer.toHexString(int i)']"
Integer.toOctalString(int i),what's the return of Integer.toOctalString(int i)?,the return of Integer.toOctalString(int i) should be a string representation of the integer argument as an unsigned integer in base 8. 01234567 These are the characters '\u0030' through '\u0037'..,"['return', 'Integer.toOctalString(int i)']"
Integer.toBinaryString(int i),what's the return of Integer.toBinaryString(int i)?,the return of Integer.toBinaryString(int i) should be a string representation of the integer argument as an unsigned integer in base 2..,"['return', 'Integer.toBinaryString(int i)']"
Integer.toString(int i),what's the return of Integer.toString(int i)?,"the return of Integer.toString(int i) should be a String object representing the specified integer. The argument is converted to signed decimal representation and returned as a string, exactly as if the argument and radix 10 were given as arguments to the toString(int, int) method..","['return', 'Integer.toString(int i)']"
Integer.toUnsignedString(int i),what's the return of Integer.toUnsignedString(int i)?,"the return of Integer.toUnsignedString(int i) should be a string representation of the argument as an unsigned decimal value. The argument is converted to unsigned decimal representation and returned as a string exactly as if the argument and radix 10 were given as arguments to the toUnsignedString(int, int) method..","['return', 'Integer.toUnsignedString(int i)']"
"Integer.parseInt(String s, int radix)","what's the return of Integer.parseInt(String s, int radix)?","the return of Integer.parseInt(String s, int radix) should be radix - the radix to be used while parsing s..","['return', 'Integer.parseInt(String s, int radix)']"
"Integer.parseInt(String s, int radix)","what's the parameter of Integer.parseInt(String s, int radix)?","the parameter of Integer.parseInt(String s, int radix) should be  the String containing the integer
                  representation to be parsed.","['parameter', 'Integer.parseInt(String s, int radix)']"
Integer.parseInt(String s),what's the return of Integer.parseInt(String s)?,the return of Integer.parseInt(String s) should be the integer value represented by the argument in decimal..,"['return', 'Integer.parseInt(String s)']"
Integer.parseInt(String s),what's the parameter of Integer.parseInt(String s)?,"the parameter of Integer.parseInt(String s) should be  a String containing the int
             representation to be parsed.","['parameter', 'Integer.parseInt(String s)']"
"Integer.parseUnsignedInt(String s, int radix)","what's the return of Integer.parseUnsignedInt(String s, int radix)?","the return of Integer.parseUnsignedInt(String s, int radix) should be radix - the radix to be used while parsing s..","['return', 'Integer.parseUnsignedInt(String s, int radix)']"
"Integer.parseUnsignedInt(String s, int radix)","what's the parameter of Integer.parseUnsignedInt(String s, int radix)?","the parameter of Integer.parseUnsignedInt(String s, int radix) should be  the String containing the unsigned integer
                  representation to be parsed.","['parameter', 'Integer.parseUnsignedInt(String s, int radix)']"
Integer.parseUnsignedInt(String s),what's the return of Integer.parseUnsignedInt(String s)?,the return of Integer.parseUnsignedInt(String s) should be the unsigned integer value represented by the argument in decimal..,"['return', 'Integer.parseUnsignedInt(String s)']"
Integer.parseUnsignedInt(String s),what's the parameter of Integer.parseUnsignedInt(String s)?,"the parameter of Integer.parseUnsignedInt(String s) should be  a String containing the unsigned int
            representation to be parsed.","['parameter', 'Integer.parseUnsignedInt(String s)']"
"Integer.valueOf(String s, int radix)","what's the return of Integer.valueOf(String s, int radix)?","the return of Integer.valueOf(String s, int radix) should be an Integer object holding the value extracted from the specified String when parsed with the radix given by the second argument. The first argument is interpreted as representing a signed integer in the radix specified by the second argument, exactly as if the arguments were given to the parseInt(java.lang.String, int) method. The result is an Integer object that represents the integer value specified by the string. new Integer(Integer.parseInt(s, radix)).","['return', 'Integer.valueOf(String s, int radix)']"
"Integer.valueOf(String s, int radix)","what's the parameter of Integer.valueOf(String s, int radix)?","the parameter of Integer.valueOf(String s, int radix) should be  the string to be parsed..","['parameter', 'Integer.valueOf(String s, int radix)']"
Integer.valueOf(String s),what's the return of Integer.valueOf(String s)?,"the return of Integer.valueOf(String s) should be an Integer object holding the value of the specified String. The argument is interpreted as representing a signed decimal integer, exactly as if the argument were given to the parseInt(java.lang.String) method. The result is an Integer object that represents the integer value specified by the string. new Integer(Integer.parseInt(s)).","['return', 'Integer.valueOf(String s)']"
Integer.valueOf(String s),what's the parameter of Integer.valueOf(String s)?,the parameter of Integer.valueOf(String s) should be  the string to be parsed..,"['parameter', 'Integer.valueOf(String s)']"
Integer.valueOf(int i),what's the return of Integer.valueOf(int i)?,"the return of Integer.valueOf(int i) should be an Integer instance representing the specified int value. If a new Integer instance is not required, this method should generally be used in preference to the constructor Integer(int), as this method is likely to yield significantly better space and time performance by caching frequently requested values. This method will always cache values in the range -128 to 127, inclusive, and may cache other values outside of this range..","['return', 'Integer.valueOf(int i)']"
Number.intValue(),what's the return of Number.intValue()?,the return of Number.intValue() should be the value of this Short as an int after a widening primitive conversion..,"['return', 'Number.intValue()']"
Number.longValue(),what's the return of Number.longValue()?,the return of Number.longValue() should be the value of this Short as a long after a widening primitive conversion..,"['return', 'Number.longValue()']"
Number.floatValue(),what's the return of Number.floatValue()?,the return of Number.floatValue() should be the value of this Short as a float after a widening primitive conversion..,"['return', 'Number.floatValue()']"
Number.doubleValue(),what's the return of Number.doubleValue()?,the return of Number.doubleValue() should be the value of this Short as a double after a widening primitive conversion..,"['return', 'Number.doubleValue()']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
Integer.hashCode(int value),what's the return of Integer.hashCode(int value)?,the return of Integer.hashCode(int value) should be a hash code for a int value; compatible with Integer.hashCode()..,"['return', 'Integer.hashCode(int value)']"
Object.equals(Object obj),what's the return of Object.equals(Object obj)?,"the return of Object.equals(Object obj) should be true if the objects are the same;
          false otherwise..","['return', 'Object.equals(Object obj)']"
Object.equals(Object obj),what's the parameter of Object.equals(Object obj)?,the parameter of Object.equals(Object obj) should be  the object to compare with..,"['parameter', 'Object.equals(Object obj)']"
Integer.getInteger(String nm),what's the return of Integer.getInteger(String nm)?,the return of Integer.getInteger(String nm) should be the Integer value of the property..,"['return', 'Integer.getInteger(String nm)']"
Integer.getInteger(String nm),what's the parameter of Integer.getInteger(String nm)?,the parameter of Integer.getInteger(String nm) should be  property name..,"['parameter', 'Integer.getInteger(String nm)']"
"Integer.getInteger(String nm, int val)","what's the return of Integer.getInteger(String nm, int val)?","the return of Integer.getInteger(String nm, int val) should be val - default value..","['return', 'Integer.getInteger(String nm, int val)']"
"Integer.getInteger(String nm, int val)","what's the parameter of Integer.getInteger(String nm, int val)?","the parameter of Integer.getInteger(String nm, int val) should be  property name..","['parameter', 'Integer.getInteger(String nm, int val)']"
"Integer.getInteger(String nm, Integer val)","what's the return of Integer.getInteger(String nm, Integer val)?","the return of Integer.getInteger(String nm, Integer val) should be the integer value of the system property with the specified name. The first argument is treated as the name of a system property. System properties are accessible through the System.getProperty(java.lang.String) method. The string value of this property is then interpreted as an integer value, as per the decode method, and an Integer object representing this value is returned; in summary: If the property value begins with the two ASCII characters 0x or the ASCII character #, not followed by a minus sign, then the rest of it is parsed as a hexadecimal integer exactly as by the method valueOf(java.lang.String, int) with radix 16. If the property value begins with the ASCII character 0 followed by another character, it is parsed as an octal integer exactly as by the method valueOf(java.lang.String, int) with radix 8. Otherwise, the property value is parsed as a decimal integer exactly as by the method valueOf(java.lang.String, int) with radix 10..","['return', 'Integer.getInteger(String nm, Integer val)']"
"Integer.getInteger(String nm, Integer val)","what's the parameter of Integer.getInteger(String nm, Integer val)?","the parameter of Integer.getInteger(String nm, Integer val) should be  property name..","['parameter', 'Integer.getInteger(String nm, Integer val)']"
"Integer.getInteger(String nm, Integer val)","what's the parameter of Integer.getInteger(String nm, Integer val)?","the parameter of Integer.getInteger(String nm, Integer val) should be  property name..","['parameter', 'Integer.getInteger(String nm, Integer val)']"
Comparable.compareTo(Integer anotherInteger),what's the return of Comparable.compareTo(Integer anotherInteger)?,"the return of Comparable.compareTo(Integer anotherInteger) should be the value 0 if this Integer is
          equal to the argument Integer; a value less than
          0 if this Integer is numerically less
          than the argument Integer; and a value greater
          than 0 if this Integer is numerically
           greater than the argument Integer (signed
           comparison)..","['return', 'Comparable.compareTo(Integer anotherInteger)']"
Comparable.compareTo(Integer anotherInteger),what's the parameter of Comparable.compareTo(Integer anotherInteger)?,the parameter of Comparable.compareTo(Integer anotherInteger) should be  the Integer to be compared..,"['parameter', 'Comparable.compareTo(Integer anotherInteger)']"
"Integer.compare(int x, int y)","what's the return of Integer.compare(int x, int y)?","the return of Integer.compare(int x, int y) should be y - the second int to compare.","['return', 'Integer.compare(int x, int y)']"
"Integer.compareUnsigned(int x, int y)","what's the return of Integer.compareUnsigned(int x, int y)?","the return of Integer.compareUnsigned(int x, int y) should be y - the second int to compare.","['return', 'Integer.compareUnsigned(int x, int y)']"
Integer.toUnsignedLong(int x),what's the return of Integer.toUnsignedLong(int x)?,"the return of Integer.toUnsignedLong(int x) should be the argument converted to long by an unsigned
         conversion.","['return', 'Integer.toUnsignedLong(int x)']"
"Integer.divideUnsigned(int dividend, int divisor)","what's the return of Integer.divideUnsigned(int dividend, int divisor)?","the return of Integer.divideUnsigned(int dividend, int divisor) should be the unsigned quotient of dividing the first argument by the second where each argument and the result is interpreted as an unsigned value..","['return', 'Integer.divideUnsigned(int dividend, int divisor)']"
"Integer.remainderUnsigned(int dividend, int divisor)","what's the return of Integer.remainderUnsigned(int dividend, int divisor)?","the return of Integer.remainderUnsigned(int dividend, int divisor) should be the unsigned remainder from dividing the first argument by the second where each argument and the result is interpreted as an unsigned value..","['return', 'Integer.remainderUnsigned(int dividend, int divisor)']"
Integer.highestOneBit(int i),what's the return of Integer.highestOneBit(int i)?,"the return of Integer.highestOneBit(int i) should be an int value with at most a single one-bit, in the position of the highest-order (""leftmost"") one-bit in the specified int value. Returns zero if the specified value has no one-bits in its two's complement binary representation, that is, if it is equal to zero..","['return', 'Integer.highestOneBit(int i)']"
Integer.lowestOneBit(int i),what's the return of Integer.lowestOneBit(int i)?,"the return of Integer.lowestOneBit(int i) should be an int value with at most a single one-bit, in the position of the lowest-order (""rightmost"") one-bit in the specified int value. Returns zero if the specified value has no one-bits in its two's complement binary representation, that is, if it is equal to zero..","['return', 'Integer.lowestOneBit(int i)']"
Integer.numberOfLeadingZeros(int i),what's the return of Integer.numberOfLeadingZeros(int i)?,"the return of Integer.numberOfLeadingZeros(int i) should be the number of zero bits preceding the highest-order (""leftmost"") one-bit in the two's complement binary representation of the specified int value. Returns 32 if the specified value has no one-bits in its two's complement representation, in other words if it is equal to zero. floor(log2(x)) = 31 - numberOfLeadingZeros(x) ceil(log2(x)) = 32 - numberOfLeadingZeros(x - 1).","['return', 'Integer.numberOfLeadingZeros(int i)']"
Integer.numberOfTrailingZeros(int i),what's the return of Integer.numberOfTrailingZeros(int i)?,"the return of Integer.numberOfTrailingZeros(int i) should be the number of zero bits following the lowest-order (""rightmost"") one-bit in the two's complement binary representation of the specified int value. Returns 32 if the specified value has no one-bits in its two's complement representation, in other words if it is equal to zero..","['return', 'Integer.numberOfTrailingZeros(int i)']"
Integer.bitCount(int i),what's the return of Integer.bitCount(int i)?,the return of Integer.bitCount(int i) should be the number of one-bits in the two's complement binary representation of the specified int value. This function is sometimes referred to as the population count..,"['return', 'Integer.bitCount(int i)']"
"Integer.rotateLeft(int i, int distance)","what's the return of Integer.rotateLeft(int i, int distance)?","the return of Integer.rotateLeft(int i, int distance) should be the value obtained by rotating the two's complement binary representation of the specified int value left by the specified number of bits. (Bits shifted out of the left hand, or high-order, side reenter on the right, or low-order.).","['return', 'Integer.rotateLeft(int i, int distance)']"
"Integer.rotateRight(int i, int distance)","what's the return of Integer.rotateRight(int i, int distance)?","the return of Integer.rotateRight(int i, int distance) should be the value obtained by rotating the two's complement binary representation of the specified int value right by the specified number of bits. (Bits shifted out of the right hand, or low-order, side reenter on the left, or high-order.).","['return', 'Integer.rotateRight(int i, int distance)']"
Integer.reverse(int i),what's the return of Integer.reverse(int i)?,the return of Integer.reverse(int i) should be the value obtained by reversing the order of the bits in the two's complement binary representation of the specified int value..,"['return', 'Integer.reverse(int i)']"
Integer.signum(int i),what's the return of Integer.signum(int i)?,the return of Integer.signum(int i) should be the signum function of the specified int value. (The return value is -1 if the specified value is negative; 0 if the specified value is zero; and 1 if the specified value is positive.).,"['return', 'Integer.signum(int i)']"
Integer.reverseBytes(int i),what's the return of Integer.reverseBytes(int i)?,the return of Integer.reverseBytes(int i) should be the value obtained by reversing the order of the bytes in the two's complement representation of the specified int value..,"['return', 'Integer.reverseBytes(int i)']"
"Integer.sum(int a, int b)","what's the return of Integer.sum(int a, int b)?","the return of Integer.sum(int a, int b) should be b - the second operand.","['return', 'Integer.sum(int a, int b)']"
"Integer.max(int a, int b)","what's the return of Integer.max(int a, int b)?","the return of Integer.max(int a, int b) should be the greater of two int values as if by calling Math.max..","['return', 'Integer.max(int a, int b)']"
"Integer.min(int a, int b)","what's the return of Integer.min(int a, int b)?","the return of Integer.min(int a, int b) should be the smaller of two int values as if by calling Math.min..","['return', 'Integer.min(int a, int b)']"
Iterable.iterator(),what's the return of Iterable.iterator()?,the return of Iterable.iterator() should be an iterator over the elements in this list in proper sequence..,"['return', 'Iterable.iterator()']"
Iterable.spliterator(),what's the return of Iterable.spliterator()?,the return of Iterable.spliterator() should be a Spliterator over the elements in this list.,"['return', 'Iterable.spliterator()']"
Number.intValue(),what's the return of Number.intValue()?,the return of Number.intValue() should be the value of this Short as an int after a widening primitive conversion..,"['return', 'Number.intValue()']"
Number.longValue(),what's the return of Number.longValue()?,the return of Number.longValue() should be the value of this Short as a long after a widening primitive conversion..,"['return', 'Number.longValue()']"
Number.floatValue(),what's the return of Number.floatValue()?,the return of Number.floatValue() should be the value of this Short as a float after a widening primitive conversion..,"['return', 'Number.floatValue()']"
Number.doubleValue(),what's the return of Number.doubleValue()?,the return of Number.doubleValue() should be the value of this Short as a double after a widening primitive conversion..,"['return', 'Number.doubleValue()']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
Object.equals(Object obj),what's the return of Object.equals(Object obj)?,"the return of Object.equals(Object obj) should be true if the objects are the same;
          false otherwise..","['return', 'Object.equals(Object obj)']"
Object.equals(Object obj),what's the parameter of Object.equals(Object obj)?,the parameter of Object.equals(Object obj) should be  the object to compare with..,"['parameter', 'Object.equals(Object obj)']"
Math.sin(double a),what's the return of Math.sin(double a)?,"the return of Math.sin(double a) should be the trigonometric sine of an angle. Special cases: If the argument is NaN or an infinity, then the result is NaN. If the argument is zero, then the result is a zero with the same sign as the argument..","['return', 'Math.sin(double a)']"
Math.cos(double a),what's the return of Math.cos(double a)?,"the return of Math.cos(double a) should be the trigonometric cosine of an angle. Special cases: If the argument is NaN or an infinity, then the result is NaN..","['return', 'Math.cos(double a)']"
Math.tan(double a),what's the return of Math.tan(double a)?,"the return of Math.tan(double a) should be the trigonometric tangent of an angle. Special cases: If the argument is NaN or an infinity, then the result is NaN. If the argument is zero, then the result is a zero with the same sign as the argument..","['return', 'Math.tan(double a)']"
Math.asin(double a),what's the return of Math.asin(double a)?,"the return of Math.asin(double a) should be the arc sine of a value; the returned angle is in the range -pi/2 through pi/2. Special cases: If the argument is NaN or its absolute value is greater than 1, then the result is NaN. If the argument is zero, then the result is a zero with the same sign as the argument..","['return', 'Math.asin(double a)']"
Math.acos(double a),what's the return of Math.acos(double a)?,"the return of Math.acos(double a) should be the arc cosine of a value; the returned angle is in the range 0.0 through pi. Special case: If the argument is NaN or its absolute value is greater than 1, then the result is NaN..","['return', 'Math.acos(double a)']"
Math.atan(double a),what's the return of Math.atan(double a)?,"the return of Math.atan(double a) should be the arc tangent of a value; the returned angle is in the range -pi/2 through pi/2. Special cases: If the argument is NaN, then the result is NaN. If the argument is zero, then the result is a zero with the same sign as the argument..","['return', 'Math.atan(double a)']"
Math.toRadians(double angdeg),what's the return of Math.toRadians(double angdeg)?,"the return of Math.toRadians(double angdeg) should be the measurement of the angle angdeg
          in radians..","['return', 'Math.toRadians(double angdeg)']"
Math.toDegrees(double angrad),what's the return of Math.toDegrees(double angrad)?,"the return of Math.toDegrees(double angrad) should be the measurement of the angle angrad
          in degrees..","['return', 'Math.toDegrees(double angrad)']"
Math.exp(double a),what's the return of Math.exp(double a)?,"the return of Math.exp(double a) should be Euler's number e raised to the power of a double value. Special cases: If the argument is NaN, the result is NaN. If the argument is positive infinity, then the result is positive infinity. If the argument is negative infinity, then the result is positive zero..","['return', 'Math.exp(double a)']"
Math.log(double a),what's the return of Math.log(double a)?,"the return of Math.log(double a) should be the natural logarithm (base e) of a double value. Special cases: If the argument is NaN or less than zero, then the result is NaN. If the argument is positive infinity, then the result is positive infinity. If the argument is positive zero or negative zero, then the result is negative infinity..","['return', 'Math.log(double a)']"
Math.a),what's the return of Math.a)?,"the return of Math.a) should be the base 10 logarithm of a double value. Special cases: If the argument is NaN or less than zero, then the result is NaN. If the argument is positive infinity, then the result is positive infinity. If the argument is positive zero or negative zero, then the result is negative infinity. If the argument is equal to 10n for integer n, then the result is n..","['return', 'Math.a)']"
Math.sqrt(double a),what's the return of Math.sqrt(double a)?,"the return of Math.sqrt(double a) should be the correctly rounded positive square root of a double value. Special cases: If the argument is NaN or less than zero, then the result is NaN. If the argument is positive infinity, then the result is positive infinity. If the argument is positive zero or negative zero, then the result is the same as the argument. Otherwise, the result is the double value closest to the true mathematical square root of the argument value..","['return', 'Math.sqrt(double a)']"
Math.cbrt(double a),what's the return of Math.cbrt(double a)?,"the return of Math.cbrt(double a) should be the cube root of a double value. For positive finite x, cbrt(-x) == -cbrt(x); that is, the cube root of a negative value is the negative of the cube root of that value's magnitude. Special cases: If the argument is NaN, then the result is NaN. If the argument is infinite, then the result is an infinity with the same sign as the argument. If the argument is zero, then the result is a zero with the same sign as the argument..","['return', 'Math.cbrt(double a)']"
"Math.IEEEremainder(double f1, double f2)","what's the return of Math.IEEEremainder(double f1, double f2)?","the return of Math.IEEEremainder(double f1, double f2) should be f2 - the divisor..","['return', 'Math.IEEEremainder(double f1, double f2)']"
Math.ceil(double a),what's the return of Math.ceil(double a)?,"the return of Math.ceil(double a) should be the smallest (closest to negative infinity) double value that is greater than or equal to the argument and is equal to a mathematical integer. Special cases: If the argument value is already equal to a mathematical integer, then the result is the same as the argument. If the argument is NaN or an infinity or positive zero or negative zero, then the result is the same as the argument. If the argument value is less than zero but greater than -1.0, then the result is negative zero. Note that the value of Math.ceil(x) is exactly the value of -Math.floor(-x)..","['return', 'Math.ceil(double a)']"
Math.floor(double a),what's the return of Math.floor(double a)?,"the return of Math.floor(double a) should be the largest (closest to positive infinity) double value that is less than or equal to the argument and is equal to a mathematical integer. Special cases: If the argument value is already equal to a mathematical integer, then the result is the same as the argument. If the argument is NaN or an infinity or positive zero or negative zero, then the result is the same as the argument..","['return', 'Math.floor(double a)']"
Math.rint(double a),what's the return of Math.rint(double a)?,"the return of Math.rint(double a) should be the double value that is closest in value to the argument and is equal to a mathematical integer. If two double values that are mathematical integers are equally close, the result is the integer value that is even. Special cases: If the argument value is already equal to a mathematical integer, then the result is the same as the argument. If the argument is NaN or an infinity or positive zero or negative zero, then the result is the same as the argument..","['return', 'Math.rint(double a)']"
Math.x),what's the return of Math.x)?,"the return of Math.x) should be the angle theta from the conversion of rectangular coordinates (x, y) to polar coordinates (r, theta). This method computes the phase theta by computing an arc tangent of y/x in the range of -pi to pi. Special cases: If either argument is NaN, then the result is NaN. If the first argument is positive zero and the second argument is positive, or the first argument is positive and finite and the second argument is positive infinity, then the result is positive zero. If the first argument is negative zero and the second argument is positive, or the first argument is negative and finite and the second argument is positive infinity, then the result is negative zero. If the first argument is positive zero and the second argument is negative, or the first argument is positive and finite and the second argument is negative infinity, then the result is the double value closest to pi. If the first argument is negative zero and the second argument is negative, or the first argument is negative and finite and the second argument is negative infinity, then the result is the double value closest to -pi. If the first argument is positive and the second argument is positive zero or negative zero, or the first argument is positive infinity and the second argument is finite, then the result is the double value closest to pi/2. If the first argument is negative and the second argument is positive zero or negative zero, or the first argument is negative infinity and the second argument is finite, then the result is the double value closest to -pi/2. If both arguments are positive infinity, then the result is the double value closest to pi/4. If the first argument is positive infinity and the second argument is negative infinity, then the result is the double value closest to 3*pi/4. If the first argument is negative infinity and the second argument is positive infinity, then the result is the double value closest to -pi/4. If both arguments are negative infinity, then the result is the double value closest to -3*pi/4..","['return', 'Math.x)']"
"Math.pow(double a, double b)","what's the return of Math.pow(double a, double b)?","the return of Math.pow(double a, double b) should be the value of the first argument raised to the power of the second argument. Special cases: If the second argument is positive or negative zero, then the result is 1.0. If the second argument is 1.0, then the result is the same as the first argument. If the second argument is NaN, then the result is NaN. If the first argument is NaN and the second argument is nonzero, then the result is NaN. If the absolute value of the first argument is greater than 1 and the second argument is positive infinity, or the absolute value of the first argument is less than 1 and the second argument is negative infinity, then the result is positive infinity. If the absolute value of the first argument is greater than 1 and the second argument is negative infinity, or the absolute value of the first argument is less than 1 and the second argument is positive infinity, then the result is positive zero. If the absolute value of the first argument equals 1 and the second argument is infinite, then the result is NaN. If the first argument is positive zero and the second argument is greater than zero, or the first argument is positive infinity and the second argument is less than zero, then the result is positive zero. If the first argument is positive zero and the second argument is less than zero, or the first argument is positive infinity and the second argument is greater than zero, then the result is positive infinity. If the first argument is negative zero and the second argument is greater than zero but not a finite odd integer, or the first argument is negative infinity and the second argument is less than zero but not a finite odd integer, then the result is positive zero. If the first argument is negative zero and the second argument is a positive finite odd integer, or the first argument is negative infinity and the second argument is a negative finite odd integer, then the result is negative zero. If the first argument is negative zero and the second argument is less than zero but not a finite odd integer, or the first argument is negative infinity and the second argument is greater than zero but not a finite odd integer, then the result is positive infinity. If the first argument is negative zero and the second argument is a negative finite odd integer, or the first argument is negative infinity and the second argument is a positive finite odd integer, then the result is negative infinity. If the first argument is finite and less than zero if the second argument is a finite even integer, the result is equal to the result of raising the absolute value of the first argument to the power of the second argument if the second argument is a finite odd integer, the result is equal to the negative of the result of raising the absolute value of the first argument to the power of the second argument if the second argument is finite and not an integer, then the result is NaN. If both arguments are integers, then the result is exactly equal to the mathematical result of raising the first argument to the power of the second argument if that result can in fact be represented exactly as a double value..","['return', 'Math.pow(double a, double b)']"
Math.round(float a),what's the return of Math.round(float a)?,"the return of Math.round(float a) should be the closest int to the argument, with ties rounding to positive infinity. If the argument is NaN, the result is 0. If the argument is negative infinity or any value less than or equal to the value of Integer.MIN_VALUE, the result is equal to the value of Integer.MIN_VALUE. If the argument is positive infinity or any value greater than or equal to the value of Integer.MAX_VALUE, the result is equal to the value of Integer.MAX_VALUE..","['return', 'Math.round(float a)']"
Math.round(double a),what's the return of Math.round(double a)?,"the return of Math.round(double a) should be the closest long to the argument, with ties rounding to positive infinity. If the argument is NaN, the result is 0. If the argument is negative infinity or any value less than or equal to the value of Long.MIN_VALUE, the result is equal to the value of Long.MIN_VALUE. If the argument is positive infinity or any value greater than or equal to the value of Long.MAX_VALUE, the result is equal to the value of Long.MAX_VALUE..","['return', 'Math.round(double a)']"
Math.random(),what's the return of Math.random()?,"the return of Math.random() should be a double value with a positive sign, greater than or equal to 0.0 and less than 1.0. Returned values are chosen pseudorandomly with (approximately) uniform distribution from that range. new java.util.Random() This new pseudorandom-number generator is used thereafter for all calls to this method and is used nowhere else..","['return', 'Math.random()']"
"Math.addExact(int x, int y)","what's the return of Math.addExact(int x, int y)?","the return of Math.addExact(int x, int y) should be the sum of its arguments, throwing an exception if the result overflows an int..","['return', 'Math.addExact(int x, int y)']"
"Math.addExact(long x, long y)","what's the return of Math.addExact(long x, long y)?","the return of Math.addExact(long x, long y) should be the sum of its arguments, throwing an exception if the result overflows a long..","['return', 'Math.addExact(long x, long y)']"
"Math.subtractExact(int x, int y)","what's the return of Math.subtractExact(int x, int y)?","the return of Math.subtractExact(int x, int y) should be the difference of the arguments, throwing an exception if the result overflows an int..","['return', 'Math.subtractExact(int x, int y)']"
"Math.subtractExact(long x, long y)","what's the return of Math.subtractExact(long x, long y)?","the return of Math.subtractExact(long x, long y) should be the difference of the arguments, throwing an exception if the result overflows a long..","['return', 'Math.subtractExact(long x, long y)']"
"Math.multiplyExact(int x, int y)","what's the return of Math.multiplyExact(int x, int y)?","the return of Math.multiplyExact(int x, int y) should be the product of the arguments, throwing an exception if the result overflows an int..","['return', 'Math.multiplyExact(int x, int y)']"
"Math.multiplyExact(long x, long y)","what's the return of Math.multiplyExact(long x, long y)?","the return of Math.multiplyExact(long x, long y) should be the product of the arguments, throwing an exception if the result overflows a long..","['return', 'Math.multiplyExact(long x, long y)']"
Math.incrementExact(int a),what's the return of Math.incrementExact(int a)?,"the return of Math.incrementExact(int a) should be the argument incremented by one, throwing an exception if the result overflows an int..","['return', 'Math.incrementExact(int a)']"
Math.incrementExact(long a),what's the return of Math.incrementExact(long a)?,"the return of Math.incrementExact(long a) should be the argument incremented by one, throwing an exception if the result overflows a long..","['return', 'Math.incrementExact(long a)']"
Math.decrementExact(int a),what's the return of Math.decrementExact(int a)?,"the return of Math.decrementExact(int a) should be the argument decremented by one, throwing an exception if the result overflows an int..","['return', 'Math.decrementExact(int a)']"
Math.decrementExact(long a),what's the return of Math.decrementExact(long a)?,"the return of Math.decrementExact(long a) should be the argument decremented by one, throwing an exception if the result overflows a long..","['return', 'Math.decrementExact(long a)']"
Math.negateExact(int a),what's the return of Math.negateExact(int a)?,"the return of Math.negateExact(int a) should be the negation of the argument, throwing an exception if the result overflows an int..","['return', 'Math.negateExact(int a)']"
Math.negateExact(long a),what's the return of Math.negateExact(long a)?,"the return of Math.negateExact(long a) should be the negation of the argument, throwing an exception if the result overflows a long..","['return', 'Math.negateExact(long a)']"
Math.toIntExact(long value),what's the return of Math.toIntExact(long value)?,the return of Math.toIntExact(long value) should be the value of the long argument; throwing an exception if the value overflows an int..,"['return', 'Math.toIntExact(long value)']"
"Math.floorDiv(int x, int y)","what's the return of Math.floorDiv(int x, int y)?","the return of Math.floorDiv(int x, int y) should be the largest (closest to positive infinity) int value that is less than or equal to the algebraic quotient. There is one special case, if the dividend is the Integer.MIN_VALUE and the divisor is -1, then integer overflow occurs and the result is equal to the Integer.MIN_VALUE. If the signs of the arguments are the same, the results of floorDiv and the / operator are the same. For example, floorDiv(4, 3) == 1 and (4 / 3) == 1. If the signs of the arguments are different, the quotient is negative and floorDiv returns the integer less than or equal to the quotient and the / operator returns the integer closest to zero. For example, floorDiv(-4, 3) == -2, whereas (-4 / 3) == -1..","['return', 'Math.floorDiv(int x, int y)']"
"Math.floorDiv(long x, long y)","what's the return of Math.floorDiv(long x, long y)?","the return of Math.floorDiv(long x, long y) should be the largest (closest to positive infinity) long value that is less than or equal to the algebraic quotient. There is one special case, if the dividend is the Long.MIN_VALUE and the divisor is -1, then integer overflow occurs and the result is equal to the Long.MIN_VALUE..","['return', 'Math.floorDiv(long x, long y)']"
"Math.floorMod(int x, int y)","what's the return of Math.floorMod(int x, int y)?","the return of Math.floorMod(int x, int y) should be the floor modulus of the int arguments. floorDiv(x, y) * y + floorMod(x, y) == x If the signs of the arguments are the same, the results of floorMod and the % operator are the same. floorMod(4, 3) == 1; and (4 % 3) == 1 If the signs of the arguments are different, the results differ from the % operator. floorMod(+4, -3) == -2; and (+4 % -3) == +1 floorMod(-4, +3) == +2; and (-4 % +3) == -1 floorMod(-4, -3) == -1; and (-4 % -3) == -1.","['return', 'Math.floorMod(int x, int y)']"
"Math.floorMod(long x, long y)","what's the return of Math.floorMod(long x, long y)?","the return of Math.floorMod(long x, long y) should be the floor modulus of the long arguments. floorDiv(x, y) * y + floorMod(x, y) == x.","['return', 'Math.floorMod(long x, long y)']"
Math.abs(int a),what's the return of Math.abs(int a)?,"the return of Math.abs(int a) should be the absolute value of an int value. If the argument is not negative, the argument is returned. If the argument is negative, the negation of the argument is returned..","['return', 'Math.abs(int a)']"
Math.abs(long a),what's the return of Math.abs(long a)?,"the return of Math.abs(long a) should be the absolute value of a long value. If the argument is not negative, the argument is returned. If the argument is negative, the negation of the argument is returned..","['return', 'Math.abs(long a)']"
Math.abs(float a),what's the return of Math.abs(float a)?,"the return of Math.abs(float a) should be the absolute value of a float value. If the argument is not negative, the argument is returned. If the argument is negative, the negation of the argument is returned. Special cases: If the argument is positive zero or negative zero, the result is positive zero. If the argument is infinite, the result is positive infinity. If the argument is NaN, the result is NaN. In other words, the result is the same as the value of the expression:.","['return', 'Math.abs(float a)']"
Math.abs(double a),what's the return of Math.abs(double a)?,"the return of Math.abs(double a) should be the absolute value of a double value. If the argument is not negative, the argument is returned. If the argument is negative, the negation of the argument is returned. Special cases: If the argument is positive zero or negative zero, the result is positive zero. If the argument is infinite, the result is positive infinity. If the argument is NaN, the result is NaN. In other words, the result is the same as the value of the expression:.","['return', 'Math.abs(double a)']"
"Math.max(int a, int b)","what's the return of Math.max(int a, int b)?","the return of Math.max(int a, int b) should be the greater of two int values. That is, the result is the argument closer to the value of Integer.MAX_VALUE. If the arguments have the same value, the result is that same value..","['return', 'Math.max(int a, int b)']"
"Math.max(long a, long b)","what's the return of Math.max(long a, long b)?","the return of Math.max(long a, long b) should be the greater of two long values. That is, the result is the argument closer to the value of Long.MAX_VALUE. If the arguments have the same value, the result is that same value..","['return', 'Math.max(long a, long b)']"
"Math.max(float a, float b)","what's the return of Math.max(float a, float b)?","the return of Math.max(float a, float b) should be the greater of two float values. That is, the result is the argument closer to positive infinity. If the arguments have the same value, the result is that same value. If either value is NaN, then the result is NaN. Unlike the numerical comparison operators, this method considers negative zero to be strictly smaller than positive zero. If one argument is positive zero and the other negative zero, the result is positive zero..","['return', 'Math.max(float a, float b)']"
"Math.max(double a, double b)","what's the return of Math.max(double a, double b)?","the return of Math.max(double a, double b) should be the greater of two double values. That is, the result is the argument closer to positive infinity. If the arguments have the same value, the result is that same value. If either value is NaN, then the result is NaN. Unlike the numerical comparison operators, this method considers negative zero to be strictly smaller than positive zero. If one argument is positive zero and the other negative zero, the result is positive zero..","['return', 'Math.max(double a, double b)']"
"Math.min(int a, int b)","what's the return of Math.min(int a, int b)?","the return of Math.min(int a, int b) should be the smaller of two int values. That is, the result the argument closer to the value of Integer.MIN_VALUE. If the arguments have the same value, the result is that same value..","['return', 'Math.min(int a, int b)']"
"Math.min(long a, long b)","what's the return of Math.min(long a, long b)?","the return of Math.min(long a, long b) should be the smaller of two long values. That is, the result is the argument closer to the value of Long.MIN_VALUE. If the arguments have the same value, the result is that same value..","['return', 'Math.min(long a, long b)']"
"Math.min(float a, float b)","what's the return of Math.min(float a, float b)?","the return of Math.min(float a, float b) should be the smaller of two float values. That is, the result is the value closer to negative infinity. If the arguments have the same value, the result is that same value. If either value is NaN, then the result is NaN. Unlike the numerical comparison operators, this method considers negative zero to be strictly smaller than positive zero. If one argument is positive zero and the other is negative zero, the result is negative zero..","['return', 'Math.min(float a, float b)']"
"Math.min(double a, double b)","what's the return of Math.min(double a, double b)?","the return of Math.min(double a, double b) should be the smaller of two double values. That is, the result is the value closer to negative infinity. If the arguments have the same value, the result is that same value. If either value is NaN, then the result is NaN. Unlike the numerical comparison operators, this method considers negative zero to be strictly smaller than positive zero. If one argument is positive zero and the other is negative zero, the result is negative zero..","['return', 'Math.min(double a, double b)']"
Math.ulp(double d),what's the return of Math.ulp(double d)?,"the return of Math.ulp(double d) should be the size of an ulp of the argument. An ulp, unit in the last place, of a double value is the positive distance between this floating-point value and the double value next larger in magnitude. Note that for non-NaN x, ulp(-x) == ulp(x). If the argument is NaN, then the result is NaN. If the argument is positive or negative infinity, then the result is positive infinity. If the argument is positive or negative zero, then the result is Double.MIN_VALUE. If the argument is ±Double.MAX_VALUE, then the result is equal to 2971..","['return', 'Math.ulp(double d)']"
Math.ulp(float f),what's the return of Math.ulp(float f)?,"the return of Math.ulp(float f) should be the size of an ulp of the argument. An ulp, unit in the last place, of a float value is the positive distance between this floating-point value and the float value next larger in magnitude. Note that for non-NaN x, ulp(-x) == ulp(x). If the argument is NaN, then the result is NaN. If the argument is positive or negative infinity, then the result is positive infinity. If the argument is positive or negative zero, then the result is Float.MIN_VALUE. If the argument is ±Float.MAX_VALUE, then the result is equal to 2104..","['return', 'Math.ulp(float f)']"
Math.signum(double d),what's the return of Math.signum(double d)?,"the return of Math.signum(double d) should be the signum function of the argument; zero if the argument is zero, 1.0 if the argument is greater than zero, -1.0 if the argument is less than zero. If the argument is NaN, then the result is NaN. If the argument is positive zero or negative zero, then the result is the same as the argument..","['return', 'Math.signum(double d)']"
Math.signum(float f),what's the return of Math.signum(float f)?,"the return of Math.signum(float f) should be the signum function of the argument; zero if the argument is zero, 1.0f if the argument is greater than zero, -1.0f if the argument is less than zero. If the argument is NaN, then the result is NaN. If the argument is positive zero or negative zero, then the result is the same as the argument..","['return', 'Math.signum(float f)']"
Math.sinh(double x),what's the return of Math.sinh(double x)?,"the return of Math.sinh(double x) should be the hyperbolic sine of a double value. The hyperbolic sine of x is defined to be (ex - e-x)/2 where e is Euler's number. If the argument is NaN, then the result is NaN. If the argument is infinite, then the result is an infinity with the same sign as the argument. If the argument is zero, then the result is a zero with the same sign as the argument..","['return', 'Math.sinh(double x)']"
Math.cosh(double x),what's the return of Math.cosh(double x)?,"the return of Math.cosh(double x) should be the hyperbolic cosine of a double value. The hyperbolic cosine of x is defined to be (ex + e-x)/2 where e is Euler's number. If the argument is NaN, then the result is NaN. If the argument is infinite, then the result is positive infinity. If the argument is zero, then the result is 1.0..","['return', 'Math.cosh(double x)']"
Math.tanh(double x),what's the return of Math.tanh(double x)?,"the return of Math.tanh(double x) should be the hyperbolic tangent of a double value. The hyperbolic tangent of x is defined to be (ex - e-x)/(ex + e-x), in other words, sinh(x)/cosh(x). Note that the absolute value of the exact tanh is always less than 1. If the argument is NaN, then the result is NaN. If the argument is zero, then the result is a zero with the same sign as the argument. If the argument is positive infinity, then the result is +1.0. If the argument is negative infinity, then the result is -1.0..","['return', 'Math.tanh(double x)']"
"Math.hypot(double x, double y)","what's the return of Math.hypot(double x, double y)?","the return of Math.hypot(double x, double y) should be sqrt(x2 +y2) without intermediate overflow or underflow. If either argument is infinite, then the result is positive infinity. If either argument is NaN and neither argument is infinite, then the result is NaN..","['return', 'Math.hypot(double x, double y)']"
Math.x),what's the return of Math.x)?,"the return of Math.x) should be the angle theta from the conversion of rectangular coordinates (x, y) to polar coordinates (r, theta). This method computes the phase theta by computing an arc tangent of y/x in the range of -pi to pi. Special cases: If either argument is NaN, then the result is NaN. If the first argument is positive zero and the second argument is positive, or the first argument is positive and finite and the second argument is positive infinity, then the result is positive zero. If the first argument is negative zero and the second argument is positive, or the first argument is negative and finite and the second argument is positive infinity, then the result is negative zero. If the first argument is positive zero and the second argument is negative, or the first argument is positive and finite and the second argument is negative infinity, then the result is the double value closest to pi. If the first argument is negative zero and the second argument is negative, or the first argument is negative and finite and the second argument is negative infinity, then the result is the double value closest to -pi. If the first argument is positive and the second argument is positive zero or negative zero, or the first argument is positive infinity and the second argument is finite, then the result is the double value closest to pi/2. If the first argument is negative and the second argument is positive zero or negative zero, or the first argument is negative infinity and the second argument is finite, then the result is the double value closest to -pi/2. If both arguments are positive infinity, then the result is the double value closest to pi/4. If the first argument is positive infinity and the second argument is negative infinity, then the result is the double value closest to 3*pi/4. If the first argument is negative infinity and the second argument is positive infinity, then the result is the double value closest to -pi/4. If both arguments are negative infinity, then the result is the double value closest to -3*pi/4..","['return', 'Math.x)']"
Math.log1p(double x),what's the return of Math.log1p(double x)?,"the return of Math.log1p(double x) should be the natural logarithm of the sum of the argument and 1. Note that for small values x, the result of log1p(x) is much closer to the true result of ln(1 + x) than the floating-point evaluation of log(1.0+x). If the argument is NaN or less than -1, then the result is NaN. If the argument is positive infinity, then the result is positive infinity. If the argument is negative one, then the result is negative infinity. If the argument is zero, then the result is a zero with the same sign as the argument..","['return', 'Math.log1p(double x)']"
"Math.copySign(double magnitude, double sign)","what's the return of Math.copySign(double magnitude, double sign)?","the return of Math.copySign(double magnitude, double sign) should be the first floating-point argument with the sign of the second floating-point argument. Note that unlike the StrictMath.copySign method, this method does not require NaN sign arguments to be treated as positive values; implementations are permitted to treat some NaN arguments as positive and other NaN arguments as negative to allow greater performance..","['return', 'Math.copySign(double magnitude, double sign)']"
"Math.copySign(float magnitude, float sign)","what's the return of Math.copySign(float magnitude, float sign)?","the return of Math.copySign(float magnitude, float sign) should be the first floating-point argument with the sign of the second floating-point argument. Note that unlike the StrictMath.copySign method, this method does not require NaN sign arguments to be treated as positive values; implementations are permitted to treat some NaN arguments as positive and other NaN arguments as negative to allow greater performance..","['return', 'Math.copySign(float magnitude, float sign)']"
Math.getExponent(float f),what's the return of Math.getExponent(float f)?,"the return of Math.getExponent(float f) should be the unbiased exponent used in the representation of a float. Special cases: If the argument is NaN or infinite, then the result is Float.MAX_EXPONENT + 1. If the argument is zero or subnormal, then the result is Float.MIN_EXPONENT -1..","['return', 'Math.getExponent(float f)']"
Math.getExponent(double d),what's the return of Math.getExponent(double d)?,"the return of Math.getExponent(double d) should be the unbiased exponent used in the representation of a double. Special cases: If the argument is NaN or infinite, then the result is Double.MAX_EXPONENT + 1. If the argument is zero or subnormal, then the result is Double.MIN_EXPONENT -1..","['return', 'Math.getExponent(double d)']"
"Math.nextAfter(double start, double direction)","what's the return of Math.nextAfter(double start, double direction)?","the return of Math.nextAfter(double start, double direction) should be the floating-point number adjacent to the first argument in the direction of the second argument. If both arguments compare as equal the second argument is returned. If either argument is a NaN, then NaN is returned. If both arguments are signed zeros, direction is returned unchanged (as implied by the requirement of returning the second argument if the arguments compare as equal). If start is ±Double.MIN_VALUE and direction has a value such that the result should have a smaller magnitude, then a zero with the same sign as start is returned. If start is infinite and direction has a value such that the result should have a smaller magnitude, Double.MAX_VALUE with the same sign as start is returned. If start is equal to ± Double.MAX_VALUE and direction has a value such that the result should have a larger magnitude, an infinity with same sign as start is returned..","['return', 'Math.nextAfter(double start, double direction)']"
"Math.nextAfter(float start, double direction)","what's the return of Math.nextAfter(float start, double direction)?","the return of Math.nextAfter(float start, double direction) should be the floating-point number adjacent to the first argument in the direction of the second argument. If both arguments compare as equal a value equivalent to the second argument is returned. If either argument is a NaN, then NaN is returned. If both arguments are signed zeros, a value equivalent to direction is returned. If start is ±Float.MIN_VALUE and direction has a value such that the result should have a smaller magnitude, then a zero with the same sign as start is returned. If start is infinite and direction has a value such that the result should have a smaller magnitude, Float.MAX_VALUE with the same sign as start is returned. If start is equal to ± Float.MAX_VALUE and direction has a value such that the result should have a larger magnitude, an infinity with same sign as start is returned..","['return', 'Math.nextAfter(float start, double direction)']"
Math.nextUp(double d),what's the return of Math.nextUp(double d)?,"the return of Math.nextUp(double d) should be the floating-point value adjacent to d in the direction of positive infinity. This method is semantically equivalent to nextAfter(d, Double.POSITIVE_INFINITY); however, a nextUp implementation may run faster than its equivalent nextAfter call. If the argument is NaN, the result is NaN. If the argument is positive infinity, the result is positive infinity. If the argument is zero, the result is Double.MIN_VALUE.","['return', 'Math.nextUp(double d)']"
Math.nextUp(float f),what's the return of Math.nextUp(float f)?,"the return of Math.nextUp(float f) should be the floating-point value adjacent to f in the direction of positive infinity. This method is semantically equivalent to nextAfter(f, Float.POSITIVE_INFINITY); however, a nextUp implementation may run faster than its equivalent nextAfter call. If the argument is NaN, the result is NaN. If the argument is positive infinity, the result is positive infinity. If the argument is zero, the result is Float.MIN_VALUE.","['return', 'Math.nextUp(float f)']"
Math.nextDown(double d),what's the return of Math.nextDown(double d)?,"the return of Math.nextDown(double d) should be the floating-point value adjacent to d in the direction of negative infinity. This method is semantically equivalent to nextAfter(d, Double.NEGATIVE_INFINITY); however, a nextDown implementation may run faster than its equivalent nextAfter call. If the argument is NaN, the result is NaN. If the argument is negative infinity, the result is negative infinity. If the argument is zero, the result is -Double.MIN_VALUE.","['return', 'Math.nextDown(double d)']"
Math.nextDown(float f),what's the return of Math.nextDown(float f)?,"the return of Math.nextDown(float f) should be the floating-point value adjacent to f in the direction of negative infinity. This method is semantically equivalent to nextAfter(f, Float.NEGATIVE_INFINITY); however, a nextDown implementation may run faster than its equivalent nextAfter call. If the argument is NaN, the result is NaN. If the argument is negative infinity, the result is negative infinity. If the argument is zero, the result is -Float.MIN_VALUE.","['return', 'Math.nextDown(float f)']"
"Math.scalb(double d, int scaleFactor)","what's the return of Math.scalb(double d, int scaleFactor)?","the return of Math.scalb(double d, int scaleFactor) should be d × 2scaleFactor rounded as if performed by a single correctly rounded floating-point multiply to a member of the double value set. See the Java Language Specification for a discussion of floating-point value sets. If the exponent of the result is between Double.MIN_EXPONENT and Double.MAX_EXPONENT, the answer is calculated exactly. If the exponent of the result would be larger than Double.MAX_EXPONENT, an infinity is returned. Note that if the result is subnormal, precision may be lost; that is, when scalb(x, n) is subnormal, scalb(scalb(x, n), -n) may not equal x. When the result is non-NaN, the result has the same sign as d. If the first argument is NaN, NaN is returned. If the first argument is infinite, then an infinity of the same sign is returned. If the first argument is zero, then a zero of the same sign is returned..","['return', 'Math.scalb(double d, int scaleFactor)']"
"Math.scalb(float f, int scaleFactor)","what's the return of Math.scalb(float f, int scaleFactor)?","the return of Math.scalb(float f, int scaleFactor) should be f × 2scaleFactor rounded as if performed by a single correctly rounded floating-point multiply to a member of the float value set. See the Java Language Specification for a discussion of floating-point value sets. If the exponent of the result is between Float.MIN_EXPONENT and Float.MAX_EXPONENT, the answer is calculated exactly. If the exponent of the result would be larger than Float.MAX_EXPONENT, an infinity is returned. Note that if the result is subnormal, precision may be lost; that is, when scalb(x, n) is subnormal, scalb(scalb(x, n), -n) may not equal x. When the result is non-NaN, the result has the same sign as f. If the first argument is NaN, NaN is returned. If the first argument is infinite, then an infinity of the same sign is returned. If the first argument is zero, then a zero of the same sign is returned..","['return', 'Math.scalb(float f, int scaleFactor)']"
Number.intValue(),what's the return of Number.intValue()?,the return of Number.intValue() should be the value of this Short as an int after a widening primitive conversion..,"['return', 'Number.intValue()']"
Number.longValue(),what's the return of Number.longValue()?,the return of Number.longValue() should be the value of this Short as a long after a widening primitive conversion..,"['return', 'Number.longValue()']"
Number.floatValue(),what's the return of Number.floatValue()?,the return of Number.floatValue() should be the value of this Short as a float after a widening primitive conversion..,"['return', 'Number.floatValue()']"
Number.doubleValue(),what's the return of Number.doubleValue()?,the return of Number.doubleValue() should be the value of this Short as a double after a widening primitive conversion..,"['return', 'Number.doubleValue()']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
Object.equals(Object obj),what's the return of Object.equals(Object obj)?,"the return of Object.equals(Object obj) should be true if the objects are the same;
          false otherwise..","['return', 'Object.equals(Object obj)']"
Object.equals(Object obj),what's the parameter of Object.equals(Object obj)?,the parameter of Object.equals(Object obj) should be  the object to compare with..,"['parameter', 'Object.equals(Object obj)']"
Object.clone(),what's the return of Object.clone()?,the return of Object.clone() should be a shallow copy of this AbstractMap instance: the keys and values themselves are not cloned..,"['return', 'Object.clone()']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
Package.getName(),what's the return of Package.getName()?,"the return of Package.getName() should be The fully-qualified name of this package as defined in section 6.5.3 of
          The Java™ Language Specification,
          for example, java.lang.","['return', 'Package.getName()']"
Package.getSpecificationTitle(),what's the return of Package.getSpecificationTitle()?,"the return of Package.getSpecificationTitle() should be the specification title, null is returned if it is not known..","['return', 'Package.getSpecificationTitle()']"
Package.getSpecificationVersion(),what's the return of Package.getSpecificationVersion()?,"the return of Package.getSpecificationVersion() should be the version number of the specification that this package implements. This version string must be a sequence of nonnegative decimal integers separated by "".""'s and may have leading zeros. When version strings are compared the most significant numbers are compared..","['return', 'Package.getSpecificationVersion()']"
Package.getSpecificationVendor(),what's the return of Package.getSpecificationVendor()?,"the return of Package.getSpecificationVendor() should be the specification vendor, null is returned if it is not known..","['return', 'Package.getSpecificationVendor()']"
Package.getImplementationTitle(),what's the return of Package.getImplementationTitle()?,"the return of Package.getImplementationTitle() should be the title of the implementation, null is returned if it is not known..","['return', 'Package.getImplementationTitle()']"
Package.getImplementationVersion(),what's the return of Package.getImplementationVersion()?,"the return of Package.getImplementationVersion() should be the version of the implementation, null is returned if it is not known..","['return', 'Package.getImplementationVersion()']"
Package.getImplementationVendor(),what's the return of Package.getImplementationVendor()?,"the return of Package.getImplementationVendor() should be the name of the organization, vendor or company that provided this implementation..","['return', 'Package.getImplementationVendor()']"
Package.isSealed(),what's the return of Package.isSealed()?,the return of Package.isSealed() should be true if this package is sealed..,"['return', 'Package.isSealed()']"
Package.isSealed(URL url),what's the return of Package.isSealed(URL url)?,the return of Package.isSealed(URL url) should be true if this package is sealed with respect to the specified code source url..,"['return', 'Package.isSealed(URL url)']"
Package.isSealed(URL url),what's the parameter of Package.isSealed(URL url)?,the parameter of Package.isSealed(URL url) should be  the code source url.,"['parameter', 'Package.isSealed(URL url)']"
Package.isCompatibleWith(String desired),what's the return of Package.isCompatibleWith(String desired)?,"the return of Package.isCompatibleWith(String desired) should be true if this package's version number is greater
          than or equal to the desired version number.","['return', 'Package.isCompatibleWith(String desired)']"
Package.isCompatibleWith(String desired),what's the parameter of Package.isCompatibleWith(String desired)?,the parameter of Package.isCompatibleWith(String desired) should be  the version string of the desired version..,"['parameter', 'Package.isCompatibleWith(String desired)']"
Package.getPackage(String name),what's the return of Package.getPackage(String name)?,"the return of Package.getPackage(String name) should be the package of the requested name. It may be null if no package
          information is available from the archive or codebase..","['return', 'Package.getPackage(String name)']"
Package.getPackage(String name),what's the parameter of Package.getPackage(String name)?,"the parameter of Package.getPackage(String name) should be  a package name, for example, java.lang..","['parameter', 'Package.getPackage(String name)']"
Package.getPackages(),what's the return of Package.getPackages()?,"the return of Package.getPackages() should be a new array of packages known to the callers ClassLoader
 instance.  An zero length array is returned if none are known..","['return', 'Package.getPackages()']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
AnnotatedElement.getAnnotation(Class<A> annotationClass),what's the return of AnnotatedElement.getAnnotation(Class<A> annotationClass)?,"the return of AnnotatedElement.getAnnotation(Class<A> annotationClass) should be this element's annotation for the specified annotation type if
     present on this element, else null.","['return', 'AnnotatedElement.getAnnotation(Class<A> annotationClass)']"
AnnotatedElement.isAnnotationPresent(Class<? extends Annotation> annotationClass),what's the return of AnnotatedElement.isAnnotationPresent(Class<? extends Annotation> annotationClass)?,"the return of AnnotatedElement.isAnnotationPresent(Class<? extends Annotation> annotationClass) should be true if an annotation for the specified type is present on this element, else false. This method is designed primarily for convenient access to marker annotations..","['return', 'AnnotatedElement.isAnnotationPresent(Class<? extends Annotation> annotationClass)']"
AnnotatedElement.getAnnotationsByType(Class<A> annotationClass),what's the return of AnnotatedElement.getAnnotationsByType(Class<A> annotationClass)?,"the return of AnnotatedElement.getAnnotationsByType(Class<A> annotationClass) should be all this element's annotations for the specified annotation type if
     associated with this element, else an array of length zero.","['return', 'AnnotatedElement.getAnnotationsByType(Class<A> annotationClass)']"
AnnotatedElement.getAnnotations(),what's the return of AnnotatedElement.getAnnotations()?,the return of AnnotatedElement.getAnnotations() should be annotations present on this element.,"['return', 'AnnotatedElement.getAnnotations()']"
AnnotatedElement.getDeclaredAnnotation(Class<A> annotationClass),what's the return of AnnotatedElement.getDeclaredAnnotation(Class<A> annotationClass)?,"the return of AnnotatedElement.getDeclaredAnnotation(Class<A> annotationClass) should be this element's annotation for the specified annotation type if
     directly present on this element, else null.","['return', 'AnnotatedElement.getDeclaredAnnotation(Class<A> annotationClass)']"
AnnotatedElement.getDeclaredAnnotationsByType(Class<A> annotationClass),what's the return of AnnotatedElement.getDeclaredAnnotationsByType(Class<A> annotationClass)?,"the return of AnnotatedElement.getDeclaredAnnotationsByType(Class<A> annotationClass) should be all this element's annotations for the specified annotation type if
     directly or indirectly present on this element, else an array of length zero.","['return', 'AnnotatedElement.getDeclaredAnnotationsByType(Class<A> annotationClass)']"
AnnotatedElement.getDeclaredAnnotations(),what's the return of AnnotatedElement.getDeclaredAnnotations()?,the return of AnnotatedElement.getDeclaredAnnotations() should be annotations directly present on this element.,"['return', 'AnnotatedElement.getDeclaredAnnotations()']"
ProcessBuilder.Redirect.type(),what's the return of ProcessBuilder.Redirect.type()?,the return of ProcessBuilder.Redirect.type() should be the type of this Redirect..,"['return', 'ProcessBuilder.Redirect.type()']"
ProcessBuilder.Redirect.file(),what's the return of ProcessBuilder.Redirect.file()?,"the return of ProcessBuilder.Redirect.file() should be the File source or destination associated with this redirect, or null if there is no such file..","['return', 'ProcessBuilder.Redirect.file()']"
ProcessBuilder.Redirect.from(File file),what's the return of ProcessBuilder.Redirect.from(File file)?,the return of ProcessBuilder.Redirect.from(File file) should be a redirect to read from the specified file. Redirect.from(file).file() == file && Redirect.from(file).type() == Redirect.Type.READ.,"['return', 'ProcessBuilder.Redirect.from(File file)']"
ProcessBuilder.Redirect.from(File file),what's the parameter of ProcessBuilder.Redirect.from(File file)?,the parameter of ProcessBuilder.Redirect.from(File file) should be  The File for the Redirect..,"['parameter', 'ProcessBuilder.Redirect.from(File file)']"
ProcessBuilder.Redirect.to(File file),what's the return of ProcessBuilder.Redirect.to(File file)?,"the return of ProcessBuilder.Redirect.to(File file) should be a redirect to write to the specified file. If the specified file exists when the subprocess is started, its previous contents will be discarded. Redirect.to(file).file() == file && Redirect.to(file).type() == Redirect.Type.WRITE.","['return', 'ProcessBuilder.Redirect.to(File file)']"
ProcessBuilder.Redirect.to(File file),what's the parameter of ProcessBuilder.Redirect.to(File file)?,the parameter of ProcessBuilder.Redirect.to(File file) should be  The File for the Redirect..,"['parameter', 'ProcessBuilder.Redirect.to(File file)']"
ProcessBuilder.Redirect.appendTo(File file),what's the return of ProcessBuilder.Redirect.appendTo(File file)?,the return of ProcessBuilder.Redirect.appendTo(File file) should be a redirect to append to the specified file. Each write operation first advances the position to the end of the file and then writes the requested data. Whether the advancement of the position and the writing of the data are done in a single atomic operation is system-dependent and therefore unspecified. Redirect.appendTo(file).file() == file && Redirect.appendTo(file).type() == Redirect.Type.APPEND.,"['return', 'ProcessBuilder.Redirect.appendTo(File file)']"
ProcessBuilder.Redirect.appendTo(File file),what's the parameter of ProcessBuilder.Redirect.appendTo(File file)?,the parameter of ProcessBuilder.Redirect.appendTo(File file) should be  The File for the Redirect..,"['parameter', 'ProcessBuilder.Redirect.appendTo(File file)']"
Object.equals(Object obj),what's the return of Object.equals(Object obj)?,"the return of Object.equals(Object obj) should be true if the objects are the same;
          false otherwise..","['return', 'Object.equals(Object obj)']"
Object.equals(Object obj),what's the parameter of Object.equals(Object obj)?,the parameter of Object.equals(Object obj) should be  the object to compare with..,"['parameter', 'Object.equals(Object obj)']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
ProcessBuilder.Redirect.Type.values(),what's the return of ProcessBuilder.Redirect.Type.values()?,"the return of ProcessBuilder.Redirect.Type.values() should be an array containing the constants of this enum type, in the order they are declared. This method may be used to iterate over the constants as follows: for (ProcessBuilder.Redirect.Type c : ProcessBuilder.Redirect.Type.values()) System.out.println(c);.","['return', 'ProcessBuilder.Redirect.Type.values()']"
ProcessBuilder.Redirect.Type.valueOf(String name),what's the return of ProcessBuilder.Redirect.Type.valueOf(String name)?,the return of ProcessBuilder.Redirect.Type.valueOf(String name) should be the enum constant of this type with the specified name. The string must match exactly an identifier used to declare an enum constant in this type. (Extraneous whitespace characters are not permitted.).,"['return', 'ProcessBuilder.Redirect.Type.valueOf(String name)']"
ProcessBuilder.Redirect.Type.valueOf(String name),what's the parameter of ProcessBuilder.Redirect.Type.valueOf(String name)?,the parameter of ProcessBuilder.Redirect.Type.valueOf(String name) should be  the name of the enum constant to be returned..,"['parameter', 'ProcessBuilder.Redirect.Type.valueOf(String name)']"
Readable.read(CharBuffer cb),what's the return of Readable.read(CharBuffer cb)?,"the return of Readable.read(CharBuffer cb) should be The number of char values added to the buffer,
                 or -1 if this source of characters is at its end.","['return', 'Readable.read(CharBuffer cb)']"
Readable.read(CharBuffer cb),what's the parameter of Readable.read(CharBuffer cb)?,the parameter of Readable.read(CharBuffer cb) should be  the buffer to read characters into.,"['parameter', 'Readable.read(CharBuffer cb)']"
Runtime.getRuntime(),what's the return of Runtime.getRuntime()?,the return of Runtime.getRuntime() should be the runtime object associated with the current Java application. Most of the methods of class Runtime are instance methods and must be invoked with respect to the current runtime object..,"['return', 'Runtime.getRuntime()']"
Runtime.addShutdownHook(Thread hook),what's the parameter of Runtime.addShutdownHook(Thread hook)?,the parameter of Runtime.addShutdownHook(Thread hook) should be  An initialized but unstarted Thread object.,"['parameter', 'Runtime.addShutdownHook(Thread hook)']"
Runtime.removeShutdownHook(Thread hook),what's the return of Runtime.removeShutdownHook(Thread hook)?,"the return of Runtime.removeShutdownHook(Thread hook) should be true if the specified hook had previously been
 registered and was successfully de-registered, false
 otherwise..","['return', 'Runtime.removeShutdownHook(Thread hook)']"
Runtime.removeShutdownHook(Thread hook),what's the parameter of Runtime.removeShutdownHook(Thread hook)?,the parameter of Runtime.removeShutdownHook(Thread hook) should be  the hook to remove.,"['parameter', 'Runtime.removeShutdownHook(Thread hook)']"
Runtime.exec(String command),what's the return of Runtime.exec(String command)?,the return of Runtime.exec(String command) should be A new Process object for managing the subprocess.,"['return', 'Runtime.exec(String command)']"
Runtime.exec(String command),what's the parameter of Runtime.exec(String command)?,the parameter of Runtime.exec(String command) should be  a specified system command..,"['parameter', 'Runtime.exec(String command)']"
"Runtime.exec(String command, String[] envp)","what's the return of Runtime.exec(String command, String[] envp)?","the return of Runtime.exec(String command, String[] envp) should be envp - array of strings, each element of which
                    has environment variable settings in the format
                    name=value, or
                    null if the subprocess should inherit
                    the environment of the current process..","['return', 'Runtime.exec(String command, String[] envp)']"
"Runtime.exec(String command, String[] envp)","what's the parameter of Runtime.exec(String command, String[] envp)?","the parameter of Runtime.exec(String command, String[] envp) should be  a specified system command..","['parameter', 'Runtime.exec(String command, String[] envp)']"
"Runtime.exec(String command, String[] envp, File dir)","what's the return of Runtime.exec(String command, String[] envp, File dir)?","the return of Runtime.exec(String command, String[] envp, File dir) should be envp - array of strings, each element of which
                    has environment variable settings in the format
                    name=value, or
                    null if the subprocess should inherit
                    the environment of the current process..","['return', 'Runtime.exec(String command, String[] envp, File dir)']"
"Runtime.exec(String command, String[] envp, File dir)","what's the parameter of Runtime.exec(String command, String[] envp, File dir)?","the parameter of Runtime.exec(String command, String[] envp, File dir) should be  a specified system command..","['parameter', 'Runtime.exec(String command, String[] envp, File dir)']"
"Runtime.exec(String command, String[] envp, File dir)","what's the parameter of Runtime.exec(String command, String[] envp, File dir)?","the parameter of Runtime.exec(String command, String[] envp, File dir) should be  a specified system command..","['parameter', 'Runtime.exec(String command, String[] envp, File dir)']"
Runtime.exec(String[] cmdarray),what's the return of Runtime.exec(String[] cmdarray)?,the return of Runtime.exec(String[] cmdarray) should be A new Process object for managing the subprocess.,"['return', 'Runtime.exec(String[] cmdarray)']"
"Runtime.exec(String[] cmdarray, String[] envp)","what's the return of Runtime.exec(String[] cmdarray, String[] envp)?","the return of Runtime.exec(String[] cmdarray, String[] envp) should be envp - array of strings, each element of which
                    has environment variable settings in the format
                    name=value, or
                    null if the subprocess should inherit
                    the environment of the current process..","['return', 'Runtime.exec(String[] cmdarray, String[] envp)']"
"Runtime.exec(String[] cmdarray, String[] envp, File dir)","what's the return of Runtime.exec(String[] cmdarray, String[] envp, File dir)?","the return of Runtime.exec(String[] cmdarray, String[] envp, File dir) should be envp - array of strings, each element of which
                    has environment variable settings in the format
                    name=value, or
                    null if the subprocess should inherit
                    the environment of the current process..","['return', 'Runtime.exec(String[] cmdarray, String[] envp, File dir)']"
"Runtime.exec(String[] cmdarray, String[] envp, File dir)","what's the parameter of Runtime.exec(String[] cmdarray, String[] envp, File dir)?","the parameter of Runtime.exec(String[] cmdarray, String[] envp, File dir) should be  array containing the command to call and
                    its arguments..","['parameter', 'Runtime.exec(String[] cmdarray, String[] envp, File dir)']"
Runtime.availableProcessors(),what's the return of Runtime.availableProcessors()?,the return of Runtime.availableProcessors() should be the number of processors available to the Java virtual machine..,"['return', 'Runtime.availableProcessors()']"
Runtime.freeMemory(),what's the return of Runtime.freeMemory()?,the return of Runtime.freeMemory() should be the amount of free memory in the Java Virtual Machine. Calling the gc method may result in increasing the value returned by freeMemory..,"['return', 'Runtime.freeMemory()']"
Runtime.totalMemory(),what's the return of Runtime.totalMemory()?,"the return of Runtime.totalMemory() should be the total amount of memory in the Java virtual machine. The value returned by this method may vary over time, depending on the host environment..","['return', 'Runtime.totalMemory()']"
Runtime.maxMemory(),what's the return of Runtime.maxMemory()?,the return of Runtime.maxMemory() should be the maximum amount of memory that the Java virtual machine will attempt to use. If there is no inherent limit then the value Long.MAX_VALUE will be returned..,"['return', 'Runtime.maxMemory()']"
SecurityManager.getInCheck(),what's the return of SecurityManager.getInCheck()?,"the return of SecurityManager.getInCheck() should be the value of the inCheck field. This field
          should contain true if a security check is
          in progress,
          false otherwise..","['return', 'SecurityManager.getInCheck()']"
SecurityManager.getClassContext(),what's the return of SecurityManager.getClassContext()?,the return of SecurityManager.getClassContext() should be the current execution stack as an array of classes..,"['return', 'SecurityManager.getClassContext()']"
SecurityManager.currentClassLoader(),what's the return of SecurityManager.currentClassLoader()?,"the return of SecurityManager.currentClassLoader() should be the class loader of the most recent occurrence on the stack
          of a method from a class defined using a non-system class
          loader..","['return', 'SecurityManager.currentClassLoader()']"
SecurityManager.currentLoadedClass(),what's the return of SecurityManager.currentLoadedClass()?,"the return of SecurityManager.currentLoadedClass() should be the class  of the most recent occurrence on the stack
          of a method from a class defined using a non-system class
          loader..","['return', 'SecurityManager.currentLoadedClass()']"
SecurityManager.classDepth(String name),what's the return of SecurityManager.classDepth(String name)?,"the return of SecurityManager.classDepth(String name) should be the depth on the stack frame of the first occurrence of a
          method from a class with the specified name;
          -1 if such a frame cannot be found..","['return', 'SecurityManager.classDepth(String name)']"
SecurityManager.classDepth(String name),what's the parameter of SecurityManager.classDepth(String name)?,the parameter of SecurityManager.classDepth(String name) should be  the fully qualified name of the class to search for..,"['parameter', 'SecurityManager.classDepth(String name)']"
SecurityManager.classLoaderDepth(),what's the return of SecurityManager.classLoaderDepth()?,"the return of SecurityManager.classLoaderDepth() should be the depth on the stack frame of the most recent occurrence of
          a method from a class defined using a non-system class loader..","['return', 'SecurityManager.classLoaderDepth()']"
SecurityManager.inClass(String name),what's the return of SecurityManager.inClass(String name)?,"the return of SecurityManager.inClass(String name) should be true if a method from a class with the specified
         name is on the execution stack; false otherwise..","['return', 'SecurityManager.inClass(String name)']"
SecurityManager.inClass(String name),what's the parameter of SecurityManager.inClass(String name)?,the parameter of SecurityManager.inClass(String name) should be  the fully qualified name of the class..,"['parameter', 'SecurityManager.inClass(String name)']"
SecurityManager.inClassLoader(),what's the return of SecurityManager.inClassLoader()?,"the return of SecurityManager.inClassLoader() should be true if a call to currentClassLoader
          has a non-null return value..","['return', 'SecurityManager.inClassLoader()']"
SecurityManager.getSecurityContext(),what's the return of SecurityManager.getSecurityContext()?,"the return of SecurityManager.getSecurityContext() should be an implementation-dependent object that encapsulates
          sufficient information about the current execution environment
          to perform some security checks later..","['return', 'SecurityManager.getSecurityContext()']"
SecurityManager.checkPermission(Permission perm),what's the parameter of SecurityManager.checkPermission(Permission perm)?,the parameter of SecurityManager.checkPermission(Permission perm) should be  the requested permission..,"['parameter', 'SecurityManager.checkPermission(Permission perm)']"
"SecurityManager.checkPermission(Permission perm, Object context)","what's the parameter of SecurityManager.checkPermission(Permission perm, Object context)?","the parameter of SecurityManager.checkPermission(Permission perm, Object context) should be  the specified permission.","['parameter', 'SecurityManager.checkPermission(Permission perm, Object context)']"
"SecurityManager.checkPermission(Permission perm, Object context)","what's the parameter of SecurityManager.checkPermission(Permission perm, Object context)?","the parameter of SecurityManager.checkPermission(Permission perm, Object context) should be  the specified permission.","['parameter', 'SecurityManager.checkPermission(Permission perm, Object context)']"
SecurityManager.checkAccess(Thread t),what's the parameter of SecurityManager.checkAccess(Thread t)?,the parameter of SecurityManager.checkAccess(Thread t) should be  the thread to be checked..,"['parameter', 'SecurityManager.checkAccess(Thread t)']"
SecurityManager.checkAccess(ThreadGroup g),what's the parameter of SecurityManager.checkAccess(ThreadGroup g)?,the parameter of SecurityManager.checkAccess(ThreadGroup g) should be  the thread group to be checked..,"['parameter', 'SecurityManager.checkAccess(ThreadGroup g)']"
SecurityManager.checkExec(String cmd),what's the parameter of SecurityManager.checkExec(String cmd)?,the parameter of SecurityManager.checkExec(String cmd) should be  the specified system command..,"['parameter', 'SecurityManager.checkExec(String cmd)']"
SecurityManager.checkLink(String lib),what's the parameter of SecurityManager.checkLink(String lib)?,the parameter of SecurityManager.checkLink(String lib) should be  the name of the library..,"['parameter', 'SecurityManager.checkLink(String lib)']"
SecurityManager.checkRead(FileDescriptor fd),what's the parameter of SecurityManager.checkRead(FileDescriptor fd)?,the parameter of SecurityManager.checkRead(FileDescriptor fd) should be  the system.,"['parameter', 'SecurityManager.checkRead(FileDescriptor fd)']"
SecurityManager.checkRead(String file),what's the parameter of SecurityManager.checkRead(String file)?,the parameter of SecurityManager.checkRead(String file) should be  the system.,"['parameter', 'SecurityManager.checkRead(String file)']"
"SecurityManager.checkRead(String file, Object context)","what's the parameter of SecurityManager.checkRead(String file, Object context)?","the parameter of SecurityManager.checkRead(String file, Object context) should be  the system.","['parameter', 'SecurityManager.checkRead(String file, Object context)']"
"SecurityManager.checkRead(String file, Object context)","what's the parameter of SecurityManager.checkRead(String file, Object context)?","the parameter of SecurityManager.checkRead(String file, Object context) should be  the system.","['parameter', 'SecurityManager.checkRead(String file, Object context)']"
SecurityManager.checkWrite(FileDescriptor fd),what's the parameter of SecurityManager.checkWrite(FileDescriptor fd)?,the parameter of SecurityManager.checkWrite(FileDescriptor fd) should be  the system.,"['parameter', 'SecurityManager.checkWrite(FileDescriptor fd)']"
SecurityManager.checkWrite(String file),what's the parameter of SecurityManager.checkWrite(String file)?,the parameter of SecurityManager.checkWrite(String file) should be  the system.,"['parameter', 'SecurityManager.checkWrite(String file)']"
SecurityManager.checkDelete(String file),what's the parameter of SecurityManager.checkDelete(String file)?,the parameter of SecurityManager.checkDelete(String file) should be  the system.,"['parameter', 'SecurityManager.checkDelete(String file)']"
"SecurityManager.checkConnect(String host, int port)","what's the parameter of SecurityManager.checkConnect(String host, int port)?","the parameter of SecurityManager.checkConnect(String host, int port) should be  the host name port to connect to..","['parameter', 'SecurityManager.checkConnect(String host, int port)']"
"SecurityManager.checkConnect(String host, int port, Object context)","what's the parameter of SecurityManager.checkConnect(String host, int port, Object context)?","the parameter of SecurityManager.checkConnect(String host, int port, Object context) should be  the host name port to connect to..","['parameter', 'SecurityManager.checkConnect(String host, int port, Object context)']"
"SecurityManager.checkConnect(String host, int port, Object context)","what's the parameter of SecurityManager.checkConnect(String host, int port, Object context)?","the parameter of SecurityManager.checkConnect(String host, int port, Object context) should be  the host name port to connect to..","['parameter', 'SecurityManager.checkConnect(String host, int port, Object context)']"
"SecurityManager.checkAccept(String host, int port)","what's the parameter of SecurityManager.checkAccept(String host, int port)?","the parameter of SecurityManager.checkAccept(String host, int port) should be  the host name of the socket connection..","['parameter', 'SecurityManager.checkAccept(String host, int port)']"
SecurityManager.checkMulticast(InetAddress maddr),what's the parameter of SecurityManager.checkMulticast(InetAddress maddr)?,the parameter of SecurityManager.checkMulticast(InetAddress maddr) should be  Internet group address to be used..,"['parameter', 'SecurityManager.checkMulticast(InetAddress maddr)']"
"SecurityManager.checkMulticast(InetAddress maddr, byte ttl)","what's the parameter of SecurityManager.checkMulticast(InetAddress maddr, byte ttl)?","the parameter of SecurityManager.checkMulticast(InetAddress maddr, byte ttl) should be  Internet group address to be used..","['parameter', 'SecurityManager.checkMulticast(InetAddress maddr, byte ttl)']"
SecurityManager.checkPropertyAccess(String key),what's the parameter of SecurityManager.checkPropertyAccess(String key)?,the parameter of SecurityManager.checkPropertyAccess(String key) should be  a system property key..,"['parameter', 'SecurityManager.checkPropertyAccess(String key)']"
SecurityManager.checkTopLevelWindow(Object window),what's the return of SecurityManager.checkTopLevelWindow(Object window)?,"the return of SecurityManager.checkTopLevelWindow(Object window) should be true if the calling thread is trusted to put up
             top-level windows; false otherwise..","['return', 'SecurityManager.checkTopLevelWindow(Object window)']"
SecurityManager.checkTopLevelWindow(Object window),what's the parameter of SecurityManager.checkTopLevelWindow(Object window)?,the parameter of SecurityManager.checkTopLevelWindow(Object window) should be  the new window that is being created..,"['parameter', 'SecurityManager.checkTopLevelWindow(Object window)']"
SecurityManager.checkPackageAccess(String pkg),what's the parameter of SecurityManager.checkPackageAccess(String pkg)?,the parameter of SecurityManager.checkPackageAccess(String pkg) should be  the package name..,"['parameter', 'SecurityManager.checkPackageAccess(String pkg)']"
SecurityManager.checkPackageDefinition(String pkg),what's the parameter of SecurityManager.checkPackageDefinition(String pkg)?,the parameter of SecurityManager.checkPackageDefinition(String pkg) should be  the package name..,"['parameter', 'SecurityManager.checkPackageDefinition(String pkg)']"
SecurityManager.checkSecurityAccess(String target),what's the parameter of SecurityManager.checkSecurityAccess(String target)?,the parameter of SecurityManager.checkSecurityAccess(String target) should be  the target name of the SecurityPermission..,"['parameter', 'SecurityManager.checkSecurityAccess(String target)']"
SecurityManager.getThreadGroup(),what's the return of SecurityManager.getThreadGroup()?,"the return of SecurityManager.getThreadGroup() should be the thread group into which to instantiate any new thread being created at the time this is being called. By default, it returns the thread group of the current thread. This should be overridden by a specific security manager to return the appropriate thread group..","['return', 'SecurityManager.getThreadGroup()']"
Short.toString(short s),what's the return of Short.toString(short s)?,the return of Short.toString(short s) should be a new String object representing the specified short. The radix is assumed to be 10..,"['return', 'Short.toString(short s)']"
"Short.parseShort(String s, int radix)","what's the return of Short.parseShort(String s, int radix)?","the return of Short.parseShort(String s, int radix) should be radix - the radix to be used while parsing s.","['return', 'Short.parseShort(String s, int radix)']"
"Short.parseShort(String s, int radix)","what's the parameter of Short.parseShort(String s, int radix)?","the parameter of Short.parseShort(String s, int radix) should be  the String containing the
                  short representation to be parsed.","['parameter', 'Short.parseShort(String s, int radix)']"
Short.parseShort(String s),what's the return of Short.parseShort(String s)?,"the return of Short.parseShort(String s) should be the short value represented by the
          argument in decimal..","['return', 'Short.parseShort(String s)']"
Short.parseShort(String s),what's the parameter of Short.parseShort(String s)?,"the parameter of Short.parseShort(String s) should be  a String containing the short
          representation to be parsed.","['parameter', 'Short.parseShort(String s)']"
"Short.valueOf(String s, int radix)","what's the return of Short.valueOf(String s, int radix)?","the return of Short.valueOf(String s, int radix) should be a Short object holding the value extracted from the specified String when parsed with the radix given by the second argument. The first argument is interpreted as representing a signed short in the radix specified by the second argument, exactly as if the argument were given to the parseShort(java.lang.String, int) method. The result is a Short object that represents the short value specified by the string. new Short(Short.parseShort(s, radix)).","['return', 'Short.valueOf(String s, int radix)']"
"Short.valueOf(String s, int radix)","what's the parameter of Short.valueOf(String s, int radix)?","the parameter of Short.valueOf(String s, int radix) should be  the string to be parsed.","['parameter', 'Short.valueOf(String s, int radix)']"
Short.valueOf(String s),what's the return of Short.valueOf(String s)?,"the return of Short.valueOf(String s) should be a Short object holding the value given by the specified String. The argument is interpreted as representing a signed decimal short, exactly as if the argument were given to the parseShort(java.lang.String) method. The result is a Short object that represents the short value specified by the string. new Short(Short.parseShort(s)).","['return', 'Short.valueOf(String s)']"
Short.valueOf(String s),what's the parameter of Short.valueOf(String s)?,the parameter of Short.valueOf(String s) should be  the string to be parsed.,"['parameter', 'Short.valueOf(String s)']"
Short.valueOf(short s),what's the return of Short.valueOf(short s)?,"the return of Short.valueOf(short s) should be a Short instance representing the specified short value. If a new Short instance is not required, this method should generally be used in preference to the constructor Short(short), as this method is likely to yield significantly better space and time performance by caching frequently requested values. This method will always cache values in the range -128 to 127, inclusive, and may cache other values outside of this range..","['return', 'Short.valueOf(short s)']"
Number.intValue(),what's the return of Number.intValue()?,the return of Number.intValue() should be the value of this Short as an int after a widening primitive conversion..,"['return', 'Number.intValue()']"
Number.longValue(),what's the return of Number.longValue()?,the return of Number.longValue() should be the value of this Short as a long after a widening primitive conversion..,"['return', 'Number.longValue()']"
Number.floatValue(),what's the return of Number.floatValue()?,the return of Number.floatValue() should be the value of this Short as a float after a widening primitive conversion..,"['return', 'Number.floatValue()']"
Number.doubleValue(),what's the return of Number.doubleValue()?,the return of Number.doubleValue() should be the value of this Short as a double after a widening primitive conversion..,"['return', 'Number.doubleValue()']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
Short.hashCode(short value),what's the return of Short.hashCode(short value)?,the return of Short.hashCode(short value) should be a hash code for a short value; compatible with Short.hashCode()..,"['return', 'Short.hashCode(short value)']"
Object.equals(Object obj),what's the return of Object.equals(Object obj)?,"the return of Object.equals(Object obj) should be true if the objects are the same;
          false otherwise..","['return', 'Object.equals(Object obj)']"
Object.equals(Object obj),what's the parameter of Object.equals(Object obj)?,the parameter of Object.equals(Object obj) should be  the object to compare with..,"['parameter', 'Object.equals(Object obj)']"
Comparable.compareTo(Short anotherShort),what's the return of Comparable.compareTo(Short anotherShort)?,"the return of Comparable.compareTo(Short anotherShort) should be the value 0 if this Short is
          equal to the argument Short; a value less than
          0 if this Short is numerically less
          than the argument Short; and a value greater than
           0 if this Short is numerically
           greater than the argument Short (signed
           comparison)..","['return', 'Comparable.compareTo(Short anotherShort)']"
Comparable.compareTo(Short anotherShort),what's the parameter of Comparable.compareTo(Short anotherShort)?,the parameter of Comparable.compareTo(Short anotherShort) should be  the Short to be compared..,"['parameter', 'Comparable.compareTo(Short anotherShort)']"
"Short.compare(short x, short y)","what's the return of Short.compare(short x, short y)?","the return of Short.compare(short x, short y) should be y - the second short to compare.","['return', 'Short.compare(short x, short y)']"
Short.reverseBytes(short i),what's the return of Short.reverseBytes(short i)?,the return of Short.reverseBytes(short i) should be the value obtained by reversing the order of the bytes in the two's complement representation of the specified short value..,"['return', 'Short.reverseBytes(short i)']"
Short.toUnsignedInt(short x),what's the return of Short.toUnsignedInt(short x)?,"the return of Short.toUnsignedInt(short x) should be the argument converted to int by an unsigned
         conversion.","['return', 'Short.toUnsignedInt(short x)']"
Short.toUnsignedLong(short x),what's the return of Short.toUnsignedLong(short x)?,"the return of Short.toUnsignedLong(short x) should be the argument converted to long by an unsigned
         conversion.","['return', 'Short.toUnsignedLong(short x)']"
StackTraceElement.getFileName(),what's the return of StackTraceElement.getFileName()?,"the return of StackTraceElement.getFileName() should be the name of the source file containing the execution point represented by this stack trace element. Generally, this corresponds to the SourceFile attribute of the relevant class file (as per The Java Virtual Machine Specification, Section 4.7.7). In some systems, the name may refer to some source code unit other than a file, such as an entry in source repository..","['return', 'StackTraceElement.getFileName()']"
StackTraceElement.getLineNumber(),what's the return of StackTraceElement.getLineNumber()?,"the return of StackTraceElement.getLineNumber() should be the line number of the source line containing the execution point represented by this stack trace element. Generally, this is derived from the LineNumberTable attribute of the relevant class file (as per The Java Virtual Machine Specification, Section 4.7.8)..","['return', 'StackTraceElement.getLineNumber()']"
StackTraceElement.getClassName(),what's the return of StackTraceElement.getClassName()?,the return of StackTraceElement.getClassName() should be the fully qualified name of the class containing the execution point represented by this stack trace element..,"['return', 'StackTraceElement.getClassName()']"
StackTraceElement.getMethodName(),what's the return of StackTraceElement.getMethodName()?,"the return of StackTraceElement.getMethodName() should be the name of the method containing the execution point represented by this stack trace element. If the execution point is contained in an instance or class initializer, this method will return the appropriate special method name, <init> or <clinit>, as per Section 3.9 of The Java Virtual Machine Specification..","['return', 'StackTraceElement.getMethodName()']"
StackTraceElement.isNativeMethod(),what's the return of StackTraceElement.isNativeMethod()?,the return of StackTraceElement.isNativeMethod() should be true if the method containing the execution point represented by this stack trace element is a native method..,"['return', 'StackTraceElement.isNativeMethod()']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
Object.equals(Object obj),what's the return of Object.equals(Object obj)?,"the return of Object.equals(Object obj) should be true if the objects are the same;
          false otherwise..","['return', 'Object.equals(Object obj)']"
Object.equals(Object obj),what's the parameter of Object.equals(Object obj)?,the parameter of Object.equals(Object obj) should be  the object to compare with..,"['parameter', 'Object.equals(Object obj)']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
CharSequence.length(),what's the return of CharSequence.length()?,the return of CharSequence.length() should be the length of this string. The length is equal to the number of Unicode code units in the string..,"['return', 'CharSequence.length()']"
String.isEmpty(),what's the return of String.isEmpty()?,"the return of String.isEmpty() should be true if, and only if, length() is 0..","['return', 'String.isEmpty()']"
CharSequence.charAt(int index),what's the return of CharSequence.charAt(int index)?,"the return of CharSequence.charAt(int index) should be the char value at the specified index. An index ranges from 0 to length() - 1. The first char value of the sequence is at index 0, the next at index 1, and so on, as for array indexing..","['return', 'CharSequence.charAt(int index)']"
String.codePointAt(int index),what's the return of String.codePointAt(int index)?,the return of String.codePointAt(int index) should be the character (Unicode code point) at the specified index. The index refers to char values (Unicode code units) and ranges from 0 to length()- 1..,"['return', 'String.codePointAt(int index)']"
String.codePointBefore(int index),what's the return of String.codePointBefore(int index)?,the return of String.codePointBefore(int index) should be the character (Unicode code point) before the specified index. The index refers to char values (Unicode code units) and ranges from 1 to length..,"['return', 'String.codePointBefore(int index)']"
"String.codePointCount(int beginIndex, int endIndex)","what's the return of String.codePointCount(int beginIndex, int endIndex)?","the return of String.codePointCount(int beginIndex, int endIndex) should be the number of Unicode code points in the specified text range of this String. The text range begins at the specified beginIndex and extends to the char at index endIndex - 1. Thus the length (in chars) of the text range is endIndex-beginIndex. Unpaired surrogates within the text range count as one code point each..","['return', 'String.codePointCount(int beginIndex, int endIndex)']"
"String.offsetByCodePoints(int index, int codePointOffset)","what's the return of String.offsetByCodePoints(int index, int codePointOffset)?","the return of String.offsetByCodePoints(int index, int codePointOffset) should be the index within this String that is offset from the given index by codePointOffset code points. Unpaired surrogates within the text range given by index and codePointOffset count as one code point each..","['return', 'String.offsetByCodePoints(int index, int codePointOffset)']"
String.getBytes(String charsetName),what's the return of String.getBytes(String charsetName)?,the return of String.getBytes(String charsetName) should be The resultant byte array.,"['return', 'String.getBytes(String charsetName)']"
String.getBytes(String charsetName),what's the parameter of String.getBytes(String charsetName)?,the parameter of String.getBytes(String charsetName) should be  The name of a supported charset.,"['parameter', 'String.getBytes(String charsetName)']"
String.getBytes(Charset charset),what's the return of String.getBytes(Charset charset)?,the return of String.getBytes(Charset charset) should be The resultant byte array.,"['return', 'String.getBytes(Charset charset)']"
String.getBytes(Charset charset),what's the parameter of String.getBytes(Charset charset)?,"the parameter of String.getBytes(Charset charset) should be  The Charset to be used to encode
         the String.","['parameter', 'String.getBytes(Charset charset)']"
String.getBytes(),what's the return of String.getBytes()?,the return of String.getBytes() should be The resultant byte array.,"['return', 'String.getBytes()']"
Object.equals(Object anObject),what's the return of Object.equals(Object anObject)?,"the return of Object.equals(Object anObject) should be true if the given object represents a String
          equivalent to this string, false otherwise.","['return', 'Object.equals(Object anObject)']"
Object.equals(Object anObject),what's the parameter of Object.equals(Object anObject)?,the parameter of Object.equals(Object anObject) should be  The object to compare this String against.,"['parameter', 'Object.equals(Object anObject)']"
String.contentEquals(StringBuffer sb),what's the return of String.contentEquals(StringBuffer sb)?,"the return of String.contentEquals(StringBuffer sb) should be true if this String represents the same
          sequence of characters as the specified StringBuffer,
          false otherwise.","['return', 'String.contentEquals(StringBuffer sb)']"
String.contentEquals(StringBuffer sb),what's the parameter of String.contentEquals(StringBuffer sb)?,the parameter of String.contentEquals(StringBuffer sb) should be  The StringBuffer to compare this String against.,"['parameter', 'String.contentEquals(StringBuffer sb)']"
String.contentEquals(CharSequence cs),what's the return of String.contentEquals(CharSequence cs)?,"the return of String.contentEquals(CharSequence cs) should be true if this String represents the same
          sequence of char values as the specified sequence, false otherwise.","['return', 'String.contentEquals(CharSequence cs)']"
String.contentEquals(CharSequence cs),what's the parameter of String.contentEquals(CharSequence cs)?,the parameter of String.contentEquals(CharSequence cs) should be  The sequence to compare this String against.,"['parameter', 'String.contentEquals(CharSequence cs)']"
String.equalsIgnoreCase(String anotherString),what's the return of String.equalsIgnoreCase(String anotherString)?,"the return of String.equalsIgnoreCase(String anotherString) should be true if the argument is not null and it
          represents an equivalent String ignoring case; false otherwise.","['return', 'String.equalsIgnoreCase(String anotherString)']"
String.equalsIgnoreCase(String anotherString),what's the parameter of String.equalsIgnoreCase(String anotherString)?,the parameter of String.equalsIgnoreCase(String anotherString) should be  The String to compare this String against.,"['parameter', 'String.equalsIgnoreCase(String anotherString)']"
Comparable.compareTo(String anotherString),what's the return of Comparable.compareTo(String anotherString)?,"the return of Comparable.compareTo(String anotherString) should be the value 0 if the argument string is equal to
          this string; a value less than 0 if this string
          is lexicographically less than the string argument; and a
          value greater than 0 if this string is
          lexicographically greater than the string argument..","['return', 'Comparable.compareTo(String anotherString)']"
Comparable.compareTo(String anotherString),what's the parameter of Comparable.compareTo(String anotherString)?,the parameter of Comparable.compareTo(String anotherString) should be  the String to be compared..,"['parameter', 'Comparable.compareTo(String anotherString)']"
String.compareToIgnoreCase(String str),what's the return of String.compareToIgnoreCase(String str)?,"the return of String.compareToIgnoreCase(String str) should be a negative integer, zero, or a positive integer as the
          specified String is greater than, equal to, or less
          than this String, ignoring case considerations..","['return', 'String.compareToIgnoreCase(String str)']"
String.compareToIgnoreCase(String str),what's the parameter of String.compareToIgnoreCase(String str)?,the parameter of String.compareToIgnoreCase(String str) should be  the String to be compared..,"['parameter', 'String.compareToIgnoreCase(String str)']"
"String.regionMatches(int toffset, String other, int ooffset, int len)","what's the return of String.regionMatches(int toffset, String other, int ooffset, int len)?","the return of String.regionMatches(int toffset, String other, int ooffset, int len) should be other - the string argument..","['return', 'String.regionMatches(int toffset, String other, int ooffset, int len)']"
"String.regionMatches(int toffset, String other, int ooffset, int len)","what's the parameter of String.regionMatches(int toffset, String other, int ooffset, int len)?","the parameter of String.regionMatches(int toffset, String other, int ooffset, int len) should be  the starting offset of the subregion in this string..","['parameter', 'String.regionMatches(int toffset, String other, int ooffset, int len)']"
"String.regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)","what's the return of String.regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)?","the return of String.regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) should be toffset - the starting offset of the subregion in this
                       string..","['return', 'String.regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)']"
"String.regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)","what's the parameter of String.regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)?","the parameter of String.regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) should be  if true, ignore case when comparing
                       characters..","['parameter', 'String.regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)']"
"String.startsWith(String prefix, int toffset)","what's the return of String.startsWith(String prefix, int toffset)?","the return of String.startsWith(String prefix, int toffset) should be toffset - where to begin looking in this string..","['return', 'String.startsWith(String prefix, int toffset)']"
"String.startsWith(String prefix, int toffset)","what's the parameter of String.startsWith(String prefix, int toffset)?","the parameter of String.startsWith(String prefix, int toffset) should be  the prefix..","['parameter', 'String.startsWith(String prefix, int toffset)']"
String.startsWith(String prefix),what's the return of String.startsWith(String prefix)?,"the return of String.startsWith(String prefix) should be true if the character sequence represented by the
          argument is a prefix of the character sequence represented by
          this string; false otherwise.
          Note also that true will be returned if the
          argument is an empty string or is equal to this
          String object as determined by the
          equals(Object) method..","['return', 'String.startsWith(String prefix)']"
String.startsWith(String prefix),what's the parameter of String.startsWith(String prefix)?,the parameter of String.startsWith(String prefix) should be  the prefix..,"['parameter', 'String.startsWith(String prefix)']"
String.endsWith(String suffix),what's the return of String.endsWith(String suffix)?,"the return of String.endsWith(String suffix) should be true if the character sequence represented by the
          argument is a suffix of the character sequence represented by
          this object; false otherwise. Note that the
          result will be true if the argument is the
          empty string or is equal to this String object
          as determined by the equals(Object) method..","['return', 'String.endsWith(String suffix)']"
String.endsWith(String suffix),what's the parameter of String.endsWith(String suffix)?,the parameter of String.endsWith(String suffix) should be  the suffix..,"['parameter', 'String.endsWith(String suffix)']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
String.indexOf(int ch),what's the return of String.indexOf(int ch)?,"the return of String.indexOf(int ch) should be the index within this string of the first occurrence of the specified character. If a character with value ch occurs in the character sequence represented by this String object, then the index (in Unicode code units) of the first such occurrence is returned. For values of ch in the range from 0 to 0xFFFF (inclusive), this is the smallest value k such that: this.charAt(k) == ch is true. For other values of ch, it is the smallest value k such that: this.codePointAt(k) == ch is true. In either case, if no such character occurs in this string, then -1 is returned..","['return', 'String.indexOf(int ch)']"
"String.indexOf(int ch, int fromIndex)","what's the return of String.indexOf(int ch, int fromIndex)?","the return of String.indexOf(int ch, int fromIndex) should be the index within this string of the first occurrence of the specified character, starting the search at the specified index. (this.charAt(k) == ch) && (k >= fromIndex) is true. For other values of ch, it is the smallest value k such that: (this.codePointAt(k) == ch) && (k >= fromIndex) is true. In either case, if no such character occurs in this string at or after position fromIndex, then -1 is returned..","['return', 'String.indexOf(int ch, int fromIndex)']"
String.lastIndexOf(int ch),what's the return of String.lastIndexOf(int ch)?,"the return of String.lastIndexOf(int ch) should be the index within this string of the last occurrence of the specified character. For values of ch in the range from 0 to 0xFFFF (inclusive), the index (in Unicode code units) returned is the largest value k such that: this.charAt(k) == ch is true. For other values of ch, it is the largest value k such that: this.codePointAt(k) == ch is true. In either case, if no such character occurs in this string, then -1 is returned. The String is searched backwards starting at the last character..","['return', 'String.lastIndexOf(int ch)']"
"String.lastIndexOf(int ch, int fromIndex)","what's the return of String.lastIndexOf(int ch, int fromIndex)?","the return of String.lastIndexOf(int ch, int fromIndex) should be the index within this string of the last occurrence of the specified character, searching backward starting at the specified index. For values of ch in the range from 0 to 0xFFFF (inclusive), the index returned is the largest value k such that: (this.charAt(k) == ch) && (k <= fromIndex) is true. For other values of ch, it is the largest value k such that: (this.codePointAt(k) == ch) && (k <= fromIndex) is true. In either case, if no such character occurs in this string at or before position fromIndex, then -1 is returned..","['return', 'String.lastIndexOf(int ch, int fromIndex)']"
String.indexOf(String str),what's the return of String.indexOf(String str)?,"the return of String.indexOf(String str) should be the index within this string of the first occurrence of the specified substring. this.startsWith(str, k) If no such value of k exists, then -1 is returned..","['return', 'String.indexOf(String str)']"
String.indexOf(String str),what's the parameter of String.indexOf(String str)?,the parameter of String.indexOf(String str) should be  the substring to search for..,"['parameter', 'String.indexOf(String str)']"
"String.indexOf(String str, int fromIndex)","what's the return of String.indexOf(String str, int fromIndex)?","the return of String.indexOf(String str, int fromIndex) should be the index within this string of the first occurrence of the specified substring, starting at the specified index. k >= fromIndex && this.startsWith(str, k) If no such value of k exists, then -1 is returned..","['return', 'String.indexOf(String str, int fromIndex)']"
"String.indexOf(String str, int fromIndex)","what's the parameter of String.indexOf(String str, int fromIndex)?","the parameter of String.indexOf(String str, int fromIndex) should be  the substring to search for..","['parameter', 'String.indexOf(String str, int fromIndex)']"
String.lastIndexOf(String str),what's the return of String.lastIndexOf(String str)?,"the return of String.lastIndexOf(String str) should be the index within this string of the last occurrence of the specified substring. The last occurrence of the empty string """" is considered to occur at the index value this.length(). this.startsWith(str, k) If no such value of k exists, then -1 is returned..","['return', 'String.lastIndexOf(String str)']"
String.lastIndexOf(String str),what's the parameter of String.lastIndexOf(String str)?,the parameter of String.lastIndexOf(String str) should be  the substring to search for..,"['parameter', 'String.lastIndexOf(String str)']"
"String.lastIndexOf(String str, int fromIndex)","what's the return of String.lastIndexOf(String str, int fromIndex)?","the return of String.lastIndexOf(String str, int fromIndex) should be the index within this string of the last occurrence of the specified substring, searching backward starting at the specified index. k <= fromIndex && this.startsWith(str, k) If no such value of k exists, then -1 is returned..","['return', 'String.lastIndexOf(String str, int fromIndex)']"
"String.lastIndexOf(String str, int fromIndex)","what's the parameter of String.lastIndexOf(String str, int fromIndex)?","the parameter of String.lastIndexOf(String str, int fromIndex) should be  the substring to search for..","['parameter', 'String.lastIndexOf(String str, int fromIndex)']"
String.substring(int beginIndex),what's the return of String.substring(int beginIndex)?,"the return of String.substring(int beginIndex) should be a string that is a substring of this string. The substring begins with the character at the specified index and extends to the end of this string. ""unhappy"".substring(2) returns ""happy"" ""Harbison"".substring(3) returns ""bison"" ""emptiness"".substring(9) returns """" (an empty string).","['return', 'String.substring(int beginIndex)']"
"String.substring(int beginIndex, int endIndex)","what's the return of String.substring(int beginIndex, int endIndex)?","the return of String.substring(int beginIndex, int endIndex) should be a string that is a substring of this string. The substring begins at the specified beginIndex and extends to the character at index endIndex - 1. Thus the length of the substring is endIndex-beginIndex. ""hamburger"".substring(4, 8) returns ""urge"" ""smiles"".substring(1, 5) returns ""mile"".","['return', 'String.substring(int beginIndex, int endIndex)']"
"CharSequence.subSequence(int beginIndex, int endIndex)","what's the return of CharSequence.subSequence(int beginIndex, int endIndex)?","the return of CharSequence.subSequence(int beginIndex, int endIndex) should be a character sequence that is a subsequence of this sequence. str.subSequence(begin, end) behaves in exactly the same way as the invocation str.substring(begin, end).","['return', 'CharSequence.subSequence(int beginIndex, int endIndex)']"
String.concat(String str),what's the return of String.concat(String str)?,"the return of String.concat(String str) should be a string that represents the concatenation of this object's
          characters followed by the string argument's characters..","['return', 'String.concat(String str)']"
String.concat(String str),what's the parameter of String.concat(String str)?,"the parameter of String.concat(String str) should be  the String that is concatenated to the end
                of this String..","['parameter', 'String.concat(String str)']"
"String.replace(char oldChar, char newChar)","what's the return of String.replace(char oldChar, char newChar)?","the return of String.replace(char oldChar, char newChar) should be a string resulting from replacing all occurrences of oldChar in this string with newChar. ""mesquite in your cellar"".replace('e', 'o') returns ""mosquito in your collar"" ""the war of baronets"".replace('r', 'y') returns ""the way of bayonets"" ""sparring with a purple porpoise"".replace('p', 't') returns ""starring with a turtle tortoise"" ""JonL"".replace('q', 'x') returns ""JonL"" (no change).","['return', 'String.replace(char oldChar, char newChar)']"
String.matches(String regex),what's the return of String.matches(String regex)?,"the return of String.matches(String regex) should be true if, and only if, this string matches the
          given regular expression.","['return', 'String.matches(String regex)']"
String.matches(String regex),what's the parameter of String.matches(String regex)?,the parameter of String.matches(String regex) should be  the regular expression to which this string is to be matched.,"['parameter', 'String.matches(String regex)']"
String.contains(CharSequence s),what's the return of String.contains(CharSequence s)?,the return of String.contains(CharSequence s) should be true if and only if this string contains the specified sequence of char values..,"['return', 'String.contains(CharSequence s)']"
String.contains(CharSequence s),what's the parameter of String.contains(CharSequence s)?,the parameter of String.contains(CharSequence s) should be  the sequence to search for.,"['parameter', 'String.contains(CharSequence s)']"
"String.replaceFirst(String regex, String replacement)","what's the return of String.replaceFirst(String regex, String replacement)?","the return of String.replaceFirst(String regex, String replacement) should be replacement - the string to be substituted for the first match.","['return', 'String.replaceFirst(String regex, String replacement)']"
"String.replaceFirst(String regex, String replacement)","what's the parameter of String.replaceFirst(String regex, String replacement)?","the parameter of String.replaceFirst(String regex, String replacement) should be  the regular expression to which this string is to be matched.","['parameter', 'String.replaceFirst(String regex, String replacement)']"
"String.replaceAll(String regex, String replacement)","what's the return of String.replaceAll(String regex, String replacement)?","the return of String.replaceAll(String regex, String replacement) should be replacement - the string to be substituted for each match.","['return', 'String.replaceAll(String regex, String replacement)']"
"String.replaceAll(String regex, String replacement)","what's the parameter of String.replaceAll(String regex, String replacement)?","the parameter of String.replaceAll(String regex, String replacement) should be  the regular expression to which this string is to be matched.","['parameter', 'String.replaceAll(String regex, String replacement)']"
"String.replace(CharSequence target, CharSequence replacement)","what's the return of String.replace(CharSequence target, CharSequence replacement)?","the return of String.replace(CharSequence target, CharSequence replacement) should be replacement - The replacement sequence of char values.","['return', 'String.replace(CharSequence target, CharSequence replacement)']"
"String.replace(CharSequence target, CharSequence replacement)","what's the parameter of String.replace(CharSequence target, CharSequence replacement)?","the parameter of String.replace(CharSequence target, CharSequence replacement) should be  The sequence of char values to be replaced.","['parameter', 'String.replace(CharSequence target, CharSequence replacement)']"
"String.split(String regex, int limit)","what's the return of String.split(String regex, int limit)?","the return of String.split(String regex, int limit) should be limit - the result threshold, as described above.","['return', 'String.split(String regex, int limit)']"
"String.split(String regex, int limit)","what's the parameter of String.split(String regex, int limit)?","the parameter of String.split(String regex, int limit) should be  the delimiting regular expression.","['parameter', 'String.split(String regex, int limit)']"
String.split(String regex),what's the return of String.split(String regex)?,"the return of String.split(String regex) should be the array of strings computed by splitting this string
          around matches of the given regular expression.","['return', 'String.split(String regex)']"
String.split(String regex),what's the parameter of String.split(String regex)?,the parameter of String.split(String regex) should be  the delimiting regular expression.,"['parameter', 'String.split(String regex)']"
"String.join(CharSequence delimiter, CharSequence... elements)","what's the return of String.join(CharSequence delimiter, CharSequence... elements)?","the return of String.join(CharSequence delimiter, CharSequence... elements) should be a new String composed of copies of the CharSequence elements joined together with a copy of the specified delimiter. For example, String message = String.join(""-"", ""Java"", ""is"", ""cool""); // message returned is: ""Java-is-cool"" Note that if an element is null, then ""null"" is added..","['return', 'String.join(CharSequence delimiter, CharSequence... elements)']"
"String.join(CharSequence delimiter, CharSequence... elements)","what's the parameter of String.join(CharSequence delimiter, CharSequence... elements)?","the parameter of String.join(CharSequence delimiter, CharSequence... elements) should be  the delimiter that separates each element.","['parameter', 'String.join(CharSequence delimiter, CharSequence... elements)']"
"String.join(CharSequence delimiter, Iterable<? extends CharSequence> elements)","what's the return of String.join(CharSequence delimiter, Iterable<? extends CharSequence> elements)?","the return of String.join(CharSequence delimiter, Iterable<? extends CharSequence> elements) should be a new String composed of copies of the CharSequence elements joined together with a copy of the specified delimiter. For example, List<String> strings = new LinkedList<>(); strings.add(""Java"");strings.add(""is""); strings.add(""cool""); String message = String.join("" "", strings); //message returned is: ""Java is cool"" Set<String> strings = new LinkedHashSet<>(); strings.add(""Java""); strings.add(""is""); strings.add(""very""); strings.add(""cool""); String message = String.join(""-"", strings); //message returned is: ""Java-is-very-cool"" Note that if an individual element is null, then ""null"" is added..","['return', 'String.join(CharSequence delimiter, Iterable<? extends CharSequence> elements)']"
"String.join(CharSequence delimiter, Iterable<? extends CharSequence> elements)","what's the parameter of String.join(CharSequence delimiter, Iterable<? extends CharSequence> elements)?","the parameter of String.join(CharSequence delimiter, Iterable<? extends CharSequence> elements) should be  a sequence of characters that is used to separate each
         of the elements in the resulting String.","['parameter', 'String.join(CharSequence delimiter, Iterable<? extends CharSequence> elements)']"
String.toLowerCase(Locale locale),what's the return of String.toLowerCase(Locale locale)?,"the return of String.toLowerCase(Locale locale) should be the String, converted to lowercase..","['return', 'String.toLowerCase(Locale locale)']"
String.toLowerCase(Locale locale),what's the parameter of String.toLowerCase(Locale locale)?,the parameter of String.toLowerCase(Locale locale) should be  use the case transformation rules for this locale.,"['parameter', 'String.toLowerCase(Locale locale)']"
String.toLowerCase(),what's the return of String.toLowerCase()?,"the return of String.toLowerCase() should be the String, converted to lowercase..","['return', 'String.toLowerCase()']"
String.toUpperCase(Locale locale),what's the return of String.toUpperCase(Locale locale)?,"the return of String.toUpperCase(Locale locale) should be the String, converted to uppercase..","['return', 'String.toUpperCase(Locale locale)']"
String.toUpperCase(Locale locale),what's the parameter of String.toUpperCase(Locale locale)?,the parameter of String.toUpperCase(Locale locale) should be  use the case transformation rules for this locale.,"['parameter', 'String.toUpperCase(Locale locale)']"
String.toUpperCase(),what's the return of String.toUpperCase()?,"the return of String.toUpperCase() should be the String, converted to uppercase..","['return', 'String.toUpperCase()']"
String.trim(),what's the return of String.trim()?,"the return of String.trim() should be a string whose value is this string, with any leading and trailing whitespace removed..","['return', 'String.trim()']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
String.toCharArray(),what's the return of String.toCharArray()?,"the return of String.toCharArray() should be a newly allocated character array whose length is the length
          of this string and whose contents are initialized to contain
          the character sequence represented by this string..","['return', 'String.toCharArray()']"
"String.format(String format, Object... args)","what's the return of String.format(String format, Object... args)?","the return of String.format(String format, Object... args) should be a formatted string using the specified format string and arguments..","['return', 'String.format(String format, Object... args)']"
"String.format(String format, Object... args)","what's the parameter of String.format(String format, Object... args)?","the parameter of String.format(String format, Object... args) should be  A format string.","['parameter', 'String.format(String format, Object... args)']"
"String.format(Locale l, String format, Object... args)","what's the return of String.format(Locale l, String format, Object... args)?","the return of String.format(Locale l, String format, Object... args) should be a formatted string using the specified locale, format string, and arguments..","['return', 'String.format(Locale l, String format, Object... args)']"
"String.format(Locale l, String format, Object... args)","what's the parameter of String.format(Locale l, String format, Object... args)?","the parameter of String.format(Locale l, String format, Object... args) should be  The locale to apply during
         formatting.  If l is null then no localization
         is applied..","['parameter', 'String.format(Locale l, String format, Object... args)']"
"String.format(Locale l, String format, Object... args)","what's the parameter of String.format(Locale l, String format, Object... args)?","the parameter of String.format(Locale l, String format, Object... args) should be  The locale to apply during
         formatting.  If l is null then no localization
         is applied..","['parameter', 'String.format(Locale l, String format, Object... args)']"
String.valueOf(Object obj),what's the return of String.valueOf(Object obj)?,the return of String.valueOf(Object obj) should be the string representation of the Object argument..,"['return', 'String.valueOf(Object obj)']"
String.valueOf(Object obj),what's the parameter of String.valueOf(Object obj)?,the parameter of String.valueOf(Object obj) should be  an Object..,"['parameter', 'String.valueOf(Object obj)']"
String.valueOf(char[] data),what's the return of String.valueOf(char[] data)?,the return of String.valueOf(char[] data) should be the string representation of the char array argument. The contents of the character array are copied; subsequent modification of the character array does not affect the returned string..,"['return', 'String.valueOf(char[] data)']"
"String.valueOf(char[] data, int offset, int count)","what's the return of String.valueOf(char[] data, int offset, int count)?","the return of String.valueOf(char[] data, int offset, int count) should be the string representation of a specific subarray of the char array argument..","['return', 'String.valueOf(char[] data, int offset, int count)']"
"String.copyValueOf(char[] data, int offset, int count)","what's the return of String.copyValueOf(char[] data, int offset, int count)?","the return of String.copyValueOf(char[] data, int offset, int count) should be offset - initial offset of the subarray..","['return', 'String.copyValueOf(char[] data, int offset, int count)']"
String.copyValueOf(char[] data),what's the return of String.copyValueOf(char[] data)?,"the return of String.copyValueOf(char[] data) should be a String that contains the characters of the
          character array..","['return', 'String.copyValueOf(char[] data)']"
String.valueOf(boolean b),what's the return of String.valueOf(boolean b)?,the return of String.valueOf(boolean b) should be the string representation of the boolean argument..,"['return', 'String.valueOf(boolean b)']"
String.valueOf(char c),what's the return of String.valueOf(char c)?,the return of String.valueOf(char c) should be the string representation of the char argument..,"['return', 'String.valueOf(char c)']"
String.valueOf(int i),what's the return of String.valueOf(int i)?,the return of String.valueOf(int i) should be the string representation of the int argument..,"['return', 'String.valueOf(int i)']"
String.valueOf(long l),what's the return of String.valueOf(long l)?,the return of String.valueOf(long l) should be the string representation of the long argument..,"['return', 'String.valueOf(long l)']"
String.valueOf(float f),what's the return of String.valueOf(float f)?,the return of String.valueOf(float f) should be the string representation of the float argument..,"['return', 'String.valueOf(float f)']"
String.valueOf(double d),what's the return of String.valueOf(double d)?,the return of String.valueOf(double d) should be the string representation of the double argument..,"['return', 'String.valueOf(double d)']"
String.intern(),what's the return of String.intern()?,the return of String.intern() should be a canonical representation for the string object..,"['return', 'String.intern()']"
CharSequence.length(),what's the return of CharSequence.length()?,the return of CharSequence.length() should be the length of this string. The length is equal to the number of Unicode code units in the string..,"['return', 'CharSequence.length()']"
StringBuffer.capacity(),what's the return of StringBuffer.capacity()?,"the return of StringBuffer.capacity() should be the current capacity. The capacity is the amount of storage available for newly inserted characters, beyond which an allocation will occur..","['return', 'StringBuffer.capacity()']"
CharSequence.charAt(int index),what's the return of CharSequence.charAt(int index)?,"the return of CharSequence.charAt(int index) should be the char value at the specified index. An index ranges from 0 to length() - 1. The first char value of the sequence is at index 0, the next at index 1, and so on, as for array indexing..","['return', 'CharSequence.charAt(int index)']"
StringBuffer.codePointAt(int index),what's the return of StringBuffer.codePointAt(int index)?,the return of StringBuffer.codePointAt(int index) should be the character (Unicode code point) at the specified index. The index refers to char values (Unicode code units) and ranges from 0 to length()- 1..,"['return', 'StringBuffer.codePointAt(int index)']"
StringBuffer.codePointBefore(int index),what's the return of StringBuffer.codePointBefore(int index)?,the return of StringBuffer.codePointBefore(int index) should be the character (Unicode code point) before the specified index. The index refers to char values (Unicode code units) and ranges from 1 to length()..,"['return', 'StringBuffer.codePointBefore(int index)']"
"StringBuffer.codePointCount(int beginIndex, int endIndex)","what's the return of StringBuffer.codePointCount(int beginIndex, int endIndex)?","the return of StringBuffer.codePointCount(int beginIndex, int endIndex) should be the number of Unicode code points in the specified text range of this sequence. The text range begins at the specified beginIndex and extends to the char at index endIndex - 1. Thus the length (in chars) of the text range is endIndex-beginIndex. Unpaired surrogates within this sequence count as one code point each..","['return', 'StringBuffer.codePointCount(int beginIndex, int endIndex)']"
"StringBuffer.offsetByCodePoints(int index, int codePointOffset)","what's the return of StringBuffer.offsetByCodePoints(int index, int codePointOffset)?","the return of StringBuffer.offsetByCodePoints(int index, int codePointOffset) should be the index within this sequence that is offset from the given index by codePointOffset code points. Unpaired surrogates within the text range given by index and codePointOffset count as one code point each..","['return', 'StringBuffer.offsetByCodePoints(int index, int codePointOffset)']"
StringBuffer.append(Object obj),what's the return of StringBuffer.append(Object obj)?,the return of StringBuffer.append(Object obj) should be a reference to this object..,"['return', 'StringBuffer.append(Object obj)']"
StringBuffer.append(Object obj),what's the parameter of StringBuffer.append(Object obj)?,the parameter of StringBuffer.append(Object obj) should be  an Object..,"['parameter', 'StringBuffer.append(Object obj)']"
StringBuffer.append(String str),what's the return of StringBuffer.append(String str)?,the return of StringBuffer.append(String str) should be a reference to this object..,"['return', 'StringBuffer.append(String str)']"
StringBuffer.append(String str),what's the parameter of StringBuffer.append(String str)?,the parameter of StringBuffer.append(String str) should be  a string..,"['parameter', 'StringBuffer.append(String str)']"
StringBuffer.append(StringBuffer sb),what's the return of StringBuffer.append(StringBuffer sb)?,the return of StringBuffer.append(StringBuffer sb) should be a reference to this object..,"['return', 'StringBuffer.append(StringBuffer sb)']"
StringBuffer.append(StringBuffer sb),what's the parameter of StringBuffer.append(StringBuffer sb)?,the parameter of StringBuffer.append(StringBuffer sb) should be  the StringBuffer to append..,"['parameter', 'StringBuffer.append(StringBuffer sb)']"
Appendable.append(CharSequence s),what's the return of Appendable.append(CharSequence s)?,the return of Appendable.append(CharSequence s) should be A reference to this Appendable.,"['return', 'Appendable.append(CharSequence s)']"
Appendable.append(CharSequence s),what's the parameter of Appendable.append(CharSequence s)?,"the parameter of Appendable.append(CharSequence s) should be  The character sequence to append.  If csq is
         null, then the four characters ""null"" are
         appended to this Appendable..","['parameter', 'Appendable.append(CharSequence s)']"
"Appendable.append(CharSequence s, int start, int end)","what's the return of Appendable.append(CharSequence s, int start, int end)?","the return of Appendable.append(CharSequence s, int start, int end) should be start - the starting index of the subsequence to be appended..","['return', 'Appendable.append(CharSequence s, int start, int end)']"
"Appendable.append(CharSequence s, int start, int end)","what's the parameter of Appendable.append(CharSequence s, int start, int end)?","the parameter of Appendable.append(CharSequence s, int start, int end) should be  the sequence to append..","['parameter', 'Appendable.append(CharSequence s, int start, int end)']"
StringBuffer.append(char[] str),what's the return of StringBuffer.append(char[] str)?,the return of StringBuffer.append(char[] str) should be a reference to this object..,"['return', 'StringBuffer.append(char[] str)']"
"StringBuffer.append(char[] str, int offset, int len)","what's the return of StringBuffer.append(char[] str, int offset, int len)?","the return of StringBuffer.append(char[] str, int offset, int len) should be offset - the index of the first char to append..","['return', 'StringBuffer.append(char[] str, int offset, int len)']"
StringBuffer.append(boolean b),what's the return of StringBuffer.append(boolean b)?,the return of StringBuffer.append(boolean b) should be a reference to this object..,"['return', 'StringBuffer.append(boolean b)']"
Appendable.append(char c),what's the return of Appendable.append(char c)?,the return of Appendable.append(char c) should be a reference to this object..,"['return', 'Appendable.append(char c)']"
StringBuffer.append(int i),what's the return of StringBuffer.append(int i)?,the return of StringBuffer.append(int i) should be a reference to this object..,"['return', 'StringBuffer.append(int i)']"
StringBuffer.appendCodePoint(int codePoint),what's the return of StringBuffer.appendCodePoint(int codePoint)?,the return of StringBuffer.appendCodePoint(int codePoint) should be a reference to this object..,"['return', 'StringBuffer.appendCodePoint(int codePoint)']"
StringBuffer.append(long lng),what's the return of StringBuffer.append(long lng)?,the return of StringBuffer.append(long lng) should be a reference to this object..,"['return', 'StringBuffer.append(long lng)']"
StringBuffer.append(float f),what's the return of StringBuffer.append(float f)?,the return of StringBuffer.append(float f) should be a reference to this object..,"['return', 'StringBuffer.append(float f)']"
StringBuffer.append(double d),what's the return of StringBuffer.append(double d)?,the return of StringBuffer.append(double d) should be a reference to this object..,"['return', 'StringBuffer.append(double d)']"
"StringBuffer.delete(int start, int end)","what's the return of StringBuffer.delete(int start, int end)?","the return of StringBuffer.delete(int start, int end) should be end - The ending index, exclusive..","['return', 'StringBuffer.delete(int start, int end)']"
StringBuffer.deleteCharAt(int index),what's the return of StringBuffer.deleteCharAt(int index)?,the return of StringBuffer.deleteCharAt(int index) should be This object..,"['return', 'StringBuffer.deleteCharAt(int index)']"
"StringBuffer.replace(int start, int end, String str)","what's the return of StringBuffer.replace(int start, int end, String str)?","the return of StringBuffer.replace(int start, int end, String str) should be end - The ending index, exclusive..","['return', 'StringBuffer.replace(int start, int end, String str)']"
"StringBuffer.replace(int start, int end, String str)","what's the parameter of StringBuffer.replace(int start, int end, String str)?","the parameter of StringBuffer.replace(int start, int end, String str) should be  The beginning index, inclusive..","['parameter', 'StringBuffer.replace(int start, int end, String str)']"
StringBuffer.substring(int start),what's the return of StringBuffer.substring(int start)?,the return of StringBuffer.substring(int start) should be a new String that contains a subsequence of characters currently contained in this character sequence. The substring begins at the specified index and extends to the end of this sequence..,"['return', 'StringBuffer.substring(int start)']"
"CharSequence.subSequence(int start, int end)","what's the return of CharSequence.subSequence(int start, int end)?","the return of CharSequence.subSequence(int start, int end) should be a new character sequence that is a subsequence of this sequence. sb.subSequence(begin,&nbsp;end) behaves in exactly the same way as the invocation sb.substring(begin,&nbsp;end) This method is provided so that this class can implement the CharSequence interface..","['return', 'CharSequence.subSequence(int start, int end)']"
"StringBuffer.substring(int start, int end)","what's the return of StringBuffer.substring(int start, int end)?","the return of StringBuffer.substring(int start, int end) should be a new String that contains a subsequence of characters currently contained in this sequence. The substring begins at the specified start and extends to the character at index end - 1..","['return', 'StringBuffer.substring(int start, int end)']"
"StringBuffer.insert(int index, char[] str, int offset, int len)","what's the return of StringBuffer.insert(int index, char[] str, int offset, int len)?","the return of StringBuffer.insert(int index, char[] str, int offset, int len) should be str - A char array..","['return', 'StringBuffer.insert(int index, char[] str, int offset, int len)']"
"StringBuffer.insert(int offset, Object obj)","what's the return of StringBuffer.insert(int offset, Object obj)?","the return of StringBuffer.insert(int offset, Object obj) should be obj - an Object..","['return', 'StringBuffer.insert(int offset, Object obj)']"
"StringBuffer.insert(int offset, Object obj)","what's the parameter of StringBuffer.insert(int offset, Object obj)?","the parameter of StringBuffer.insert(int offset, Object obj) should be  the offset..","['parameter', 'StringBuffer.insert(int offset, Object obj)']"
"StringBuffer.insert(int offset, String str)","what's the return of StringBuffer.insert(int offset, String str)?","the return of StringBuffer.insert(int offset, String str) should be str - a string..","['return', 'StringBuffer.insert(int offset, String str)']"
"StringBuffer.insert(int offset, String str)","what's the parameter of StringBuffer.insert(int offset, String str)?","the parameter of StringBuffer.insert(int offset, String str) should be  the offset..","['parameter', 'StringBuffer.insert(int offset, String str)']"
"StringBuffer.insert(int offset, char[] str)","what's the return of StringBuffer.insert(int offset, char[] str)?","the return of StringBuffer.insert(int offset, char[] str) should be str - a character array..","['return', 'StringBuffer.insert(int offset, char[] str)']"
"StringBuffer.insert(int dstOffset, CharSequence s)","what's the return of StringBuffer.insert(int dstOffset, CharSequence s)?","the return of StringBuffer.insert(int dstOffset, CharSequence s) should be s - the sequence to be inserted.","['return', 'StringBuffer.insert(int dstOffset, CharSequence s)']"
"StringBuffer.insert(int dstOffset, CharSequence s)","what's the parameter of StringBuffer.insert(int dstOffset, CharSequence s)?","the parameter of StringBuffer.insert(int dstOffset, CharSequence s) should be  the offset..","['parameter', 'StringBuffer.insert(int dstOffset, CharSequence s)']"
"StringBuffer.insert(int dstOffset, CharSequence s, int start, int end)","what's the return of StringBuffer.insert(int dstOffset, CharSequence s, int start, int end)?","the return of StringBuffer.insert(int dstOffset, CharSequence s, int start, int end) should be s - the sequence to be inserted..","['return', 'StringBuffer.insert(int dstOffset, CharSequence s, int start, int end)']"
"StringBuffer.insert(int dstOffset, CharSequence s, int start, int end)","what's the parameter of StringBuffer.insert(int dstOffset, CharSequence s, int start, int end)?","the parameter of StringBuffer.insert(int dstOffset, CharSequence s, int start, int end) should be  the offset in this sequence..","['parameter', 'StringBuffer.insert(int dstOffset, CharSequence s, int start, int end)']"
"StringBuffer.insert(int offset, boolean b)","what's the return of StringBuffer.insert(int offset, boolean b)?","the return of StringBuffer.insert(int offset, boolean b) should be b - a boolean..","['return', 'StringBuffer.insert(int offset, boolean b)']"
"StringBuffer.insert(int offset, char c)","what's the return of StringBuffer.insert(int offset, char c)?","the return of StringBuffer.insert(int offset, char c) should be c - a char..","['return', 'StringBuffer.insert(int offset, char c)']"
"StringBuffer.insert(int offset, int i)","what's the return of StringBuffer.insert(int offset, int i)?","the return of StringBuffer.insert(int offset, int i) should be i - an int..","['return', 'StringBuffer.insert(int offset, int i)']"
"StringBuffer.insert(int offset, long l)","what's the return of StringBuffer.insert(int offset, long l)?","the return of StringBuffer.insert(int offset, long l) should be l - a long..","['return', 'StringBuffer.insert(int offset, long l)']"
"StringBuffer.insert(int offset, float f)","what's the return of StringBuffer.insert(int offset, float f)?","the return of StringBuffer.insert(int offset, float f) should be f - a float..","['return', 'StringBuffer.insert(int offset, float f)']"
"StringBuffer.insert(int offset, double d)","what's the return of StringBuffer.insert(int offset, double d)?","the return of StringBuffer.insert(int offset, double d) should be d - a double..","['return', 'StringBuffer.insert(int offset, double d)']"
StringBuffer.indexOf(String str),what's the return of StringBuffer.indexOf(String str)?,"the return of StringBuffer.indexOf(String str) should be the index within this string of the first occurrence of the specified substring. The integer returned is the smallest value k such that: this.toString().startsWith(str, <i>k</i>) is true..","['return', 'StringBuffer.indexOf(String str)']"
StringBuffer.indexOf(String str),what's the parameter of StringBuffer.indexOf(String str)?,the parameter of StringBuffer.indexOf(String str) should be  any string..,"['parameter', 'StringBuffer.indexOf(String str)']"
"StringBuffer.indexOf(String str, int fromIndex)","what's the return of StringBuffer.indexOf(String str, int fromIndex)?","the return of StringBuffer.indexOf(String str, int fromIndex) should be the index within this string of the first occurrence of the specified substring, starting at the specified index. The integer returned is the smallest value k for which: k >= Math.min(fromIndex, this.length()) && this.toString().startsWith(str, k) If no such value of k exists, then -1 is returned..","['return', 'StringBuffer.indexOf(String str, int fromIndex)']"
"StringBuffer.indexOf(String str, int fromIndex)","what's the parameter of StringBuffer.indexOf(String str, int fromIndex)?","the parameter of StringBuffer.indexOf(String str, int fromIndex) should be  the substring for which to search..","['parameter', 'StringBuffer.indexOf(String str, int fromIndex)']"
StringBuffer.lastIndexOf(String str),what's the return of StringBuffer.lastIndexOf(String str)?,"the return of StringBuffer.lastIndexOf(String str) should be the index within this string of the rightmost occurrence of the specified substring. The rightmost empty string """" is considered to occur at the index value this.length(). The returned index is the largest value k such that this.toString().startsWith(str, k) is true..","['return', 'StringBuffer.lastIndexOf(String str)']"
StringBuffer.lastIndexOf(String str),what's the parameter of StringBuffer.lastIndexOf(String str)?,the parameter of StringBuffer.lastIndexOf(String str) should be  the substring to search for..,"['parameter', 'StringBuffer.lastIndexOf(String str)']"
"StringBuffer.lastIndexOf(String str, int fromIndex)","what's the return of StringBuffer.lastIndexOf(String str, int fromIndex)?","the return of StringBuffer.lastIndexOf(String str, int fromIndex) should be the index within this string of the last occurrence of the specified substring. The integer returned is the largest value k such that: k <= Math.min(fromIndex, this.length()) && this.toString().startsWith(str, k) If no such value of k exists, then -1 is returned..","['return', 'StringBuffer.lastIndexOf(String str, int fromIndex)']"
"StringBuffer.lastIndexOf(String str, int fromIndex)","what's the parameter of StringBuffer.lastIndexOf(String str, int fromIndex)?","the parameter of StringBuffer.lastIndexOf(String str, int fromIndex) should be  the substring to search for..","['parameter', 'StringBuffer.lastIndexOf(String str, int fromIndex)']"
StringBuffer.reverse(),what's the return of StringBuffer.reverse()?,the return of StringBuffer.reverse() should be a reference to this object..,"['return', 'StringBuffer.reverse()']"
CharSequence.toString(),what's the return of CharSequence.toString()?,the return of CharSequence.toString() should be a string representing the data in this sequence. A new String object is allocated and initialized to contain the character sequence currently represented by this object. This String is then returned. Subsequent changes to this sequence do not affect the contents of the String..,"['return', 'CharSequence.toString()']"
StringBuilder.append(Object obj),what's the return of StringBuilder.append(Object obj)?,the return of StringBuilder.append(Object obj) should be a reference to this object..,"['return', 'StringBuilder.append(Object obj)']"
StringBuilder.append(Object obj),what's the parameter of StringBuilder.append(Object obj)?,the parameter of StringBuilder.append(Object obj) should be  an Object..,"['parameter', 'StringBuilder.append(Object obj)']"
StringBuilder.append(String str),what's the return of StringBuilder.append(String str)?,the return of StringBuilder.append(String str) should be a reference to this object..,"['return', 'StringBuilder.append(String str)']"
StringBuilder.append(String str),what's the parameter of StringBuilder.append(String str)?,the parameter of StringBuilder.append(String str) should be  a string..,"['parameter', 'StringBuilder.append(String str)']"
StringBuilder.append(StringBuffer sb),what's the return of StringBuilder.append(StringBuffer sb)?,the return of StringBuilder.append(StringBuffer sb) should be a reference to this object..,"['return', 'StringBuilder.append(StringBuffer sb)']"
StringBuilder.append(StringBuffer sb),what's the parameter of StringBuilder.append(StringBuffer sb)?,the parameter of StringBuilder.append(StringBuffer sb) should be  the StringBuffer to append..,"['parameter', 'StringBuilder.append(StringBuffer sb)']"
Appendable.append(CharSequence s),what's the return of Appendable.append(CharSequence s)?,the return of Appendable.append(CharSequence s) should be A reference to this Appendable.,"['return', 'Appendable.append(CharSequence s)']"
Appendable.append(CharSequence s),what's the parameter of Appendable.append(CharSequence s)?,"the parameter of Appendable.append(CharSequence s) should be  The character sequence to append.  If csq is
         null, then the four characters ""null"" are
         appended to this Appendable..","['parameter', 'Appendable.append(CharSequence s)']"
"Appendable.append(CharSequence s, int start, int end)","what's the return of Appendable.append(CharSequence s, int start, int end)?","the return of Appendable.append(CharSequence s, int start, int end) should be start - the starting index of the subsequence to be appended..","['return', 'Appendable.append(CharSequence s, int start, int end)']"
"Appendable.append(CharSequence s, int start, int end)","what's the parameter of Appendable.append(CharSequence s, int start, int end)?","the parameter of Appendable.append(CharSequence s, int start, int end) should be  the sequence to append..","['parameter', 'Appendable.append(CharSequence s, int start, int end)']"
StringBuilder.append(char[] str),what's the return of StringBuilder.append(char[] str)?,the return of StringBuilder.append(char[] str) should be a reference to this object..,"['return', 'StringBuilder.append(char[] str)']"
"StringBuilder.append(char[] str, int offset, int len)","what's the return of StringBuilder.append(char[] str, int offset, int len)?","the return of StringBuilder.append(char[] str, int offset, int len) should be offset - the index of the first char to append..","['return', 'StringBuilder.append(char[] str, int offset, int len)']"
StringBuilder.append(boolean b),what's the return of StringBuilder.append(boolean b)?,the return of StringBuilder.append(boolean b) should be a reference to this object..,"['return', 'StringBuilder.append(boolean b)']"
Appendable.append(char c),what's the return of Appendable.append(char c)?,the return of Appendable.append(char c) should be a reference to this object..,"['return', 'Appendable.append(char c)']"
StringBuilder.append(int i),what's the return of StringBuilder.append(int i)?,the return of StringBuilder.append(int i) should be a reference to this object..,"['return', 'StringBuilder.append(int i)']"
StringBuilder.append(long lng),what's the return of StringBuilder.append(long lng)?,the return of StringBuilder.append(long lng) should be a reference to this object..,"['return', 'StringBuilder.append(long lng)']"
StringBuilder.append(float f),what's the return of StringBuilder.append(float f)?,the return of StringBuilder.append(float f) should be a reference to this object..,"['return', 'StringBuilder.append(float f)']"
StringBuilder.append(double d),what's the return of StringBuilder.append(double d)?,the return of StringBuilder.append(double d) should be a reference to this object..,"['return', 'StringBuilder.append(double d)']"
StringBuilder.appendCodePoint(int codePoint),what's the return of StringBuilder.appendCodePoint(int codePoint)?,the return of StringBuilder.appendCodePoint(int codePoint) should be a reference to this object..,"['return', 'StringBuilder.appendCodePoint(int codePoint)']"
"StringBuilder.delete(int start, int end)","what's the return of StringBuilder.delete(int start, int end)?","the return of StringBuilder.delete(int start, int end) should be end - The ending index, exclusive..","['return', 'StringBuilder.delete(int start, int end)']"
StringBuilder.deleteCharAt(int index),what's the return of StringBuilder.deleteCharAt(int index)?,the return of StringBuilder.deleteCharAt(int index) should be This object..,"['return', 'StringBuilder.deleteCharAt(int index)']"
"StringBuilder.replace(int start, int end, String str)","what's the return of StringBuilder.replace(int start, int end, String str)?","the return of StringBuilder.replace(int start, int end, String str) should be end - The ending index, exclusive..","['return', 'StringBuilder.replace(int start, int end, String str)']"
"StringBuilder.replace(int start, int end, String str)","what's the parameter of StringBuilder.replace(int start, int end, String str)?","the parameter of StringBuilder.replace(int start, int end, String str) should be  The beginning index, inclusive..","['parameter', 'StringBuilder.replace(int start, int end, String str)']"
"StringBuilder.insert(int index, char[] str, int offset, int len)","what's the return of StringBuilder.insert(int index, char[] str, int offset, int len)?","the return of StringBuilder.insert(int index, char[] str, int offset, int len) should be str - A char array..","['return', 'StringBuilder.insert(int index, char[] str, int offset, int len)']"
"StringBuilder.insert(int offset, Object obj)","what's the return of StringBuilder.insert(int offset, Object obj)?","the return of StringBuilder.insert(int offset, Object obj) should be obj - an Object..","['return', 'StringBuilder.insert(int offset, Object obj)']"
"StringBuilder.insert(int offset, Object obj)","what's the parameter of StringBuilder.insert(int offset, Object obj)?","the parameter of StringBuilder.insert(int offset, Object obj) should be  the offset..","['parameter', 'StringBuilder.insert(int offset, Object obj)']"
"StringBuilder.insert(int offset, String str)","what's the return of StringBuilder.insert(int offset, String str)?","the return of StringBuilder.insert(int offset, String str) should be str - a string..","['return', 'StringBuilder.insert(int offset, String str)']"
"StringBuilder.insert(int offset, String str)","what's the parameter of StringBuilder.insert(int offset, String str)?","the parameter of StringBuilder.insert(int offset, String str) should be  the offset..","['parameter', 'StringBuilder.insert(int offset, String str)']"
"StringBuilder.insert(int offset, char[] str)","what's the return of StringBuilder.insert(int offset, char[] str)?","the return of StringBuilder.insert(int offset, char[] str) should be str - a character array..","['return', 'StringBuilder.insert(int offset, char[] str)']"
"StringBuilder.insert(int dstOffset, CharSequence s)","what's the return of StringBuilder.insert(int dstOffset, CharSequence s)?","the return of StringBuilder.insert(int dstOffset, CharSequence s) should be s - the sequence to be inserted.","['return', 'StringBuilder.insert(int dstOffset, CharSequence s)']"
"StringBuilder.insert(int dstOffset, CharSequence s)","what's the parameter of StringBuilder.insert(int dstOffset, CharSequence s)?","the parameter of StringBuilder.insert(int dstOffset, CharSequence s) should be  the offset..","['parameter', 'StringBuilder.insert(int dstOffset, CharSequence s)']"
"StringBuilder.insert(int dstOffset, CharSequence s, int start, int end)","what's the return of StringBuilder.insert(int dstOffset, CharSequence s, int start, int end)?","the return of StringBuilder.insert(int dstOffset, CharSequence s, int start, int end) should be s - the sequence to be inserted..","['return', 'StringBuilder.insert(int dstOffset, CharSequence s, int start, int end)']"
"StringBuilder.insert(int dstOffset, CharSequence s, int start, int end)","what's the parameter of StringBuilder.insert(int dstOffset, CharSequence s, int start, int end)?","the parameter of StringBuilder.insert(int dstOffset, CharSequence s, int start, int end) should be  the offset in this sequence..","['parameter', 'StringBuilder.insert(int dstOffset, CharSequence s, int start, int end)']"
"StringBuilder.insert(int offset, boolean b)","what's the return of StringBuilder.insert(int offset, boolean b)?","the return of StringBuilder.insert(int offset, boolean b) should be b - a boolean..","['return', 'StringBuilder.insert(int offset, boolean b)']"
"StringBuilder.insert(int offset, char c)","what's the return of StringBuilder.insert(int offset, char c)?","the return of StringBuilder.insert(int offset, char c) should be c - a char..","['return', 'StringBuilder.insert(int offset, char c)']"
"StringBuilder.insert(int offset, int i)","what's the return of StringBuilder.insert(int offset, int i)?","the return of StringBuilder.insert(int offset, int i) should be i - an int..","['return', 'StringBuilder.insert(int offset, int i)']"
"StringBuilder.insert(int offset, long l)","what's the return of StringBuilder.insert(int offset, long l)?","the return of StringBuilder.insert(int offset, long l) should be l - a long..","['return', 'StringBuilder.insert(int offset, long l)']"
"StringBuilder.insert(int offset, float f)","what's the return of StringBuilder.insert(int offset, float f)?","the return of StringBuilder.insert(int offset, float f) should be f - a float..","['return', 'StringBuilder.insert(int offset, float f)']"
"StringBuilder.insert(int offset, double d)","what's the return of StringBuilder.insert(int offset, double d)?","the return of StringBuilder.insert(int offset, double d) should be d - a double..","['return', 'StringBuilder.insert(int offset, double d)']"
StringBuilder.indexOf(String str),what's the return of StringBuilder.indexOf(String str)?,"the return of StringBuilder.indexOf(String str) should be the index within this string of the first occurrence of the specified substring. The integer returned is the smallest value k such that: this.toString().startsWith(str, <i>k</i>) is true..","['return', 'StringBuilder.indexOf(String str)']"
StringBuilder.indexOf(String str),what's the parameter of StringBuilder.indexOf(String str)?,the parameter of StringBuilder.indexOf(String str) should be  any string..,"['parameter', 'StringBuilder.indexOf(String str)']"
"StringBuilder.indexOf(String str, int fromIndex)","what's the return of StringBuilder.indexOf(String str, int fromIndex)?","the return of StringBuilder.indexOf(String str, int fromIndex) should be the index within this string of the first occurrence of the specified substring, starting at the specified index. The integer returned is the smallest value k for which: k >= Math.min(fromIndex, this.length()) && this.toString().startsWith(str, k) If no such value of k exists, then -1 is returned..","['return', 'StringBuilder.indexOf(String str, int fromIndex)']"
"StringBuilder.indexOf(String str, int fromIndex)","what's the parameter of StringBuilder.indexOf(String str, int fromIndex)?","the parameter of StringBuilder.indexOf(String str, int fromIndex) should be  the substring for which to search..","['parameter', 'StringBuilder.indexOf(String str, int fromIndex)']"
StringBuilder.lastIndexOf(String str),what's the return of StringBuilder.lastIndexOf(String str)?,"the return of StringBuilder.lastIndexOf(String str) should be the index within this string of the rightmost occurrence of the specified substring. The rightmost empty string """" is considered to occur at the index value this.length(). The returned index is the largest value k such that this.toString().startsWith(str, k) is true..","['return', 'StringBuilder.lastIndexOf(String str)']"
StringBuilder.lastIndexOf(String str),what's the parameter of StringBuilder.lastIndexOf(String str)?,the parameter of StringBuilder.lastIndexOf(String str) should be  the substring to search for..,"['parameter', 'StringBuilder.lastIndexOf(String str)']"
"StringBuilder.lastIndexOf(String str, int fromIndex)","what's the return of StringBuilder.lastIndexOf(String str, int fromIndex)?","the return of StringBuilder.lastIndexOf(String str, int fromIndex) should be the index within this string of the last occurrence of the specified substring. The integer returned is the largest value k such that: k <= Math.min(fromIndex, this.length()) && this.toString().startsWith(str, k) If no such value of k exists, then -1 is returned..","['return', 'StringBuilder.lastIndexOf(String str, int fromIndex)']"
"StringBuilder.lastIndexOf(String str, int fromIndex)","what's the parameter of StringBuilder.lastIndexOf(String str, int fromIndex)?","the parameter of StringBuilder.lastIndexOf(String str, int fromIndex) should be  the substring to search for..","['parameter', 'StringBuilder.lastIndexOf(String str, int fromIndex)']"
StringBuilder.reverse(),what's the return of StringBuilder.reverse()?,the return of StringBuilder.reverse() should be a reference to this object..,"['return', 'StringBuilder.reverse()']"
CharSequence.toString(),what's the return of CharSequence.toString()?,the return of CharSequence.toString() should be a string representing the data in this sequence. A new String object is allocated and initialized to contain the character sequence currently represented by this object. This String is then returned. Subsequent changes to this sequence do not affect the contents of the String..,"['return', 'CharSequence.toString()']"
CharSequence.length(),what's the return of CharSequence.length()?,the return of CharSequence.length() should be the length of this string. The length is equal to the number of Unicode code units in the string..,"['return', 'CharSequence.length()']"
StringBuilder.capacity(),what's the return of StringBuilder.capacity()?,"the return of StringBuilder.capacity() should be the current capacity. The capacity is the amount of storage available for newly inserted characters, beyond which an allocation will occur..","['return', 'StringBuilder.capacity()']"
System.setIn(InputStream in),what's the parameter of System.setIn(InputStream in)?,the parameter of System.setIn(InputStream in) should be  the new standard input stream..,"['parameter', 'System.setIn(InputStream in)']"
System.setOut(PrintStream out),what's the parameter of System.setOut(PrintStream out)?,the parameter of System.setOut(PrintStream out) should be  the new standard output stream.,"['parameter', 'System.setOut(PrintStream out)']"
System.setErr(PrintStream err),what's the parameter of System.setErr(PrintStream err)?,the parameter of System.setErr(PrintStream err) should be  the new standard error output stream..,"['parameter', 'System.setErr(PrintStream err)']"
System.console(),what's the return of System.console()?,"the return of System.console() should be the unique Console object associated with the current Java virtual machine, if any..","['return', 'System.console()']"
System.inheritedChannel(),what's the return of System.inheritedChannel()?,the return of System.inheritedChannel() should be the channel inherited from the entity that created this Java virtual machine..,"['return', 'System.inheritedChannel()']"
System.setSecurityManager(SecurityManager s),what's the parameter of System.setSecurityManager(SecurityManager s)?,the parameter of System.setSecurityManager(SecurityManager s) should be  the security manager..,"['parameter', 'System.setSecurityManager(SecurityManager s)']"
System.getSecurityManager(),what's the return of System.getSecurityManager()?,"the return of System.getSecurityManager() should be if a security manager has already been established for the
          current application, then that security manager is returned;
          otherwise, null is returned..","['return', 'System.getSecurityManager()']"
System.currentTimeMillis(),what's the return of System.currentTimeMillis()?,"the return of System.currentTimeMillis() should be the current time in milliseconds. Note that while the unit of time of the return value is a millisecond, the granularity of the value depends on the underlying operating system and may be larger. For example, many operating systems measure time in units of tens of milliseconds..","['return', 'System.currentTimeMillis()']"
System.nanoTime(),what's the return of System.nanoTime()?,"the return of System.nanoTime() should be the current value of the running Java Virtual Machine's high-resolution time source, in nanoseconds. long startTime = System.nanoTime(); // ... the code being measured ... long estimatedTime = System.nanoTime() - startTime; long t0 = System.nanoTime(); ... long t1 = System.nanoTime(); one should use t1 - t0 < 0, not t1 < t0, because of the possibility of numerical overflow..","['return', 'System.nanoTime()']"
"System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)","what's the parameter of System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)?","the parameter of System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length) should be  the source array..","['parameter', 'System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)']"
System.identityHashCode(Object x),what's the return of System.identityHashCode(Object x)?,"the return of System.identityHashCode(Object x) should be the same hash code for the given object as would be returned by the default method hashCode(), whether or not the given object's class overrides hashCode(). The hash code for the null reference is zero..","['return', 'System.identityHashCode(Object x)']"
System.identityHashCode(Object x),what's the parameter of System.identityHashCode(Object x)?,the parameter of System.identityHashCode(Object x) should be  object for which the hashCode is to be calculated.,"['parameter', 'System.identityHashCode(Object x)']"
System.getProperties(),what's the return of System.getProperties()?,the return of System.getProperties() should be the system properties.,"['return', 'System.getProperties()']"
System.lineSeparator(),what's the return of System.lineSeparator()?,the return of System.lineSeparator() should be the system-dependent line separator string. It always returns the same value - the initial value of the system property line.separator..,"['return', 'System.lineSeparator()']"
System.setProperties(Properties props),what's the parameter of System.setProperties(Properties props)?,the parameter of System.setProperties(Properties props) should be  the new system properties..,"['parameter', 'System.setProperties(Properties props)']"
System.getProperty(String key),what's the return of System.getProperty(String key)?,"the return of System.getProperty(String key) should be the string value of the system property,
             or null if there is no property with that key..","['return', 'System.getProperty(String key)']"
System.getProperty(String key),what's the parameter of System.getProperty(String key)?,the parameter of System.getProperty(String key) should be  the name of the system property..,"['parameter', 'System.getProperty(String key)']"
"System.getProperty(String key, String def)","what's the return of System.getProperty(String key, String def)?","the return of System.getProperty(String key, String def) should be def - a default value..","['return', 'System.getProperty(String key, String def)']"
"System.getProperty(String key, String def)","what's the parameter of System.getProperty(String key, String def)?","the parameter of System.getProperty(String key, String def) should be  the name of the system property..","['parameter', 'System.getProperty(String key, String def)']"
"System.setProperty(String key, String value)","what's the return of System.setProperty(String key, String value)?","the return of System.setProperty(String key, String value) should be value - the value of the system property..","['return', 'System.setProperty(String key, String value)']"
"System.setProperty(String key, String value)","what's the parameter of System.setProperty(String key, String value)?","the parameter of System.setProperty(String key, String value) should be  the name of the system property..","['parameter', 'System.setProperty(String key, String value)']"
System.clearProperty(String key),what's the return of System.clearProperty(String key)?,"the return of System.clearProperty(String key) should be the previous string value of the system property,
             or null if there was no property with that key..","['return', 'System.clearProperty(String key)']"
System.clearProperty(String key),what's the parameter of System.clearProperty(String key)?,the parameter of System.clearProperty(String key) should be  the name of the system property to be removed..,"['parameter', 'System.clearProperty(String key)']"
System.getenv(String name),what's the return of System.getenv(String name)?,"the return of System.getenv(String name) should be the string value of the variable, or null
         if the variable is not defined in the system environment.","['return', 'System.getenv(String name)']"
System.getenv(String name),what's the parameter of System.getenv(String name)?,the parameter of System.getenv(String name) should be  the name of the environment variable.,"['parameter', 'System.getenv(String name)']"
System.getenv(),what's the return of System.getenv()?,the return of System.getenv() should be an unmodifiable string map view of the current system environment. The environment is a system-dependent mapping from names to values which is passed from parent to child processes..,"['return', 'System.getenv()']"
System.load(String filename),what's the parameter of System.load(String filename)?,the parameter of System.load(String filename) should be  the file to load..,"['parameter', 'System.load(String filename)']"
System.loadLibrary(String libname),what's the parameter of System.loadLibrary(String libname)?,the parameter of System.loadLibrary(String libname) should be  the name of the library..,"['parameter', 'System.loadLibrary(String libname)']"
System.mapLibraryName(String libname),what's the return of System.mapLibraryName(String libname)?,the return of System.mapLibraryName(String libname) should be a platform-dependent native library name..,"['return', 'System.mapLibraryName(String libname)']"
System.mapLibraryName(String libname),what's the parameter of System.mapLibraryName(String libname)?,the parameter of System.mapLibraryName(String libname) should be  the name of the library..,"['parameter', 'System.mapLibraryName(String libname)']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
ThreadLocal.initialValue(),what's the return of ThreadLocal.initialValue()?,"the return of ThreadLocal.initialValue() should be the current thread's ""initial value"" for this thread-local variable. This method will be invoked the first time a thread accesses the variable with the get() method, unless the thread previously invoked the set(T) method, in which case the initialValue method will not be invoked for the thread. Normally, this method is invoked at most once per thread, but it may be invoked again in case of subsequent invocations of remove() followed by get()..","['return', 'ThreadLocal.initialValue()']"
ThreadLocal.withInitial(Supplier<? extends S> supplier),what's the return of ThreadLocal.withInitial(Supplier<? extends S> supplier)?,the return of ThreadLocal.withInitial(Supplier<? extends S> supplier) should be a new thread local variable.,"['return', 'ThreadLocal.withInitial(Supplier<? extends S> supplier)']"
ThreadLocal.get(),what's the return of ThreadLocal.get()?,"the return of ThreadLocal.get() should be the value in the current thread's copy of this thread-local variable. If the variable has no value for the current thread, it is first initialized to the value returned by an invocation of the initialValue() method..","['return', 'ThreadLocal.get()']"
ThreadLocal.set(T value),what's the parameter of ThreadLocal.set(T value)?,"the parameter of ThreadLocal.set(T value) should be  the value to be stored in the current thread's copy of
        this thread.","['parameter', 'ThreadLocal.set(T value)']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
Iterable.iterator(),what's the return of Iterable.iterator()?,the return of Iterable.iterator() should be an iterator over the elements in this list in proper sequence..,"['return', 'Iterable.iterator()']"
Collection.size(),what's the return of Collection.size()?,the return of Collection.size() should be the number of elements in this deque..,"['return', 'Collection.size()']"
Collection.isEmpty(),what's the return of Collection.isEmpty()?,the return of Collection.isEmpty() should be true if this set contains no elements..,"['return', 'Collection.isEmpty()']"
Collection.contains(Object o),what's the return of Collection.contains(Object o)?,"the return of Collection.contains(Object o) should be true if this deque contains the specified element. More formally, returns true if and only if this deque contains at least one element e such that (o==null ? e==null : o.equals(e))..","['return', 'Collection.contains(Object o)']"
Collection.contains(Object o),what's the parameter of Collection.contains(Object o)?,the parameter of Collection.contains(Object o) should be  element whose presence in this deque is to be tested.,"['parameter', 'Collection.contains(Object o)']"
Collection.toArray(),what's the return of Collection.toArray()?,"the return of Collection.toArray() should be an array containing all of the elements in this set. If this set makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order..","['return', 'Collection.toArray()']"
Collection.toArray(T[] a),what's the return of Collection.toArray(T[] a)?,"the return of Collection.toArray(T[] a) should be an array containing all of the elements in this set; the runtime type of the returned array is that of the specified array. If the set fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this set. String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray()..","['return', 'Collection.toArray(T[] a)']"
Collection.add(E e),what's the return of Collection.add(E e)?,the return of Collection.add(E e) should be true (as specified by Collection.add(E)).,"['return', 'Collection.add(E e)']"
Collection.add(E e),what's the parameter of Collection.add(E e)?,the parameter of Collection.add(E e) should be  the element to add.,"['parameter', 'Collection.add(E e)']"
Collection.remove(Object o),what's the return of Collection.remove(Object o)?,the return of Collection.remove(Object o) should be true if an element was removed as a result of this call.,"['return', 'Collection.remove(Object o)']"
Collection.remove(Object o),what's the parameter of Collection.remove(Object o)?,"the parameter of Collection.remove(Object o) should be  element to be removed from this deque, if present.","['parameter', 'Collection.remove(Object o)']"
Collection.containsAll(Collection<?> c),what's the return of Collection.containsAll(Collection<?> c)?,"the return of Collection.containsAll(Collection<?> c) should be true if this set contains all of the elements of the specified collection. If the specified collection is also a set, this method returns true if it is a subset of this set..","['return', 'Collection.containsAll(Collection<?> c)']"
Collection.addAll(Collection<? extends E> c),what's the return of Collection.addAll(Collection<? extends E> c)?,the return of Collection.addAll(Collection<? extends E> c) should be true if this set changed as a result of the call.,"['return', 'Collection.addAll(Collection<? extends E> c)']"
Collection.removeAll(Collection<?> c),what's the return of Collection.removeAll(Collection<?> c)?,the return of Collection.removeAll(Collection<?> c) should be true if this set changed as a result of the call.,"['return', 'Collection.removeAll(Collection<?> c)']"
Collection.retainAll(Collection<?> c),what's the return of Collection.retainAll(Collection<?> c)?,the return of Collection.retainAll(Collection<?> c) should be true if this set changed as a result of the call.,"['return', 'Collection.retainAll(Collection<?> c)']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
List.get(int index),what's the return of List.get(int index)?,the return of List.get(int index) should be the element at the specified position in this Vector..,"['return', 'List.get(int index)']"
"List.set(int index, E element)","what's the return of List.set(int index, E element)?","the return of List.set(int index, E element) should be element - element to be stored at the specified position.","['return', 'List.set(int index, E element)']"
"List.set(int index, E element)","what's the parameter of List.set(int index, E element)?","the parameter of List.set(int index, E element) should be  index of the element to replace.","['parameter', 'List.set(int index, E element)']"
"List.add(int index, E element)","what's the parameter of List.add(int index, E element)?","the parameter of List.add(int index, E element) should be  index at which the specified element is to be inserted.","['parameter', 'List.add(int index, E element)']"
List.remove(int index),what's the return of List.remove(int index)?,the return of List.remove(int index) should be element that was removed.,"['return', 'List.remove(int index)']"
List.indexOf(Object o),what's the return of List.indexOf(Object o)?,"the return of List.indexOf(Object o) should be the index of the first occurrence of the specified element in this vector, or -1 if this vector does not contain the element. More formally, returns the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index..","['return', 'List.indexOf(Object o)']"
List.indexOf(Object o),what's the parameter of List.indexOf(Object o)?,the parameter of List.indexOf(Object o) should be  element to search for.,"['parameter', 'List.indexOf(Object o)']"
List.lastIndexOf(Object o),what's the return of List.lastIndexOf(Object o)?,"the return of List.lastIndexOf(Object o) should be the index of the last occurrence of the specified element in this vector, or -1 if this vector does not contain the element. More formally, returns the highest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index..","['return', 'List.lastIndexOf(Object o)']"
List.lastIndexOf(Object o),what's the parameter of List.lastIndexOf(Object o)?,the parameter of List.lastIndexOf(Object o) should be  element to search for.,"['parameter', 'List.lastIndexOf(Object o)']"
"List.addAll(int index, Collection<? extends E> c)","what's the return of List.addAll(int index, Collection<? extends E> c)?","the return of List.addAll(int index, Collection<? extends E> c) should be c - elements to be inserted into this Vector.","['return', 'List.addAll(int index, Collection<? extends E> c)']"
Iterable.iterator(),what's the return of Iterable.iterator()?,the return of Iterable.iterator() should be an iterator over the elements in this list in proper sequence..,"['return', 'Iterable.iterator()']"
List.listIterator(),what's the return of List.listIterator()?,the return of List.listIterator() should be a list iterator over the elements in this list (in proper sequence)..,"['return', 'List.listIterator()']"
List.listIterator(int index),what's the return of List.listIterator(int index)?,"the return of List.listIterator(int index) should be a list iterator over the elements in this list (in proper sequence), starting at the specified position in the list. The specified index indicates the first element that would be returned by an initial call to next. An initial call to previous would return the element with the specified index minus one..","['return', 'List.listIterator(int index)']"
"List.subList(int fromIndex, int toIndex)","what's the return of List.subList(int fromIndex, int toIndex)?","the return of List.subList(int fromIndex, int toIndex) should be a view of the portion of this List between fromIndex, inclusive, and toIndex, exclusive. (If fromIndex and toIndex are equal, the returned List is empty.) The returned List is backed by this List, so changes in the returned List are reflected in this List, and vice-versa. The returned List supports all of the optional List operations supported by this List. list.subList(from, to).clear(); Similar idioms may be constructed for indexOf and lastIndexOf, and all of the algorithms in the Collections class can be applied to a subList..","['return', 'List.subList(int fromIndex, int toIndex)']"
Object.equals(Object o),what's the return of Object.equals(Object o)?,the return of Object.equals(Object o) should be true if the specified object is equal to this map.,"['return', 'Object.equals(Object o)']"
Object.equals(Object o),what's the parameter of Object.equals(Object o)?,the parameter of Object.equals(Object o) should be  object to be compared for equality with this map.,"['parameter', 'Object.equals(Object o)']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
Map.size(),what's the return of Map.size()?,"the return of Map.size() should be the number of key-value mappings in this map. If the map contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE..","['return', 'Map.size()']"
Map.isEmpty(),what's the return of Map.isEmpty()?,the return of Map.isEmpty() should be true if this map contains no key-value mappings..,"['return', 'Map.isEmpty()']"
Map.containsValue(Object value),what's the return of Map.containsValue(Object value)?,"the return of Map.containsValue(Object value) should be true if this map maps one or more keys to the specified value. More formally, returns true if and only if this map contains at least one mapping to a value v such that (value==null ? v==null : value.equals(v)). This operation will probably require time linear in the map size for most implementations of the Map interface..","['return', 'Map.containsValue(Object value)']"
Map.containsValue(Object value),what's the parameter of Map.containsValue(Object value)?,the parameter of Map.containsValue(Object value) should be  value whose presence in this map is to be tested.,"['parameter', 'Map.containsValue(Object value)']"
Map.containsKey(Object key),what's the return of Map.containsKey(Object key)?,"the return of Map.containsKey(Object key) should be true if this map contains a mapping for the specified key. More formally, returns true if and only if this map contains a mapping for a key k such that (key==null ? k==null : key.equals(k)). (There can be at most one such mapping.).","['return', 'Map.containsKey(Object key)']"
Map.containsKey(Object key),what's the parameter of Map.containsKey(Object key)?,the parameter of Map.containsKey(Object key) should be  key whose presence in this map is to be tested.,"['parameter', 'Map.containsKey(Object key)']"
Map.get(Object key),what's the return of Map.get(Object key)?,"the return of Map.get(Object key) should be the value to which the specified key is mapped, or null if this map contains no mapping for the key..","['return', 'Map.get(Object key)']"
Map.get(Object key),what's the parameter of Map.get(Object key)?,the parameter of Map.get(Object key) should be  the key whose associated value is to be returned.,"['parameter', 'Map.get(Object key)']"
"Map.put(K key, V value)","what's the return of Map.put(K key, V value)?","the return of Map.put(K key, V value) should be value - value to be associated with the specified key.","['return', 'Map.put(K key, V value)']"
"Map.put(K key, V value)","what's the parameter of Map.put(K key, V value)?","the parameter of Map.put(K key, V value) should be  key with which the specified value is to be associated.","['parameter', 'Map.put(K key, V value)']"
Map.remove(Object key),what's the return of Map.remove(Object key)?,"the return of Map.remove(Object key) should be the previous value associated with key, or
         null if there was no mapping for key..","['return', 'Map.remove(Object key)']"
Map.remove(Object key),what's the parameter of Map.remove(Object key)?,the parameter of Map.remove(Object key) should be  key whose mapping is to be removed from the map.,"['parameter', 'Map.remove(Object key)']"
"Map.putAll(Map<? extends K,? extends V> m)","what's the parameter of Map.putAll(Map<? extends K,? extends V> m)?","the parameter of Map.putAll(Map<? extends K,? extends V> m) should be  mappings to be stored in this map.","['parameter', 'Map.putAll(Map<? extends K,? extends V> m)']"
Map.keySet(),what's the return of Map.keySet()?,"the return of Map.keySet() should be a Set view of the keys contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations..","['return', 'Map.keySet()']"
Map.values(),what's the return of Map.values()?,"the return of Map.values() should be a Collection view of the values contained in this map. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Collection.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations..","['return', 'Map.values()']"
Map.entrySet(),what's the return of Map.entrySet()?,the return of Map.entrySet() should be a set view of the mappings contained in this map.,"['return', 'Map.entrySet()']"
Object.equals(Object o),what's the return of Object.equals(Object o)?,the return of Object.equals(Object o) should be true if the specified object is equal to this map.,"['return', 'Object.equals(Object o)']"
Object.equals(Object o),what's the parameter of Object.equals(Object o)?,the parameter of Object.equals(Object o) should be  object to be compared for equality with this map.,"['parameter', 'Object.equals(Object o)']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
Object.clone(),what's the return of Object.clone()?,the return of Object.clone() should be a shallow copy of this AbstractMap instance: the keys and values themselves are not cloned..,"['return', 'Object.clone()']"
Map.Entry.getKey(),what's the return of Map.Entry.getKey()?,the return of Map.Entry.getKey() should be the key corresponding to this entry..,"['return', 'Map.Entry.getKey()']"
Map.Entry.getValue(),what's the return of Map.Entry.getValue()?,"the return of Map.Entry.getValue() should be the value corresponding to this entry. If the mapping has been removed from the backing map (by the iterator's remove operation), the results of this call are undefined..","['return', 'Map.Entry.getValue()']"
Map.Entry.setValue(V value),what's the return of Map.Entry.setValue(V value)?,the return of Map.Entry.setValue(V value) should be old value corresponding to the entry.,"['return', 'Map.Entry.setValue(V value)']"
Map.Entry.setValue(V value),what's the parameter of Map.Entry.setValue(V value)?,the parameter of Map.Entry.setValue(V value) should be  new value to be stored in this entry.,"['parameter', 'Map.Entry.setValue(V value)']"
Object.equals(Object o),what's the return of Object.equals(Object o)?,the return of Object.equals(Object o) should be true if the specified object is equal to this map.,"['return', 'Object.equals(Object o)']"
Object.equals(Object o),what's the parameter of Object.equals(Object o)?,the parameter of Object.equals(Object o) should be  object to be compared for equality with this map.,"['parameter', 'Object.equals(Object o)']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
Map.Entry.getKey(),what's the return of Map.Entry.getKey()?,the return of Map.Entry.getKey() should be the key corresponding to this entry..,"['return', 'Map.Entry.getKey()']"
Map.Entry.getValue(),what's the return of Map.Entry.getValue()?,"the return of Map.Entry.getValue() should be the value corresponding to this entry. If the mapping has been removed from the backing map (by the iterator's remove operation), the results of this call are undefined..","['return', 'Map.Entry.getValue()']"
Map.Entry.setValue(V value),what's the return of Map.Entry.setValue(V value)?,the return of Map.Entry.setValue(V value) should be old value corresponding to the entry.,"['return', 'Map.Entry.setValue(V value)']"
Map.Entry.setValue(V value),what's the parameter of Map.Entry.setValue(V value)?,the parameter of Map.Entry.setValue(V value) should be  new value to be stored in this entry.,"['parameter', 'Map.Entry.setValue(V value)']"
Object.equals(Object o),what's the return of Object.equals(Object o)?,the return of Object.equals(Object o) should be true if the specified object is equal to this map.,"['return', 'Object.equals(Object o)']"
Object.equals(Object o),what's the parameter of Object.equals(Object o)?,the parameter of Object.equals(Object o) should be  object to be compared for equality with this map.,"['parameter', 'Object.equals(Object o)']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
Queue.remove(),what's the return of Queue.remove()?,the return of Queue.remove() should be the head of the queue represented by this deque.,"['return', 'Queue.remove()']"
Queue.element(),what's the return of Queue.element()?,the return of Queue.element() should be the head of the queue represented by this deque.,"['return', 'Queue.element()']"
List.get(int index),what's the return of List.get(int index)?,the return of List.get(int index) should be the element at the specified position in this Vector..,"['return', 'List.get(int index)']"
Object.equals(Object o),what's the return of Object.equals(Object o)?,the return of Object.equals(Object o) should be true if the specified object is equal to this map.,"['return', 'Object.equals(Object o)']"
Object.equals(Object o),what's the parameter of Object.equals(Object o)?,the parameter of Object.equals(Object o) should be  object to be compared for equality with this map.,"['parameter', 'Object.equals(Object o)']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
Deque.addFirst(E e),what's the parameter of Deque.addFirst(E e)?,the parameter of Deque.addFirst(E e) should be  the element to add.,"['parameter', 'Deque.addFirst(E e)']"
Deque.addLast(E e),what's the parameter of Deque.addLast(E e)?,the parameter of Deque.addLast(E e) should be  the element to add.,"['parameter', 'Deque.addLast(E e)']"
Deque.offerFirst(E e),what's the return of Deque.offerFirst(E e)?,"the return of Deque.offerFirst(E e) should be true if the element was added to this deque, else
         false.","['return', 'Deque.offerFirst(E e)']"
Deque.offerFirst(E e),what's the parameter of Deque.offerFirst(E e)?,the parameter of Deque.offerFirst(E e) should be  the element to add.,"['parameter', 'Deque.offerFirst(E e)']"
Deque.offerLast(E e),what's the return of Deque.offerLast(E e)?,"the return of Deque.offerLast(E e) should be true if the element was added to this deque, else
         false.","['return', 'Deque.offerLast(E e)']"
Deque.offerLast(E e),what's the parameter of Deque.offerLast(E e)?,the parameter of Deque.offerLast(E e) should be  the element to add.,"['parameter', 'Deque.offerLast(E e)']"
Deque.removeFirst(),what's the return of Deque.removeFirst()?,the return of Deque.removeFirst() should be the head of this deque.,"['return', 'Deque.removeFirst()']"
Deque.removeLast(),what's the return of Deque.removeLast()?,the return of Deque.removeLast() should be the tail of this deque.,"['return', 'Deque.removeLast()']"
Deque.pollFirst(),what's the return of Deque.pollFirst()?,"the return of Deque.pollFirst() should be the head of this deque, or null if this deque is empty.","['return', 'Deque.pollFirst()']"
Deque.pollLast(),what's the return of Deque.pollLast()?,"the return of Deque.pollLast() should be the tail of this deque, or null if this deque is empty.","['return', 'Deque.pollLast()']"
Deque.getFirst(),what's the return of Deque.getFirst()?,the return of Deque.getFirst() should be the head of this deque.,"['return', 'Deque.getFirst()']"
Deque.getLast(),what's the return of Deque.getLast()?,the return of Deque.getLast() should be the tail of this deque.,"['return', 'Deque.getLast()']"
Deque.peekFirst(),what's the return of Deque.peekFirst()?,"the return of Deque.peekFirst() should be the head of this deque, or null if this deque is empty.","['return', 'Deque.peekFirst()']"
Deque.peekLast(),what's the return of Deque.peekLast()?,"the return of Deque.peekLast() should be the tail of this deque, or null if this deque is empty.","['return', 'Deque.peekLast()']"
Deque.removeFirstOccurrence(Object o),what's the return of Deque.removeFirstOccurrence(Object o)?,the return of Deque.removeFirstOccurrence(Object o) should be true if an element was removed as a result of this call.,"['return', 'Deque.removeFirstOccurrence(Object o)']"
Deque.removeFirstOccurrence(Object o),what's the parameter of Deque.removeFirstOccurrence(Object o)?,"the parameter of Deque.removeFirstOccurrence(Object o) should be  element to be removed from this deque, if present.","['parameter', 'Deque.removeFirstOccurrence(Object o)']"
Deque.removeLastOccurrence(Object o),what's the return of Deque.removeLastOccurrence(Object o)?,the return of Deque.removeLastOccurrence(Object o) should be true if an element was removed as a result of this call.,"['return', 'Deque.removeLastOccurrence(Object o)']"
Deque.removeLastOccurrence(Object o),what's the parameter of Deque.removeLastOccurrence(Object o)?,"the parameter of Deque.removeLastOccurrence(Object o) should be  element to be removed from this deque, if present.","['parameter', 'Deque.removeLastOccurrence(Object o)']"
Deque.offer(E e),what's the return of Deque.offer(E e)?,the return of Deque.offer(E e) should be true (as specified by Queue.offer(E)).,"['return', 'Deque.offer(E e)']"
Deque.offer(E e),what's the parameter of Deque.offer(E e)?,the parameter of Deque.offer(E e) should be  the element to add.,"['parameter', 'Deque.offer(E e)']"
Deque.remove(),what's the return of Deque.remove()?,the return of Deque.remove() should be the head of the queue represented by this deque.,"['return', 'Deque.remove()']"
Deque.poll(),what's the return of Deque.poll()?,"the return of Deque.poll() should be the head of the queue represented by this deque, or
         null if this deque is empty.","['return', 'Deque.poll()']"
Deque.element(),what's the return of Deque.element()?,the return of Deque.element() should be the head of the queue represented by this deque.,"['return', 'Deque.element()']"
Deque.peek(),what's the return of Deque.peek()?,"the return of Deque.peek() should be the head of the queue represented by this deque, or
         null if this deque is empty.","['return', 'Deque.peek()']"
Deque.push(E e),what's the parameter of Deque.push(E e)?,the parameter of Deque.push(E e) should be  the element to push.,"['parameter', 'Deque.push(E e)']"
Deque.pop(),what's the return of Deque.pop()?,"the return of Deque.pop() should be the element at the front of this deque (which is the top
         of the stack represented by this deque).","['return', 'Deque.pop()']"
Collection.size(),what's the return of Collection.size()?,the return of Collection.size() should be the number of elements in this deque..,"['return', 'Collection.size()']"
Iterable.iterator(),what's the return of Iterable.iterator()?,the return of Iterable.iterator() should be an iterator over the elements in this list in proper sequence..,"['return', 'Iterable.iterator()']"
Deque.descendingIterator(),what's the return of Deque.descendingIterator()?,the return of Deque.descendingIterator() should be an iterator over the elements in this deque in reverse sequential order. The elements will be returned in order from last (tail) to first (head)..,"['return', 'Deque.descendingIterator()']"
Object.clone(),what's the return of Object.clone()?,the return of Object.clone() should be a shallow copy of this AbstractMap instance: the keys and values themselves are not cloned..,"['return', 'Object.clone()']"
Iterable.spliterator(),what's the return of Iterable.spliterator()?,the return of Iterable.spliterator() should be a Spliterator over the elements in this list.,"['return', 'Iterable.spliterator()']"
Base64.Encoder.encode(byte[] src),what's the return of Base64.Encoder.encode(byte[] src)?,"the return of Base64.Encoder.encode(byte[] src) should be A newly-allocated byte array containing the resulting
          encoded bytes..","['return', 'Base64.Encoder.encode(byte[] src)']"
"Base64.Encoder.encode(byte[] src, byte[] dst)","what's the return of Base64.Encoder.encode(byte[] src, byte[] dst)?","the return of Base64.Encoder.encode(byte[] src, byte[] dst) should be dst - the output byte array.","['return', 'Base64.Encoder.encode(byte[] src, byte[] dst)']"
Base64.Encoder.encodeToString(byte[] src),what's the return of Base64.Encoder.encodeToString(byte[] src)?,the return of Base64.Encoder.encodeToString(byte[] src) should be A String containing the resulting Base64 encoded characters.,"['return', 'Base64.Encoder.encodeToString(byte[] src)']"
Base64.Encoder.encode(ByteBuffer buffer),what's the return of Base64.Encoder.encode(ByteBuffer buffer)?,the return of Base64.Encoder.encode(ByteBuffer buffer) should be A newly-allocated byte buffer containing the encoded bytes..,"['return', 'Base64.Encoder.encode(ByteBuffer buffer)']"
Base64.Encoder.encode(ByteBuffer buffer),what's the parameter of Base64.Encoder.encode(ByteBuffer buffer)?,the parameter of Base64.Encoder.encode(ByteBuffer buffer) should be  the source ByteBuffer to encode.,"['parameter', 'Base64.Encoder.encode(ByteBuffer buffer)']"
Base64.Encoder.wrap(OutputStream os),what's the return of Base64.Encoder.wrap(OutputStream os)?,"the return of Base64.Encoder.wrap(OutputStream os) should be the output stream for encoding the byte data into the
          specified Base64 encoded format.","['return', 'Base64.Encoder.wrap(OutputStream os)']"
Base64.Encoder.wrap(OutputStream os),what's the parameter of Base64.Encoder.wrap(OutputStream os)?,the parameter of Base64.Encoder.wrap(OutputStream os) should be  the output stream..,"['parameter', 'Base64.Encoder.wrap(OutputStream os)']"
Base64.Encoder.withoutPadding(),what's the return of Base64.Encoder.withoutPadding()?,"the return of Base64.Encoder.withoutPadding() should be an encoder instance that encodes equivalently to this one, but without adding any padding character at the end of the encoded byte data..","['return', 'Base64.Encoder.withoutPadding()']"
Base64.getEncoder(),what's the return of Base64.getEncoder()?,the return of Base64.getEncoder() should be a Base64.Encoder that encodes using the Basic type base64 encoding scheme..,"['return', 'Base64.getEncoder()']"
Base64.getUrlEncoder(),what's the return of Base64.getUrlEncoder()?,the return of Base64.getUrlEncoder() should be a Base64.Encoder that encodes using the URL and Filename safe type base64 encoding scheme..,"['return', 'Base64.getUrlEncoder()']"
Base64.getMimeEncoder(),what's the return of Base64.getMimeEncoder()?,the return of Base64.getMimeEncoder() should be a Base64.Encoder that encodes using the MIME type base64 encoding scheme..,"['return', 'Base64.getMimeEncoder()']"
"Base64.getMimeEncoder(int lineLength, byte[] lineSeparator)","what's the return of Base64.getMimeEncoder(int lineLength, byte[] lineSeparator)?","the return of Base64.getMimeEncoder(int lineLength, byte[] lineSeparator) should be a Base64.Encoder that encodes using the MIME type base64 encoding scheme with specified line length and line separators..","['return', 'Base64.getMimeEncoder(int lineLength, byte[] lineSeparator)']"
Base64.getDecoder(),what's the return of Base64.getDecoder()?,the return of Base64.getDecoder() should be a Base64.Decoder that decodes using the Basic type base64 encoding scheme..,"['return', 'Base64.getDecoder()']"
Base64.getUrlDecoder(),what's the return of Base64.getUrlDecoder()?,the return of Base64.getUrlDecoder() should be a Base64.Decoder that decodes using the URL and Filename safe type base64 encoding scheme..,"['return', 'Base64.getUrlDecoder()']"
Base64.getMimeDecoder(),what's the return of Base64.getMimeDecoder()?,the return of Base64.getMimeDecoder() should be a Base64.Decoder that decodes using the MIME type base64 decoding scheme..,"['return', 'Base64.getMimeDecoder()']"
BitSet.valueOf(long[] longs),what's the return of BitSet.valueOf(long[] longs)?,the return of BitSet.valueOf(long[] longs) should be a new bit set containing all the bits in the given long array..,"['return', 'BitSet.valueOf(long[] longs)']"
BitSet.valueOf(LongBuffer lb),what's the return of BitSet.valueOf(LongBuffer lb)?,the return of BitSet.valueOf(LongBuffer lb) should be a new bit set containing all the bits in the given long buffer between its position and limit..,"['return', 'BitSet.valueOf(LongBuffer lb)']"
BitSet.valueOf(LongBuffer lb),what's the parameter of BitSet.valueOf(LongBuffer lb)?,the parameter of BitSet.valueOf(LongBuffer lb) should be  a long buffer containing a little.,"['parameter', 'BitSet.valueOf(LongBuffer lb)']"
BitSet.valueOf(byte[] bytes),what's the return of BitSet.valueOf(byte[] bytes)?,the return of BitSet.valueOf(byte[] bytes) should be a new bit set containing all the bits in the given byte array..,"['return', 'BitSet.valueOf(byte[] bytes)']"
BitSet.valueOf(ByteBuffer bb),what's the return of BitSet.valueOf(ByteBuffer bb)?,the return of BitSet.valueOf(ByteBuffer bb) should be a new bit set containing all the bits in the given byte buffer between its position and limit..,"['return', 'BitSet.valueOf(ByteBuffer bb)']"
BitSet.valueOf(ByteBuffer bb),what's the parameter of BitSet.valueOf(ByteBuffer bb)?,the parameter of BitSet.valueOf(ByteBuffer bb) should be  a byte buffer containing a little.,"['parameter', 'BitSet.valueOf(ByteBuffer bb)']"
BitSet.toByteArray(),what's the return of BitSet.toByteArray()?,the return of BitSet.toByteArray() should be a new byte array containing all the bits in this bit set..,"['return', 'BitSet.toByteArray()']"
BitSet.toLongArray(),what's the return of BitSet.toLongArray()?,the return of BitSet.toLongArray() should be a new long array containing all the bits in this bit set..,"['return', 'BitSet.toLongArray()']"
BitSet.get(int bitIndex),what's the return of BitSet.get(int bitIndex)?,"the return of BitSet.get(int bitIndex) should be the value of the bit with the specified index. The value is true if the bit with the index bitIndex is currently set in this BitSet; otherwise, the result is false..","['return', 'BitSet.get(int bitIndex)']"
"BitSet.get(int fromIndex, int toIndex)","what's the return of BitSet.get(int fromIndex, int toIndex)?","the return of BitSet.get(int fromIndex, int toIndex) should be a new BitSet composed of bits from this BitSet from fromIndex (inclusive) to toIndex (exclusive)..","['return', 'BitSet.get(int fromIndex, int toIndex)']"
BitSet.nextSetBit(int fromIndex),what's the return of BitSet.nextSetBit(int fromIndex)?,the return of BitSet.nextSetBit(int fromIndex) should be the index of the first bit that is set to true that occurs on or after the specified starting index. If no such bit exists then -1 is returned. for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i+1)) { // operate on index i here if (i == Integer.MAX_VALUE) { break; // or (i+1) would overflow } }.,"['return', 'BitSet.nextSetBit(int fromIndex)']"
BitSet.nextClearBit(int fromIndex),what's the return of BitSet.nextClearBit(int fromIndex)?,the return of BitSet.nextClearBit(int fromIndex) should be the index of the first bit that is set to false that occurs on or after the specified starting index..,"['return', 'BitSet.nextClearBit(int fromIndex)']"
BitSet.previousSetBit(int fromIndex),what's the return of BitSet.previousSetBit(int fromIndex)?,"the return of BitSet.previousSetBit(int fromIndex) should be the index of the nearest bit that is set to true that occurs on or before the specified starting index. If no such bit exists, or if -1 is given as the starting index, then -1 is returned. for (int i = bs.length(); (i = bs.previousSetBit(i-1)) >= 0; ) { // operate on index i here }.","['return', 'BitSet.previousSetBit(int fromIndex)']"
BitSet.previousClearBit(int fromIndex),what's the return of BitSet.previousClearBit(int fromIndex)?,"the return of BitSet.previousClearBit(int fromIndex) should be the index of the nearest bit that is set to false that occurs on or before the specified starting index. If no such bit exists, or if -1 is given as the starting index, then -1 is returned..","['return', 'BitSet.previousClearBit(int fromIndex)']"
BitSet.length(),what's the return of BitSet.length()?,"the return of BitSet.length() should be the ""logical size"" of this BitSet: the index of the highest set bit in the BitSet plus one. Returns zero if the BitSet contains no set bits..","['return', 'BitSet.length()']"
BitSet.isEmpty(),what's the return of BitSet.isEmpty()?,the return of BitSet.isEmpty() should be true if this BitSet contains no bits that are set to true..,"['return', 'BitSet.isEmpty()']"
BitSet.intersects(BitSet set),what's the return of BitSet.intersects(BitSet set)?,the return of BitSet.intersects(BitSet set) should be true if the specified BitSet has any bits set to true that are also set to true in this BitSet..,"['return', 'BitSet.intersects(BitSet set)']"
BitSet.intersects(BitSet set),what's the parameter of BitSet.intersects(BitSet set)?,the parameter of BitSet.intersects(BitSet set) should be  BitSet to intersect with.,"['parameter', 'BitSet.intersects(BitSet set)']"
BitSet.cardinality(),what's the return of BitSet.cardinality()?,the return of BitSet.cardinality() should be the number of bits set to true in this BitSet..,"['return', 'BitSet.cardinality()']"
BitSet.and(BitSet set),what's the parameter of BitSet.and(BitSet set)?,the parameter of BitSet.and(BitSet set) should be  a bit set.,"['parameter', 'BitSet.and(BitSet set)']"
BitSet.or(BitSet set),what's the parameter of BitSet.or(BitSet set)?,the parameter of BitSet.or(BitSet set) should be  a bit set.,"['parameter', 'BitSet.or(BitSet set)']"
BitSet.xor(BitSet set),what's the parameter of BitSet.xor(BitSet set)?,the parameter of BitSet.xor(BitSet set) should be  a bit set.,"['parameter', 'BitSet.xor(BitSet set)']"
BitSet.andNot(BitSet set),what's the parameter of BitSet.andNot(BitSet set)?,"the parameter of BitSet.andNot(BitSet set) should be  the BitSet with which to mask this
         BitSet.","['parameter', 'BitSet.andNot(BitSet set)']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
BitSet.size(),what's the return of BitSet.size()?,the return of BitSet.size() should be the number of bits of space actually in use by this BitSet to represent bit values. The maximum element in the set is the size - 1st element..,"['return', 'BitSet.size()']"
Object.equals(Object obj),what's the return of Object.equals(Object obj)?,"the return of Object.equals(Object obj) should be true if the objects are the same;
          false otherwise..","['return', 'Object.equals(Object obj)']"
Object.equals(Object obj),what's the parameter of Object.equals(Object obj)?,the parameter of Object.equals(Object obj) should be  the object to compare with..,"['parameter', 'Object.equals(Object obj)']"
Object.clone(),what's the return of Object.clone()?,the return of Object.clone() should be a shallow copy of this AbstractMap instance: the keys and values themselves are not cloned..,"['return', 'Object.clone()']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
BitSet.stream(),what's the return of BitSet.stream()?,"the return of BitSet.stream() should be a stream of indices for which this BitSet contains a bit in the set state. The indices are returned in order, from lowest to highest. The size of the stream is the number of bits in the set state, equal to the value returned by the cardinality() method..","['return', 'BitSet.stream()']"
Calendar.Builder.setInstant(long instant),what's the return of Calendar.Builder.setInstant(long instant)?,the return of Calendar.Builder.setInstant(long instant) should be this Calendar.Builder.,"['return', 'Calendar.Builder.setInstant(long instant)']"
Calendar.Builder.setInstant(Date instant),what's the return of Calendar.Builder.setInstant(Date instant)?,the return of Calendar.Builder.setInstant(Date instant) should be this Calendar.Builder.,"['return', 'Calendar.Builder.setInstant(Date instant)']"
Calendar.Builder.setInstant(Date instant),what's the parameter of Calendar.Builder.setInstant(Date instant)?,"the parameter of Calendar.Builder.setInstant(Date instant) should be  a Date representing a millisecond offset from
                the Epoch.","['parameter', 'Calendar.Builder.setInstant(Date instant)']"
"Calendar.Builder.set(int field, int value)","what's the return of Calendar.Builder.set(int field, int value)?","the return of Calendar.Builder.set(int field, int value) should be value - the field value.","['return', 'Calendar.Builder.set(int field, int value)']"
Calendar.Builder.setFields(int... fieldValuePairs),what's the return of Calendar.Builder.setFields(int... fieldValuePairs)?,the return of Calendar.Builder.setFields(int... fieldValuePairs) should be this Calendar.Builder.,"['return', 'Calendar.Builder.setFields(int... fieldValuePairs)']"
"Calendar.Builder.setDate(int year, int month, int dayOfMonth)","what's the return of Calendar.Builder.setDate(int year, int month, int dayOfMonth)?","the return of Calendar.Builder.setDate(int year, int month, int dayOfMonth) should be month - the MONTH value
                   (the month numbering is 0-based)..","['return', 'Calendar.Builder.setDate(int year, int month, int dayOfMonth)']"
"Calendar.Builder.setTimeOfDay(int hourOfDay, int minute, int second)","what's the return of Calendar.Builder.setTimeOfDay(int hourOfDay, int minute, int second)?","the return of Calendar.Builder.setTimeOfDay(int hourOfDay, int minute, int second) should be minute - the MINUTE value.","['return', 'Calendar.Builder.setTimeOfDay(int hourOfDay, int minute, int second)']"
"Calendar.Builder.setTimeOfDay(int hourOfDay, int minute, int second, int millis)","what's the return of Calendar.Builder.setTimeOfDay(int hourOfDay, int minute, int second, int millis)?","the return of Calendar.Builder.setTimeOfDay(int hourOfDay, int minute, int second, int millis) should be minute - the MINUTE value.","['return', 'Calendar.Builder.setTimeOfDay(int hourOfDay, int minute, int second, int millis)']"
"Calendar.Builder.setWeekDate(int weekYear, int weekOfYear, int dayOfWeek)","what's the return of Calendar.Builder.setWeekDate(int weekYear, int weekOfYear, int dayOfWeek)?","the return of Calendar.Builder.setWeekDate(int weekYear, int weekOfYear, int dayOfWeek) should be weekOfYear - the week number based on weekYear.","['return', 'Calendar.Builder.setWeekDate(int weekYear, int weekOfYear, int dayOfWeek)']"
Calendar.Builder.setTimeZone(TimeZone zone),what's the return of Calendar.Builder.setTimeZone(TimeZone zone)?,the return of Calendar.Builder.setTimeZone(TimeZone zone) should be this Calendar.Builder.,"['return', 'Calendar.Builder.setTimeZone(TimeZone zone)']"
Calendar.Builder.setTimeZone(TimeZone zone),what's the parameter of Calendar.Builder.setTimeZone(TimeZone zone)?,the parameter of Calendar.Builder.setTimeZone(TimeZone zone) should be  the TimeZone.,"['parameter', 'Calendar.Builder.setTimeZone(TimeZone zone)']"
Calendar.Builder.setLenient(boolean lenient),what's the return of Calendar.Builder.setLenient(boolean lenient)?,the return of Calendar.Builder.setLenient(boolean lenient) should be this Calendar.Builder.,"['return', 'Calendar.Builder.setLenient(boolean lenient)']"
Calendar.Builder.setCalendarType(String type),what's the return of Calendar.Builder.setCalendarType(String type)?,the return of Calendar.Builder.setCalendarType(String type) should be this Calendar.Builder.,"['return', 'Calendar.Builder.setCalendarType(String type)']"
Calendar.Builder.setCalendarType(String type),what's the parameter of Calendar.Builder.setCalendarType(String type)?,the parameter of Calendar.Builder.setCalendarType(String type) should be  the calendar type.,"['parameter', 'Calendar.Builder.setCalendarType(String type)']"
Calendar.Builder.setLocale(Locale locale),what's the return of Calendar.Builder.setLocale(Locale locale)?,the return of Calendar.Builder.setLocale(Locale locale) should be this Calendar.Builder.,"['return', 'Calendar.Builder.setLocale(Locale locale)']"
Calendar.Builder.setLocale(Locale locale),what's the parameter of Calendar.Builder.setLocale(Locale locale)?,the parameter of Calendar.Builder.setLocale(Locale locale) should be  the Locale.,"['parameter', 'Calendar.Builder.setLocale(Locale locale)']"
"Calendar.Builder.setWeekDefinition(int firstDayOfWeek, int minimalDaysInFirstWeek)","what's the return of Calendar.Builder.setWeekDefinition(int firstDayOfWeek, int minimalDaysInFirstWeek)?","the return of Calendar.Builder.setWeekDefinition(int firstDayOfWeek, int minimalDaysInFirstWeek) should be minimalDaysInFirstWeek - the minimal number of days in the first
                               week (1..7).","['return', 'Calendar.Builder.setWeekDefinition(int firstDayOfWeek, int minimalDaysInFirstWeek)']"
Calendar.Builder.build(),what's the return of Calendar.Builder.build()?,"the return of Calendar.Builder.build() should be a Calendar built from the parameters set by the setter methods. The calendar type given by the setCalendarType method or the locale is used to determine what Calendar to be created. If no explicit calendar type is given, the locale's default calendar is created..","['return', 'Calendar.Builder.build()']"
Collection.size(),what's the return of Collection.size()?,the return of Collection.size() should be the number of elements in this deque..,"['return', 'Collection.size()']"
Collection.isEmpty(),what's the return of Collection.isEmpty()?,the return of Collection.isEmpty() should be true if this set contains no elements..,"['return', 'Collection.isEmpty()']"
Collection.contains(Object o),what's the return of Collection.contains(Object o)?,"the return of Collection.contains(Object o) should be true if this deque contains the specified element. More formally, returns true if and only if this deque contains at least one element e such that (o==null ? e==null : o.equals(e))..","['return', 'Collection.contains(Object o)']"
Collection.contains(Object o),what's the parameter of Collection.contains(Object o)?,the parameter of Collection.contains(Object o) should be  element whose presence in this deque is to be tested.,"['parameter', 'Collection.contains(Object o)']"
Iterable.iterator(),what's the return of Iterable.iterator()?,the return of Iterable.iterator() should be an iterator over the elements in this list in proper sequence..,"['return', 'Iterable.iterator()']"
Collection.toArray(),what's the return of Collection.toArray()?,"the return of Collection.toArray() should be an array containing all of the elements in this set. If this set makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order..","['return', 'Collection.toArray()']"
Collection.toArray(T[] a),what's the return of Collection.toArray(T[] a)?,"the return of Collection.toArray(T[] a) should be an array containing all of the elements in this set; the runtime type of the returned array is that of the specified array. If the set fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this set. String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray()..","['return', 'Collection.toArray(T[] a)']"
Collection.add(E e),what's the return of Collection.add(E e)?,the return of Collection.add(E e) should be true (as specified by Collection.add(E)).,"['return', 'Collection.add(E e)']"
Collection.add(E e),what's the parameter of Collection.add(E e)?,the parameter of Collection.add(E e) should be  the element to add.,"['parameter', 'Collection.add(E e)']"
Collection.remove(Object o),what's the return of Collection.remove(Object o)?,the return of Collection.remove(Object o) should be true if an element was removed as a result of this call.,"['return', 'Collection.remove(Object o)']"
Collection.remove(Object o),what's the parameter of Collection.remove(Object o)?,"the parameter of Collection.remove(Object o) should be  element to be removed from this deque, if present.","['parameter', 'Collection.remove(Object o)']"
Collection.containsAll(Collection<?> c),what's the return of Collection.containsAll(Collection<?> c)?,"the return of Collection.containsAll(Collection<?> c) should be true if this set contains all of the elements of the specified collection. If the specified collection is also a set, this method returns true if it is a subset of this set..","['return', 'Collection.containsAll(Collection<?> c)']"
Collection.addAll(Collection<? extends E> c),what's the return of Collection.addAll(Collection<? extends E> c)?,the return of Collection.addAll(Collection<? extends E> c) should be true if this set changed as a result of the call.,"['return', 'Collection.addAll(Collection<? extends E> c)']"
Collection.removeAll(Collection<?> c),what's the return of Collection.removeAll(Collection<?> c)?,the return of Collection.removeAll(Collection<?> c) should be true if this set changed as a result of the call.,"['return', 'Collection.removeAll(Collection<?> c)']"
Collection.removeIf(Predicate<? super E> filter),what's the return of Collection.removeIf(Predicate<? super E> filter)?,the return of Collection.removeIf(Predicate<? super E> filter) should be true if any elements were removed.,"['return', 'Collection.removeIf(Predicate<? super E> filter)']"
Collection.retainAll(Collection<?> c),what's the return of Collection.retainAll(Collection<?> c)?,the return of Collection.retainAll(Collection<?> c) should be true if this set changed as a result of the call.,"['return', 'Collection.retainAll(Collection<?> c)']"
Object.equals(Object o),what's the return of Object.equals(Object o)?,the return of Object.equals(Object o) should be true if the specified object is equal to this map.,"['return', 'Object.equals(Object o)']"
Object.equals(Object o),what's the parameter of Object.equals(Object o)?,the parameter of Object.equals(Object o) should be  object to be compared for equality with this map.,"['parameter', 'Object.equals(Object o)']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
Iterable.spliterator(),what's the return of Iterable.spliterator()?,the return of Iterable.spliterator() should be a Spliterator over the elements in this list.,"['return', 'Iterable.spliterator()']"
Collection.stream(),what's the return of Collection.stream()?,the return of Collection.stream() should be a sequential Stream with this collection as its source..,"['return', 'Collection.stream()']"
Collection.parallelStream(),what's the return of Collection.parallelStream()?,the return of Collection.parallelStream() should be a possibly parallel Stream with this collection as its source. It is allowable for this method to return a sequential stream..,"['return', 'Collection.parallelStream()']"
"Collections.binarySearch(List<? extends Comparable<? super T>> list, T key)","what's the return of Collections.binarySearch(List<? extends Comparable<? super T>> list, T key)?","the return of Collections.binarySearch(List<? extends Comparable<? super T>> list, T key) should be key - the key to be searched for..","['return', 'Collections.binarySearch(List<? extends Comparable<? super T>> list, T key)']"
"Collections.binarySearch(List<? extends T> list, T key, Comparator<? super T> c)","what's the return of Collections.binarySearch(List<? extends T> list, T key, Comparator<? super T> c)?","the return of Collections.binarySearch(List<? extends T> list, T key, Comparator<? super T> c) should be key - the key to be searched for..","['return', 'Collections.binarySearch(List<? extends T> list, T key, Comparator<? super T> c)']"
"Collections.shuffle(List<?> list, Random rnd)","what's the parameter of Collections.shuffle(List<?> list, Random rnd)?","the parameter of Collections.shuffle(List<?> list, Random rnd) should be  the list to be shuffled..","['parameter', 'Collections.shuffle(List<?> list, Random rnd)']"
Collections.min(Collection<? extends T> coll),what's the return of Collections.min(Collection<? extends T> coll)?,"the return of Collections.min(Collection<? extends T> coll) should be the minimum element of the given collection, according to the natural ordering of its elements. All elements in the collection must implement the Comparable interface. Furthermore, all elements in the collection must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the collection)..","['return', 'Collections.min(Collection<? extends T> coll)']"
"Collections.min(Collection<? extends T> coll, Comparator<? super T> comp)","what's the return of Collections.min(Collection<? extends T> coll, Comparator<? super T> comp)?","the return of Collections.min(Collection<? extends T> coll, Comparator<? super T> comp) should be the minimum element of the given collection, according to the order induced by the specified comparator. All elements in the collection must be mutually comparable by the specified comparator (that is, comp.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the collection)..","['return', 'Collections.min(Collection<? extends T> coll, Comparator<? super T> comp)']"
Collections.max(Collection<? extends T> coll),what's the return of Collections.max(Collection<? extends T> coll)?,"the return of Collections.max(Collection<? extends T> coll) should be the maximum element of the given collection, according to the natural ordering of its elements. All elements in the collection must implement the Comparable interface. Furthermore, all elements in the collection must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the collection)..","['return', 'Collections.max(Collection<? extends T> coll)']"
"Collections.max(Collection<? extends T> coll, Comparator<? super T> comp)","what's the return of Collections.max(Collection<? extends T> coll, Comparator<? super T> comp)?","the return of Collections.max(Collection<? extends T> coll, Comparator<? super T> comp) should be the maximum element of the given collection, according to the order induced by the specified comparator. All elements in the collection must be mutually comparable by the specified comparator (that is, comp.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the collection)..","['return', 'Collections.max(Collection<? extends T> coll, Comparator<? super T> comp)']"
"Collections.replaceAll(List<T> list, T oldVal, T newVal)","what's the return of Collections.replaceAll(List<T> list, T oldVal, T newVal)?","the return of Collections.replaceAll(List<T> list, T oldVal, T newVal) should be oldVal - the old value to be replaced..","['return', 'Collections.replaceAll(List<T> list, T oldVal, T newVal)']"
"Collections.indexOfSubList(List<?> source, List<?> target)","what's the return of Collections.indexOfSubList(List<?> source, List<?> target)?","the return of Collections.indexOfSubList(List<?> source, List<?> target) should be the starting position of the first occurrence of the specified target list within the specified source list, or -1 if there is no such occurrence. More formally, returns the lowest index i such that source.subList(i, i+target.size()).equals(target), or -1 if there is no such index. (Returns -1 if target.size() > source.size()).","['return', 'Collections.indexOfSubList(List<?> source, List<?> target)']"
"Collections.lastIndexOfSubList(List<?> source, List<?> target)","what's the return of Collections.lastIndexOfSubList(List<?> source, List<?> target)?","the return of Collections.lastIndexOfSubList(List<?> source, List<?> target) should be the starting position of the last occurrence of the specified target list within the specified source list, or -1 if there is no such occurrence. More formally, returns the highest index i such that source.subList(i, i+target.size()).equals(target), or -1 if there is no such index. (Returns -1 if target.size() > source.size()).","['return', 'Collections.lastIndexOfSubList(List<?> source, List<?> target)']"
Collections.unmodifiableCollection(Collection<? extends T> c),what's the return of Collections.unmodifiableCollection(Collection<? extends T> c)?,"the return of Collections.unmodifiableCollection(Collection<? extends T> c) should be an unmodifiable view of the specified collection. This method allows modules to provide users with ""read-only"" access to internal collections. Query operations on the returned collection ""read through"" to the specified collection, and attempts to modify the returned collection, whether direct or via its iterator, result in an UnsupportedOperationException..","['return', 'Collections.unmodifiableCollection(Collection<? extends T> c)']"
Collections.unmodifiableSet(Set<? extends T> s),what's the return of Collections.unmodifiableSet(Set<? extends T> s)?,"the return of Collections.unmodifiableSet(Set<? extends T> s) should be an unmodifiable view of the specified set. This method allows modules to provide users with ""read-only"" access to internal sets. Query operations on the returned set ""read through"" to the specified set, and attempts to modify the returned set, whether direct or via its iterator, result in an UnsupportedOperationException..","['return', 'Collections.unmodifiableSet(Set<? extends T> s)']"
Collections.unmodifiableSortedSet(SortedSet<T> s),what's the return of Collections.unmodifiableSortedSet(SortedSet<T> s)?,"the return of Collections.unmodifiableSortedSet(SortedSet<T> s) should be an unmodifiable view of the specified sorted set. This method allows modules to provide users with ""read-only"" access to internal sorted sets. Query operations on the returned sorted set ""read through"" to the specified sorted set. Attempts to modify the returned sorted set, whether direct, via its iterator, or via its subSet, headSet, or tailSet views, result in an UnsupportedOperationException..","['return', 'Collections.unmodifiableSortedSet(SortedSet<T> s)']"
Collections.unmodifiableNavigableSet(NavigableSet<T> s),what's the return of Collections.unmodifiableNavigableSet(NavigableSet<T> s)?,"the return of Collections.unmodifiableNavigableSet(NavigableSet<T> s) should be an unmodifiable view of the specified navigable set. This method allows modules to provide users with ""read-only"" access to internal navigable sets. Query operations on the returned navigable set ""read through"" to the specified navigable set. Attempts to modify the returned navigable set, whether direct, via its iterator, or via its subSet, headSet, or tailSet views, result in an UnsupportedOperationException..","['return', 'Collections.unmodifiableNavigableSet(NavigableSet<T> s)']"
Collections.unmodifiableList(List<? extends T> list),what's the return of Collections.unmodifiableList(List<? extends T> list)?,"the return of Collections.unmodifiableList(List<? extends T> list) should be an unmodifiable view of the specified list. This method allows modules to provide users with ""read-only"" access to internal lists. Query operations on the returned list ""read through"" to the specified list, and attempts to modify the returned list, whether direct or via its iterator, result in an UnsupportedOperationException..","['return', 'Collections.unmodifiableList(List<? extends T> list)']"
"Collections.unmodifiableMap(Map<? extends K,? extends V> m)","what's the return of Collections.unmodifiableMap(Map<? extends K,? extends V> m)?","the return of Collections.unmodifiableMap(Map<? extends K,? extends V> m) should be an unmodifiable view of the specified map. This method allows modules to provide users with ""read-only"" access to internal maps. Query operations on the returned map ""read through"" to the specified map, and attempts to modify the returned map, whether direct or via its collection views, result in an UnsupportedOperationException..","['return', 'Collections.unmodifiableMap(Map<? extends K,? extends V> m)']"
"Collections.unmodifiableSortedMap(SortedMap<K,? extends V> m)","what's the return of Collections.unmodifiableSortedMap(SortedMap<K,? extends V> m)?","the return of Collections.unmodifiableSortedMap(SortedMap<K,? extends V> m) should be an unmodifiable view of the specified sorted map. This method allows modules to provide users with ""read-only"" access to internal sorted maps. Query operations on the returned sorted map ""read through"" to the specified sorted map. Attempts to modify the returned sorted map, whether direct, via its collection views, or via its subMap, headMap, or tailMap views, result in an UnsupportedOperationException..","['return', 'Collections.unmodifiableSortedMap(SortedMap<K,? extends V> m)']"
"Collections.unmodifiableNavigableMap(NavigableMap<K,? extends V> m)","what's the return of Collections.unmodifiableNavigableMap(NavigableMap<K,? extends V> m)?","the return of Collections.unmodifiableNavigableMap(NavigableMap<K,? extends V> m) should be an unmodifiable view of the specified navigable map. This method allows modules to provide users with ""read-only"" access to internal navigable maps. Query operations on the returned navigable map ""read through"" to the specified navigable map. Attempts to modify the returned navigable map, whether direct, via its collection views, or via its subMap, headMap, or tailMap views, result in an UnsupportedOperationException..","['return', 'Collections.unmodifiableNavigableMap(NavigableMap<K,? extends V> m)']"
Collections.synchronizedCollection(Collection<T> c),what's the return of Collections.synchronizedCollection(Collection<T> c)?,"the return of Collections.synchronizedCollection(Collection<T> c) should be a synchronized (thread-safe) collection backed by the specified collection. In order to guarantee serial access, it is critical that all access to the backing collection is accomplished through the returned collection. Collection c = Collections.synchronizedCollection(myCollection); ... synchronized (c) { Iterator i = c.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); } Failure to follow this advice may result in non-deterministic behavior..","['return', 'Collections.synchronizedCollection(Collection<T> c)']"
Collections.synchronizedSet(Set<T> s),what's the return of Collections.synchronizedSet(Set<T> s)?,"the return of Collections.synchronizedSet(Set<T> s) should be a synchronized (thread-safe) set backed by the specified set. In order to guarantee serial access, it is critical that all access to the backing set is accomplished through the returned set. Set s = Collections.synchronizedSet(new HashSet()); ... synchronized (s) { Iterator i = s.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); } Failure to follow this advice may result in non-deterministic behavior..","['return', 'Collections.synchronizedSet(Set<T> s)']"
Collections.synchronizedSortedSet(SortedSet<T> s),what's the return of Collections.synchronizedSortedSet(SortedSet<T> s)?,"the return of Collections.synchronizedSortedSet(SortedSet<T> s) should be a synchronized (thread-safe) sorted set backed by the specified sorted set. In order to guarantee serial access, it is critical that all access to the backing sorted set is accomplished through the returned sorted set (or its views). SortedSet s = Collections.synchronizedSortedSet(new TreeSet()); ... synchronized (s) { Iterator i = s.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); } or: SortedSet s = Collections.synchronizedSortedSet(new TreeSet()); SortedSet s2 = s.headSet(foo); ... synchronized (s) { // Note: s, not s2!!! Iterator i = s2.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); } Failure to follow this advice may result in non-deterministic behavior..","['return', 'Collections.synchronizedSortedSet(SortedSet<T> s)']"
Collections.synchronizedNavigableSet(NavigableSet<T> s),what's the return of Collections.synchronizedNavigableSet(NavigableSet<T> s)?,"the return of Collections.synchronizedNavigableSet(NavigableSet<T> s) should be a synchronized (thread-safe) navigable set backed by the specified navigable set. In order to guarantee serial access, it is critical that all access to the backing navigable set is accomplished through the returned navigable set (or its views). NavigableSet s = Collections.synchronizedNavigableSet(new TreeSet()); ... synchronized (s) { Iterator i = s.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); } or: NavigableSet s = Collections.synchronizedNavigableSet(new TreeSet()); NavigableSet s2 = s.headSet(foo, true); ... synchronized (s) { // Note: s, not s2!!! Iterator i = s2.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); } Failure to follow this advice may result in non-deterministic behavior..","['return', 'Collections.synchronizedNavigableSet(NavigableSet<T> s)']"
Collections.synchronizedList(List<T> list),what's the return of Collections.synchronizedList(List<T> list)?,"the return of Collections.synchronizedList(List<T> list) should be a synchronized (thread-safe) list backed by the specified list. In order to guarantee serial access, it is critical that all access to the backing list is accomplished through the returned list. List list = Collections.synchronizedList(new ArrayList()); ... synchronized (list) { Iterator i = list.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); } Failure to follow this advice may result in non-deterministic behavior..","['return', 'Collections.synchronizedList(List<T> list)']"
"Collections.synchronizedMap(Map<K,V> m)","what's the return of Collections.synchronizedMap(Map<K,V> m)?","the return of Collections.synchronizedMap(Map<K,V> m) should be a synchronized (thread-safe) map backed by the specified map. In order to guarantee serial access, it is critical that all access to the backing map is accomplished through the returned map. Map m = Collections.synchronizedMap(new HashMap()); ... Set s = m.keySet(); // Needn't be in synchronized block ... synchronized (m) { // Synchronizing on m, not s! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); } Failure to follow this advice may result in non-deterministic behavior..","['return', 'Collections.synchronizedMap(Map<K,V> m)']"
"Collections.synchronizedSortedMap(SortedMap<K,V> m)","what's the return of Collections.synchronizedSortedMap(SortedMap<K,V> m)?","the return of Collections.synchronizedSortedMap(SortedMap<K,V> m) should be a synchronized (thread-safe) sorted map backed by the specified sorted map. In order to guarantee serial access, it is critical that all access to the backing sorted map is accomplished through the returned sorted map (or its views). SortedMap m = Collections.synchronizedSortedMap(new TreeMap()); ... Set s = m.keySet(); // Needn't be in synchronized block ... synchronized (m) { // Synchronizing on m, not s! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); } or: SortedMap m = Collections.synchronizedSortedMap(new TreeMap()); SortedMap m2 = m.subMap(foo, bar); ... Set s2 = m2.keySet(); // Needn't be in synchronized block ... synchronized (m) { // Synchronizing on m, not m2 or s2! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); } Failure to follow this advice may result in non-deterministic behavior..","['return', 'Collections.synchronizedSortedMap(SortedMap<K,V> m)']"
"Collections.synchronizedNavigableMap(NavigableMap<K,V> m)","what's the return of Collections.synchronizedNavigableMap(NavigableMap<K,V> m)?","the return of Collections.synchronizedNavigableMap(NavigableMap<K,V> m) should be a synchronized (thread-safe) navigable map backed by the specified navigable map. In order to guarantee serial access, it is critical that all access to the backing navigable map is accomplished through the returned navigable map (or its views). NavigableMap m = Collections.synchronizedNavigableMap(new TreeMap()); ... Set s = m.keySet(); // Needn't be in synchronized block ... synchronized (m) { // Synchronizing on m, not s! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); } or: NavigableMap m = Collections.synchronizedNavigableMap(new TreeMap()); NavigableMap m2 = m.subMap(foo, true, bar, false); ... Set s2 = m2.keySet(); // Needn't be in synchronized block ... synchronized (m) { // Synchronizing on m, not m2 or s2! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); } Failure to follow this advice may result in non-deterministic behavior..","['return', 'Collections.synchronizedNavigableMap(NavigableMap<K,V> m)']"
"Collections.checkedCollection(Collection<E> c, Class<E> type)","what's the return of Collections.checkedCollection(Collection<E> c, Class<E> type)?","the return of Collections.checkedCollection(Collection<E> c, Class<E> type) should be a dynamically typesafe view of the specified collection. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a collection contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the collection takes place through the view, it is guaranteed that the collection cannot contain an incorrectly typed element. Collection<String> c = new HashSet<>(); may be replaced temporarily by this one: Collection<String> c = Collections.checkedCollection( new HashSet<>(), String.class); Running the program again will cause it to fail at the point where an incorrectly typed element is inserted into the collection, clearly identifying the source of the problem. Once the problem is fixed, the modified declaration may be reverted back to the original..","['return', 'Collections.checkedCollection(Collection<E> c, Class<E> type)']"
"Collections.checkedQueue(Queue<E> queue, Class<E> type)","what's the return of Collections.checkedQueue(Queue<E> queue, Class<E> type)?","the return of Collections.checkedQueue(Queue<E> queue, Class<E> type) should be a dynamically typesafe view of the specified queue. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a queue contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the queue takes place through the view, it is guaranteed that the queue cannot contain an incorrectly typed element..","['return', 'Collections.checkedQueue(Queue<E> queue, Class<E> type)']"
"Collections.checkedSet(Set<E> s, Class<E> type)","what's the return of Collections.checkedSet(Set<E> s, Class<E> type)?","the return of Collections.checkedSet(Set<E> s, Class<E> type) should be a dynamically typesafe view of the specified set. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a set contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the set takes place through the view, it is guaranteed that the set cannot contain an incorrectly typed element..","['return', 'Collections.checkedSet(Set<E> s, Class<E> type)']"
"Collections.checkedSortedSet(SortedSet<E> s, Class<E> type)","what's the return of Collections.checkedSortedSet(SortedSet<E> s, Class<E> type)?","the return of Collections.checkedSortedSet(SortedSet<E> s, Class<E> type) should be a dynamically typesafe view of the specified sorted set. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a sorted set contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the sorted set takes place through the view, it is guaranteed that the sorted set cannot contain an incorrectly typed element..","['return', 'Collections.checkedSortedSet(SortedSet<E> s, Class<E> type)']"
"Collections.checkedNavigableSet(NavigableSet<E> s, Class<E> type)","what's the return of Collections.checkedNavigableSet(NavigableSet<E> s, Class<E> type)?","the return of Collections.checkedNavigableSet(NavigableSet<E> s, Class<E> type) should be a dynamically typesafe view of the specified navigable set. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a navigable set contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the navigable set takes place through the view, it is guaranteed that the navigable set cannot contain an incorrectly typed element..","['return', 'Collections.checkedNavigableSet(NavigableSet<E> s, Class<E> type)']"
"Collections.checkedList(List<E> list, Class<E> type)","what's the return of Collections.checkedList(List<E> list, Class<E> type)?","the return of Collections.checkedList(List<E> list, Class<E> type) should be a dynamically typesafe view of the specified list. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a list contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the list takes place through the view, it is guaranteed that the list cannot contain an incorrectly typed element..","['return', 'Collections.checkedList(List<E> list, Class<E> type)']"
"Collections.checkedMap(Map<K,V> m, Class<K> keyType, Class<V> valueType)","what's the return of Collections.checkedMap(Map<K,V> m, Class<K> keyType, Class<V> valueType)?","the return of Collections.checkedMap(Map<K,V> m, Class<K> keyType, Class<V> valueType) should be a dynamically typesafe view of the specified map. Any attempt to insert a mapping whose key or value have the wrong type will result in an immediate ClassCastException. Similarly, any attempt to modify the value currently associated with a key will result in an immediate ClassCastException, whether the modification is attempted directly through the map itself, or through a Map.Entry instance obtained from the map's entry set view..","['return', 'Collections.checkedMap(Map<K,V> m, Class<K> keyType, Class<V> valueType)']"
"Collections.checkedSortedMap(SortedMap<K,V> m, Class<K> keyType, Class<V> valueType)","what's the return of Collections.checkedSortedMap(SortedMap<K,V> m, Class<K> keyType, Class<V> valueType)?","the return of Collections.checkedSortedMap(SortedMap<K,V> m, Class<K> keyType, Class<V> valueType) should be a dynamically typesafe view of the specified sorted map. Any attempt to insert a mapping whose key or value have the wrong type will result in an immediate ClassCastException. Similarly, any attempt to modify the value currently associated with a key will result in an immediate ClassCastException, whether the modification is attempted directly through the map itself, or through a Map.Entry instance obtained from the map's entry set view..","['return', 'Collections.checkedSortedMap(SortedMap<K,V> m, Class<K> keyType, Class<V> valueType)']"
"Collections.checkedNavigableMap(NavigableMap<K,V> m, Class<K> keyType, Class<V> valueType)","what's the return of Collections.checkedNavigableMap(NavigableMap<K,V> m, Class<K> keyType, Class<V> valueType)?","the return of Collections.checkedNavigableMap(NavigableMap<K,V> m, Class<K> keyType, Class<V> valueType) should be a dynamically typesafe view of the specified navigable map. Any attempt to insert a mapping whose key or value have the wrong type will result in an immediate ClassCastException. Similarly, any attempt to modify the value currently associated with a key will result in an immediate ClassCastException, whether the modification is attempted directly through the map itself, or through a Map.Entry instance obtained from the map's entry set view..","['return', 'Collections.checkedNavigableMap(NavigableMap<K,V> m, Class<K> keyType, Class<V> valueType)']"
Collections.emptyIterator(),what's the return of Collections.emptyIterator()?,"the return of Collections.emptyIterator() should be an iterator that has no elements. More precisely, hasNext always returns false. next always throws NoSuchElementException. remove always throws IllegalStateException..","['return', 'Collections.emptyIterator()']"
Collections.emptyListIterator(),what's the return of Collections.emptyListIterator()?,"the return of Collections.emptyListIterator() should be a list iterator that has no elements. More precisely, hasNext and hasPrevious always return false. next and previous always throw NoSuchElementException. remove and set always throw IllegalStateException. add always throws UnsupportedOperationException. nextIndex always returns 0. previousIndex always returns -1..","['return', 'Collections.emptyListIterator()']"
Collections.emptyEnumeration(),what's the return of Collections.emptyEnumeration()?,"the return of Collections.emptyEnumeration() should be an enumeration that has no elements. More precisely, hasMoreElements always returns false. nextElement always throws NoSuchElementException..","['return', 'Collections.emptyEnumeration()']"
Collections.emptySet(),what's the return of Collections.emptySet()?,"the return of Collections.emptySet() should be an empty set (immutable). This set is serializable. Unlike the like-named field, this method is parameterized. Set<String> s = Collections.emptySet();.","['return', 'Collections.emptySet()']"
Collections.emptySortedSet(),what's the return of Collections.emptySortedSet()?,the return of Collections.emptySortedSet() should be an empty sorted set (immutable). This set is serializable. SortedSet<String> s = Collections.emptySortedSet();.,"['return', 'Collections.emptySortedSet()']"
Collections.emptyNavigableSet(),what's the return of Collections.emptyNavigableSet()?,the return of Collections.emptyNavigableSet() should be an empty navigable set (immutable). This set is serializable. NavigableSet<String> s = Collections.emptyNavigableSet();.,"['return', 'Collections.emptyNavigableSet()']"
Collections.emptyList(),what's the return of Collections.emptyList()?,the return of Collections.emptyList() should be an empty list (immutable). This list is serializable. List<String> s = Collections.emptyList();.,"['return', 'Collections.emptyList()']"
Collections.emptyMap(),what's the return of Collections.emptyMap()?,"the return of Collections.emptyMap() should be an empty map (immutable). This map is serializable. Map<String, Date> s = Collections.emptyMap();.","['return', 'Collections.emptyMap()']"
Collections.emptySortedMap(),what's the return of Collections.emptySortedMap()?,"the return of Collections.emptySortedMap() should be an empty sorted map (immutable). This map is serializable. SortedMap<String, Date> s = Collections.emptySortedMap();.","['return', 'Collections.emptySortedMap()']"
Collections.emptyNavigableMap(),what's the return of Collections.emptyNavigableMap()?,"the return of Collections.emptyNavigableMap() should be an empty navigable map (immutable). This map is serializable. NavigableMap<String, Date> s = Collections.emptyNavigableMap();.","['return', 'Collections.emptyNavigableMap()']"
Collections.singleton(T o),what's the return of Collections.singleton(T o)?,the return of Collections.singleton(T o) should be an immutable set containing only the specified object. The returned set is serializable..,"['return', 'Collections.singleton(T o)']"
Collections.singletonList(T o),what's the return of Collections.singletonList(T o)?,the return of Collections.singletonList(T o) should be an immutable list containing only the specified object. The returned list is serializable..,"['return', 'Collections.singletonList(T o)']"
"Collections.singletonMap(K key, V value)","what's the return of Collections.singletonMap(K key, V value)?","the return of Collections.singletonMap(K key, V value) should be an immutable map, mapping only the specified key to the specified value. The returned map is serializable..","['return', 'Collections.singletonMap(K key, V value)']"
"Collections.nCopies(int n, T o)","what's the return of Collections.nCopies(int n, T o)?","the return of Collections.nCopies(int n, T o) should be an immutable list consisting of n copies of the specified object. The newly allocated data object is tiny (it contains a single reference to the data object). This method is useful in combination with the List.addAll method to grow lists. The returned list is serializable..","['return', 'Collections.nCopies(int n, T o)']"
Collections.reverseOrder(),what's the return of Collections.reverseOrder()?,"the return of Collections.reverseOrder() should be a comparator that imposes the reverse of the natural ordering on a collection of objects that implement the Comparable interface. (The natural ordering is the ordering imposed by the objects' own compareTo method.) This enables a simple idiom for sorting (or maintaining) collections (or arrays) of objects that implement the Comparable interface in reverse-natural-order. For example, suppose a is an array of strings. Then: Arrays.sort(a, Collections.reverseOrder()); sorts the array in reverse-lexicographic (alphabetical) order..","['return', 'Collections.reverseOrder()']"
Collections.reverseOrder(Comparator<T> cmp),what's the return of Collections.reverseOrder(Comparator<T> cmp)?,"the return of Collections.reverseOrder(Comparator<T> cmp) should be a comparator that imposes the reverse ordering of the specified comparator. If the specified comparator is null, this method is equivalent to reverseOrder() (in other words, it returns a comparator that imposes the reverse of the natural ordering on a collection of objects that implement the Comparable interface)..","['return', 'Collections.reverseOrder(Comparator<T> cmp)']"
Collections.enumeration(Collection<T> c),what's the return of Collections.enumeration(Collection<T> c)?,the return of Collections.enumeration(Collection<T> c) should be an enumeration over the specified collection. This provides interoperability with legacy APIs that require an enumeration as input..,"['return', 'Collections.enumeration(Collection<T> c)']"
Collections.list(Enumeration<T> e),what's the return of Collections.list(Enumeration<T> e)?,the return of Collections.list(Enumeration<T> e) should be an array list containing the elements returned by the specified enumeration in the order they are returned by the enumeration. This method provides interoperability between legacy APIs that return enumerations and new APIs that require collections..,"['return', 'Collections.list(Enumeration<T> e)']"
"Collections.frequency(Collection<?> c, Object o)","what's the return of Collections.frequency(Collection<?> c, Object o)?","the return of Collections.frequency(Collection<?> c, Object o) should be the number of elements in the specified collection equal to the specified object. More formally, returns the number of elements e in the collection such that (o == null ? e == null : o.equals(e))..","['return', 'Collections.frequency(Collection<?> c, Object o)']"
"Collections.frequency(Collection<?> c, Object o)","what's the parameter of Collections.frequency(Collection<?> c, Object o)?","the parameter of Collections.frequency(Collection<?> c, Object o) should be  the collection in which to determine the frequency
     of o.","['parameter', 'Collections.frequency(Collection<?> c, Object o)']"
"Collections.disjoint(Collection<?> c1, Collection<?> c2)","what's the return of Collections.disjoint(Collection<?> c1, Collection<?> c2)?","the return of Collections.disjoint(Collection<?> c1, Collection<?> c2) should be true if the two specified collections have no elements in common..","['return', 'Collections.disjoint(Collection<?> c1, Collection<?> c2)']"
"Collections.addAll(Collection<? super T> c, T... elements)","what's the return of Collections.addAll(Collection<? super T> c, T... elements)?","the return of Collections.addAll(Collection<? super T> c, T... elements) should be elements - the elements to insert into c.","['return', 'Collections.addAll(Collection<? super T> c, T... elements)']"
"Collections.newSetFromMap(Map<E,Boolean> map)","what's the return of Collections.newSetFromMap(Map<E,Boolean> map)?","the return of Collections.newSetFromMap(Map<E,Boolean> map) should be a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>());.","['return', 'Collections.newSetFromMap(Map<E,Boolean> map)']"
Collections.asLifoQueue(Deque<T> deque),what's the return of Collections.asLifoQueue(Deque<T> deque)?,"the return of Collections.asLifoQueue(Deque<T> deque) should be a view of a Deque as a Last-in-first-out (Lifo) Queue. Method add is mapped to push, remove is mapped to pop and so on. This view can be useful when you would like to use a method requiring a Queue but you need Lifo ordering..","['return', 'Collections.asLifoQueue(Deque<T> deque)']"
"Comparator.compare(T o1, T o2)","what's the return of Comparator.compare(T o1, T o2)?","the return of Comparator.compare(T o1, T o2) should be o2 - the second object to be compared..","['return', 'Comparator.compare(T o1, T o2)']"
"Comparator.compare(T o1, T o2)","what's the parameter of Comparator.compare(T o1, T o2)?","the parameter of Comparator.compare(T o1, T o2) should be  the first object to be compared..","['parameter', 'Comparator.compare(T o1, T o2)']"
Object.equals(Object obj),what's the return of Object.equals(Object obj)?,"the return of Object.equals(Object obj) should be true if the objects are the same;
          false otherwise..","['return', 'Object.equals(Object obj)']"
Object.equals(Object obj),what's the parameter of Object.equals(Object obj)?,the parameter of Object.equals(Object obj) should be  the object to compare with..,"['parameter', 'Object.equals(Object obj)']"
Comparator.reversed(),what's the return of Comparator.reversed()?,the return of Comparator.reversed() should be a comparator that imposes the reverse ordering of this comparator..,"['return', 'Comparator.reversed()']"
Comparator.thenComparing(Comparator<? super T> other),what's the return of Comparator.thenComparing(Comparator<? super T> other)?,"the return of Comparator.thenComparing(Comparator<? super T> other) should be a lexicographic-order comparator with another comparator. If this Comparator considers two elements equal, i.e. compare(a, b) == 0, other is used to determine the order..","['return', 'Comparator.thenComparing(Comparator<? super T> other)']"
"Comparator.thenComparing(Function<? super T,? extends U> keyExtractor, Comparator<? super U> keyComparator)","what's the return of Comparator.thenComparing(Function<? super T,? extends U> keyExtractor, Comparator<? super U> keyComparator)?","the return of Comparator.thenComparing(Function<? super T,? extends U> keyExtractor, Comparator<? super U> keyComparator) should be a lexicographic-order comparator with a function that extracts a key to be compared with the given Comparator..","['return', 'Comparator.thenComparing(Function<? super T,? extends U> keyExtractor, Comparator<? super U> keyComparator)']"
"Comparator.thenComparing(Function<? super T,? extends U> keyExtractor, Comparator<? super U> keyComparator)","what's the parameter of Comparator.thenComparing(Function<? super T,? extends U> keyExtractor, Comparator<? super U> keyComparator)?","the parameter of Comparator.thenComparing(Function<? super T,? extends U> keyExtractor, Comparator<? super U> keyComparator) should be  the function used to extract the sort key.","['parameter', 'Comparator.thenComparing(Function<? super T,? extends U> keyExtractor, Comparator<? super U> keyComparator)']"
"Comparator.thenComparing(Function<? super T,? extends U> keyExtractor)","what's the return of Comparator.thenComparing(Function<? super T,? extends U> keyExtractor)?","the return of Comparator.thenComparing(Function<? super T,? extends U> keyExtractor) should be a lexicographic-order comparator with a function that extracts a Comparable sort key..","['return', 'Comparator.thenComparing(Function<? super T,? extends U> keyExtractor)']"
"Comparator.thenComparing(Function<? super T,? extends U> keyExtractor)","what's the parameter of Comparator.thenComparing(Function<? super T,? extends U> keyExtractor)?","the parameter of Comparator.thenComparing(Function<? super T,? extends U> keyExtractor) should be  the function used to extract the Comparable sort key.","['parameter', 'Comparator.thenComparing(Function<? super T,? extends U> keyExtractor)']"
Comparator.thenComparingInt(ToIntFunction<? super T> keyExtractor),what's the return of Comparator.thenComparingInt(ToIntFunction<? super T> keyExtractor)?,the return of Comparator.thenComparingInt(ToIntFunction<? super T> keyExtractor) should be a lexicographic-order comparator with a function that extracts a int sort key..,"['return', 'Comparator.thenComparingInt(ToIntFunction<? super T> keyExtractor)']"
Comparator.thenComparingLong(ToLongFunction<? super T> keyExtractor),what's the return of Comparator.thenComparingLong(ToLongFunction<? super T> keyExtractor)?,the return of Comparator.thenComparingLong(ToLongFunction<? super T> keyExtractor) should be a lexicographic-order comparator with a function that extracts a long sort key..,"['return', 'Comparator.thenComparingLong(ToLongFunction<? super T> keyExtractor)']"
Comparator.thenComparingDouble(ToDoubleFunction<? super T> keyExtractor),what's the return of Comparator.thenComparingDouble(ToDoubleFunction<? super T> keyExtractor)?,the return of Comparator.thenComparingDouble(ToDoubleFunction<? super T> keyExtractor) should be a lexicographic-order comparator with a function that extracts a double sort key..,"['return', 'Comparator.thenComparingDouble(ToDoubleFunction<? super T> keyExtractor)']"
Comparator.reverseOrder(),what's the return of Comparator.reverseOrder()?,the return of Comparator.reverseOrder() should be a comparator that imposes the reverse of the natural ordering..,"['return', 'Comparator.reverseOrder()']"
Comparator.naturalOrder(),what's the return of Comparator.naturalOrder()?,the return of Comparator.naturalOrder() should be a comparator that compares Comparable objects in natural order..,"['return', 'Comparator.naturalOrder()']"
Comparator.nullsFirst(Comparator<? super T> comparator),what's the return of Comparator.nullsFirst(Comparator<? super T> comparator)?,"the return of Comparator.nullsFirst(Comparator<? super T> comparator) should be a null-friendly comparator that considers null to be less than non-null. When both are null, they are considered equal. If both are non-null, the specified Comparator is used to determine the order. If the specified comparator is null, then the returned comparator considers all non-null values to be equal..","['return', 'Comparator.nullsFirst(Comparator<? super T> comparator)']"
Comparator.nullsLast(Comparator<? super T> comparator),what's the return of Comparator.nullsLast(Comparator<? super T> comparator)?,"the return of Comparator.nullsLast(Comparator<? super T> comparator) should be a null-friendly comparator that considers null to be greater than non-null. When both are null, they are considered equal. If both are non-null, the specified Comparator is used to determine the order. If the specified comparator is null, then the returned comparator considers all non-null values to be equal..","['return', 'Comparator.nullsLast(Comparator<? super T> comparator)']"
"Comparator.comparing(Function<? super T,? extends U> keyExtractor, Comparator<? super U> keyComparator)","what's the return of Comparator.comparing(Function<? super T,? extends U> keyExtractor, Comparator<? super U> keyComparator)?","the return of Comparator.comparing(Function<? super T,? extends U> keyExtractor, Comparator<? super U> keyComparator) should be keyExtractor - the function used to extract the sort key.","['return', 'Comparator.comparing(Function<? super T,? extends U> keyExtractor, Comparator<? super U> keyComparator)']"
"Comparator.comparing(Function<? super T,? extends U> keyExtractor)","what's the return of Comparator.comparing(Function<? super T,? extends U> keyExtractor)?","the return of Comparator.comparing(Function<? super T,? extends U> keyExtractor) should be keyExtractor - the function used to extract the Comparable sort key.","['return', 'Comparator.comparing(Function<? super T,? extends U> keyExtractor)']"
Comparator.comparingInt(ToIntFunction<? super T> keyExtractor),what's the return of Comparator.comparingInt(ToIntFunction<? super T> keyExtractor)?,the return of Comparator.comparingInt(ToIntFunction<? super T> keyExtractor) should be a comparator that compares by an extracted key.,"['return', 'Comparator.comparingInt(ToIntFunction<? super T> keyExtractor)']"
Comparator.comparingLong(ToLongFunction<? super T> keyExtractor),what's the return of Comparator.comparingLong(ToLongFunction<? super T> keyExtractor)?,the return of Comparator.comparingLong(ToLongFunction<? super T> keyExtractor) should be a comparator that compares by an extracted key.,"['return', 'Comparator.comparingLong(ToLongFunction<? super T> keyExtractor)']"
Comparator.comparingDouble(ToDoubleFunction<? super T> keyExtractor),what's the return of Comparator.comparingDouble(ToDoubleFunction<? super T> keyExtractor)?,the return of Comparator.comparingDouble(ToDoubleFunction<? super T> keyExtractor) should be a comparator that compares by an extracted key.,"['return', 'Comparator.comparingDouble(ToDoubleFunction<? super T> keyExtractor)']"
Currency.getInstance(String currencyCode),what's the return of Currency.getInstance(String currencyCode)?,the return of Currency.getInstance(String currencyCode) should be the Currency instance for the given currency code..,"['return', 'Currency.getInstance(String currencyCode)']"
Currency.getInstance(String currencyCode),what's the parameter of Currency.getInstance(String currencyCode)?,the parameter of Currency.getInstance(String currencyCode) should be  the ISO 4217 code of the currency.,"['parameter', 'Currency.getInstance(String currencyCode)']"
Currency.getInstance(Locale locale),what's the return of Currency.getInstance(Locale locale)?,"the return of Currency.getInstance(Locale locale) should be the Currency instance for the country of the given locale. The language and variant components of the locale are ignored. The result may vary over time, as countries change their currencies. For example, for the original member countries of the European Monetary Union, the method returns the old national currencies until December 31, 2001, and the Euro from January 1, 2002, local time of the respective countries..","['return', 'Currency.getInstance(Locale locale)']"
Currency.getInstance(Locale locale),what's the parameter of Currency.getInstance(Locale locale)?,"the parameter of Currency.getInstance(Locale locale) should be  the locale for whose country a Currency
 instance is needed.","['parameter', 'Currency.getInstance(Locale locale)']"
Currency.getAvailableCurrencies(),what's the return of Currency.getAvailableCurrencies()?,"the return of Currency.getAvailableCurrencies() should be the set of available currencies.  If there is no currency
    available in the runtime, the returned set is empty..","['return', 'Currency.getAvailableCurrencies()']"
Currency.getCurrencyCode(),what's the return of Currency.getCurrencyCode()?,the return of Currency.getCurrencyCode() should be the ISO 4217 currency code of this currency..,"['return', 'Currency.getCurrencyCode()']"
Currency.getSymbol(),what's the return of Currency.getSymbol()?,"the return of Currency.getSymbol() should be the symbol of this currency for the default
     DISPLAY locale.","['return', 'Currency.getSymbol()']"
Currency.getSymbol(Locale locale),what's the return of Currency.getSymbol(Locale locale)?,the return of Currency.getSymbol(Locale locale) should be the symbol of this currency for the specified locale.,"['return', 'Currency.getSymbol(Locale locale)']"
Currency.getSymbol(Locale locale),what's the parameter of Currency.getSymbol(Locale locale)?,"the parameter of Currency.getSymbol(Locale locale) should be  the locale for which a display name for this currency is
 needed.","['parameter', 'Currency.getSymbol(Locale locale)']"
Currency.getDefaultFractionDigits(),what's the return of Currency.getDefaultFractionDigits()?,the return of Currency.getDefaultFractionDigits() should be the default number of fraction digits used with this currency.,"['return', 'Currency.getDefaultFractionDigits()']"
Currency.getNumericCode(),what's the return of Currency.getNumericCode()?,the return of Currency.getNumericCode() should be the ISO 4217 numeric code of this currency..,"['return', 'Currency.getNumericCode()']"
Currency.getDisplayName(),what's the return of Currency.getDisplayName()?,"the return of Currency.getDisplayName() should be the display name of this currency for the default
     DISPLAY locale.","['return', 'Currency.getDisplayName()']"
Currency.getDisplayName(Locale locale),what's the return of Currency.getDisplayName(Locale locale)?,the return of Currency.getDisplayName(Locale locale) should be the display name of this currency for the specified locale.,"['return', 'Currency.getDisplayName(Locale locale)']"
Currency.getDisplayName(Locale locale),what's the parameter of Currency.getDisplayName(Locale locale)?,"the parameter of Currency.getDisplayName(Locale locale) should be  the locale for which a display name for this currency is
 needed.","['parameter', 'Currency.getDisplayName(Locale locale)']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
Object.clone(),what's the return of Object.clone()?,the return of Object.clone() should be a shallow copy of this AbstractMap instance: the keys and values themselves are not cloned..,"['return', 'Object.clone()']"
"Date.UTC(int year, int month, int date, int hrs, int min, int sec)","what's the return of Date.UTC(int year, int month, int date, int hrs, int min, int sec)?","the return of Date.UTC(int year, int month, int date, int hrs, int min, int sec) should be month - the month between 0-11..","['return', 'Date.UTC(int year, int month, int date, int hrs, int min, int sec)']"
Date.parse(String s),what's the return of Date.parse(String s)?,"the return of Date.parse(String s) should be the number of milliseconds since January 1, 1970, 00:00:00 GMT
          represented by the string argument..","['return', 'Date.parse(String s)']"
Date.parse(String s),what's the parameter of Date.parse(String s)?,the parameter of Date.parse(String s) should be  a string to be parsed as a date..,"['parameter', 'Date.parse(String s)']"
Date.getYear(),what's the return of Date.getYear()?,"the return of Date.getYear() should be the year represented by this date, minus 1900..","['return', 'Date.getYear()']"
Date.getMonth(),what's the return of Date.getMonth()?,the return of Date.getMonth() should be the month represented by this date..,"['return', 'Date.getMonth()']"
Date.getDate(),what's the return of Date.getDate()?,the return of Date.getDate() should be the day of the month represented by this date..,"['return', 'Date.getDate()']"
Date.getDay(),what's the return of Date.getDay()?,the return of Date.getDay() should be the day of the week represented by this date..,"['return', 'Date.getDay()']"
Date.getHours(),what's the return of Date.getHours()?,the return of Date.getHours() should be the hour represented by this date..,"['return', 'Date.getHours()']"
Date.getMinutes(),what's the return of Date.getMinutes()?,the return of Date.getMinutes() should be the number of minutes past the hour represented by this date..,"['return', 'Date.getMinutes()']"
Date.getSeconds(),what's the return of Date.getSeconds()?,the return of Date.getSeconds() should be the number of seconds past the minute represented by this date..,"['return', 'Date.getSeconds()']"
Date.getTime(),what's the return of Date.getTime()?,"the return of Date.getTime() should be the number of milliseconds since January 1, 1970, 00:00:00 GMT represented by this Date object..","['return', 'Date.getTime()']"
Date.before(Date when),what's the return of Date.before(Date when)?,"the return of Date.before(Date when) should be true if and only if the instant of time
            represented by this Date object is strictly
            earlier than the instant represented by when;
          false otherwise..","['return', 'Date.before(Date when)']"
Date.before(Date when),what's the parameter of Date.before(Date when)?,the parameter of Date.before(Date when) should be  a date..,"['parameter', 'Date.before(Date when)']"
Date.after(Date when),what's the return of Date.after(Date when)?,"the return of Date.after(Date when) should be true if and only if the instant represented
          by this Date object is strictly later than the
          instant represented by when;
          false otherwise..","['return', 'Date.after(Date when)']"
Date.after(Date when),what's the parameter of Date.after(Date when)?,the parameter of Date.after(Date when) should be  a date..,"['parameter', 'Date.after(Date when)']"
Object.equals(Object obj),what's the return of Object.equals(Object obj)?,"the return of Object.equals(Object obj) should be true if the objects are the same;
          false otherwise..","['return', 'Object.equals(Object obj)']"
Object.equals(Object obj),what's the parameter of Object.equals(Object obj)?,the parameter of Object.equals(Object obj) should be  the object to compare with..,"['parameter', 'Object.equals(Object obj)']"
Comparable.compareTo(Date anotherDate),what's the return of Comparable.compareTo(Date anotherDate)?,"the return of Comparable.compareTo(Date anotherDate) should be the value 0 if the argument Date is equal to
          this Date; a value less than 0 if this Date
          is before the Date argument; and a value greater than
      0 if this Date is after the Date argument..","['return', 'Comparable.compareTo(Date anotherDate)']"
Comparable.compareTo(Date anotherDate),what's the parameter of Comparable.compareTo(Date anotherDate)?,the parameter of Comparable.compareTo(Date anotherDate) should be  the Date to be compared..,"['parameter', 'Comparable.compareTo(Date anotherDate)']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
Date.toLocaleString(),what's the return of Date.toLocaleString()?,"the return of Date.toLocaleString() should be a string representation of this date, using the locale
          conventions..","['return', 'Date.toLocaleString()']"
Date.toGMTString(),what's the return of Date.toGMTString()?,"the return of Date.toGMTString() should be a string representation of this date, using the Internet GMT
          conventions..","['return', 'Date.toGMTString()']"
Date.getTimezoneOffset(),what's the return of Date.getTimezoneOffset()?,"the return of Date.getTimezoneOffset() should be the time-zone offset, in minutes, for the current time zone..","['return', 'Date.getTimezoneOffset()']"
Date.from(Instant instant),what's the return of Date.from(Instant instant)?,"the return of Date.from(Instant instant) should be a Date representing the same point on the time-line as
  the provided instant.","['return', 'Date.from(Instant instant)']"
Date.from(Instant instant),what's the parameter of Date.from(Instant instant)?,the parameter of Date.from(Instant instant) should be  the instant to convert.,"['parameter', 'Date.from(Instant instant)']"
Date.toInstant(),what's the return of Date.toInstant()?,"the return of Date.toInstant() should be an instant representing the same point on the time-line as
  this Date object.","['return', 'Date.toInstant()']"
Deque.addFirst(E e),what's the parameter of Deque.addFirst(E e)?,the parameter of Deque.addFirst(E e) should be  the element to add.,"['parameter', 'Deque.addFirst(E e)']"
Deque.addLast(E e),what's the parameter of Deque.addLast(E e)?,the parameter of Deque.addLast(E e) should be  the element to add.,"['parameter', 'Deque.addLast(E e)']"
Deque.offerFirst(E e),what's the return of Deque.offerFirst(E e)?,"the return of Deque.offerFirst(E e) should be true if the element was added to this deque, else
         false.","['return', 'Deque.offerFirst(E e)']"
Deque.offerFirst(E e),what's the parameter of Deque.offerFirst(E e)?,the parameter of Deque.offerFirst(E e) should be  the element to add.,"['parameter', 'Deque.offerFirst(E e)']"
Deque.offerLast(E e),what's the return of Deque.offerLast(E e)?,"the return of Deque.offerLast(E e) should be true if the element was added to this deque, else
         false.","['return', 'Deque.offerLast(E e)']"
Deque.offerLast(E e),what's the parameter of Deque.offerLast(E e)?,the parameter of Deque.offerLast(E e) should be  the element to add.,"['parameter', 'Deque.offerLast(E e)']"
Deque.removeFirst(),what's the return of Deque.removeFirst()?,the return of Deque.removeFirst() should be the head of this deque.,"['return', 'Deque.removeFirst()']"
Deque.removeLast(),what's the return of Deque.removeLast()?,the return of Deque.removeLast() should be the tail of this deque.,"['return', 'Deque.removeLast()']"
Deque.pollFirst(),what's the return of Deque.pollFirst()?,"the return of Deque.pollFirst() should be the head of this deque, or null if this deque is empty.","['return', 'Deque.pollFirst()']"
Deque.pollLast(),what's the return of Deque.pollLast()?,"the return of Deque.pollLast() should be the tail of this deque, or null if this deque is empty.","['return', 'Deque.pollLast()']"
Deque.getFirst(),what's the return of Deque.getFirst()?,the return of Deque.getFirst() should be the head of this deque.,"['return', 'Deque.getFirst()']"
Deque.getLast(),what's the return of Deque.getLast()?,the return of Deque.getLast() should be the tail of this deque.,"['return', 'Deque.getLast()']"
Deque.peekFirst(),what's the return of Deque.peekFirst()?,"the return of Deque.peekFirst() should be the head of this deque, or null if this deque is empty.","['return', 'Deque.peekFirst()']"
Deque.peekLast(),what's the return of Deque.peekLast()?,"the return of Deque.peekLast() should be the tail of this deque, or null if this deque is empty.","['return', 'Deque.peekLast()']"
Deque.removeFirstOccurrence(Object o),what's the return of Deque.removeFirstOccurrence(Object o)?,the return of Deque.removeFirstOccurrence(Object o) should be true if an element was removed as a result of this call.,"['return', 'Deque.removeFirstOccurrence(Object o)']"
Deque.removeFirstOccurrence(Object o),what's the parameter of Deque.removeFirstOccurrence(Object o)?,"the parameter of Deque.removeFirstOccurrence(Object o) should be  element to be removed from this deque, if present.","['parameter', 'Deque.removeFirstOccurrence(Object o)']"
Deque.removeLastOccurrence(Object o),what's the return of Deque.removeLastOccurrence(Object o)?,the return of Deque.removeLastOccurrence(Object o) should be true if an element was removed as a result of this call.,"['return', 'Deque.removeLastOccurrence(Object o)']"
Deque.removeLastOccurrence(Object o),what's the parameter of Deque.removeLastOccurrence(Object o)?,"the parameter of Deque.removeLastOccurrence(Object o) should be  element to be removed from this deque, if present.","['parameter', 'Deque.removeLastOccurrence(Object o)']"
Collection.add(E e),what's the return of Collection.add(E e)?,the return of Collection.add(E e) should be true (as specified by Collection.add(E)).,"['return', 'Collection.add(E e)']"
Collection.add(E e),what's the parameter of Collection.add(E e)?,the parameter of Collection.add(E e) should be  the element to add.,"['parameter', 'Collection.add(E e)']"
Queue.offer(E e),what's the return of Queue.offer(E e)?,"the return of Queue.offer(E e) should be true if the element was added to this deque, else
         false.","['return', 'Queue.offer(E e)']"
Queue.offer(E e),what's the parameter of Queue.offer(E e)?,the parameter of Queue.offer(E e) should be  the element to add.,"['parameter', 'Queue.offer(E e)']"
Queue.remove(),what's the return of Queue.remove()?,the return of Queue.remove() should be the head of the queue represented by this deque.,"['return', 'Queue.remove()']"
Queue.poll(),what's the return of Queue.poll()?,"the return of Queue.poll() should be the first element of this deque, or null if
         this deque is empty.","['return', 'Queue.poll()']"
Queue.element(),what's the return of Queue.element()?,the return of Queue.element() should be the head of the queue represented by this deque.,"['return', 'Queue.element()']"
Queue.peek(),what's the return of Queue.peek()?,"the return of Queue.peek() should be the head of the queue represented by this deque, or
         null if this deque is empty.","['return', 'Queue.peek()']"
Deque.push(E e),what's the parameter of Deque.push(E e)?,the parameter of Deque.push(E e) should be  the element to push.,"['parameter', 'Deque.push(E e)']"
Deque.pop(),what's the return of Deque.pop()?,"the return of Deque.pop() should be the element at the front of this deque (which is the top
         of the stack represented by this deque).","['return', 'Deque.pop()']"
Collection.remove(Object o),what's the return of Collection.remove(Object o)?,the return of Collection.remove(Object o) should be true if an element was removed as a result of this call.,"['return', 'Collection.remove(Object o)']"
Collection.remove(Object o),what's the parameter of Collection.remove(Object o)?,"the parameter of Collection.remove(Object o) should be  element to be removed from this deque, if present.","['parameter', 'Collection.remove(Object o)']"
Collection.contains(Object o),what's the return of Collection.contains(Object o)?,"the return of Collection.contains(Object o) should be true if this deque contains the specified element. More formally, returns true if and only if this deque contains at least one element e such that (o==null ? e==null : o.equals(e))..","['return', 'Collection.contains(Object o)']"
Collection.contains(Object o),what's the parameter of Collection.contains(Object o)?,the parameter of Collection.contains(Object o) should be  element whose presence in this deque is to be tested.,"['parameter', 'Collection.contains(Object o)']"
Collection.size(),what's the return of Collection.size()?,the return of Collection.size() should be the number of elements in this deque..,"['return', 'Collection.size()']"
Collection.iterator(),what's the return of Collection.iterator()?,the return of Collection.iterator() should be an iterator over the elements in this deque in proper sequence. The elements will be returned in order from first (head) to last (tail)..,"['return', 'Collection.iterator()']"
Deque.descendingIterator(),what's the return of Deque.descendingIterator()?,the return of Deque.descendingIterator() should be an iterator over the elements in this deque in reverse sequential order. The elements will be returned in order from last (tail) to first (head)..,"['return', 'Deque.descendingIterator()']"
Dictionary.size(),what's the return of Dictionary.size()?,the return of Dictionary.size() should be the number of entries (distinct keys) in this dictionary..,"['return', 'Dictionary.size()']"
Dictionary.isEmpty(),what's the return of Dictionary.isEmpty()?,"the return of Dictionary.isEmpty() should be true if this dictionary maps no keys to values;
          false otherwise..","['return', 'Dictionary.isEmpty()']"
Dictionary.keys(),what's the return of Dictionary.keys()?,the return of Dictionary.keys() should be an enumeration of the keys in this dictionary. The general contract for the keys method is that an Enumeration object is returned that will generate all the keys for which this dictionary contains entries..,"['return', 'Dictionary.keys()']"
Dictionary.elements(),what's the return of Dictionary.elements()?,the return of Dictionary.elements() should be an enumeration of the values in this dictionary. The general contract for the elements method is that an Enumeration is returned that will generate all the elements contained in entries in this dictionary..,"['return', 'Dictionary.elements()']"
Dictionary.get(Object key),what's the return of Dictionary.get(Object key)?,"the return of Dictionary.get(Object key) should be the value to which the key is mapped in this dictionary. The general contract for the isEmpty method is that if this dictionary contains an entry for the specified key, the associated value is returned; otherwise, null is returned..","['return', 'Dictionary.get(Object key)']"
Dictionary.get(Object key),what's the parameter of Dictionary.get(Object key)?,"the parameter of Dictionary.get(Object key) should be  a key in this dictionary.
          null if the key is not mapped to any value in
          this dictionary..","['parameter', 'Dictionary.get(Object key)']"
"Dictionary.put(K key, V value)","what's the return of Dictionary.put(K key, V value)?","the return of Dictionary.put(K key, V value) should be value - the value..","['return', 'Dictionary.put(K key, V value)']"
"Dictionary.put(K key, V value)","what's the parameter of Dictionary.put(K key, V value)?","the parameter of Dictionary.put(K key, V value) should be  the hashtable key..","['parameter', 'Dictionary.put(K key, V value)']"
Dictionary.remove(Object key),what's the return of Dictionary.remove(Object key)?,"the return of Dictionary.remove(Object key) should be the value to which the key had been mapped in this
          dictionary, or null if the key did not have a
          mapping..","['return', 'Dictionary.remove(Object key)']"
Dictionary.remove(Object key),what's the parameter of Dictionary.remove(Object key)?,the parameter of Dictionary.remove(Object key) should be  the key that needs to be removed..,"['parameter', 'Dictionary.remove(Object key)']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
Enumeration.hasMoreElements(),what's the return of Enumeration.hasMoreElements()?,"the return of Enumeration.hasMoreElements() should be true if and only if this enumeration object
           contains at least one more element to provide;
          false otherwise..","['return', 'Enumeration.hasMoreElements()']"
Enumeration.nextElement(),what's the return of Enumeration.nextElement()?,the return of Enumeration.nextElement() should be the next element of this enumeration if this enumeration object has at least one more element to provide..,"['return', 'Enumeration.nextElement()']"
Enum.size(),what's the return of Enum.size()?,the return of Enum.size() should be the number of key-value mappings in this map..,"['return', 'Enum.size()']"
Enum.containsValue(Object value),what's the return of Enum.containsValue(Object value)?,the return of Enum.containsValue(Object value) should be true if this map maps one or more keys to the specified value..,"['return', 'Enum.containsValue(Object value)']"
Enum.containsValue(Object value),what's the parameter of Enum.containsValue(Object value)?,the parameter of Enum.containsValue(Object value) should be  the value whose presence in this map is to be tested.,"['parameter', 'Enum.containsValue(Object value)']"
Enum.containsKey(Object key),what's the return of Enum.containsKey(Object key)?,the return of Enum.containsKey(Object key) should be true if this map contains a mapping for the specified key..,"['return', 'Enum.containsKey(Object key)']"
Enum.containsKey(Object key),what's the parameter of Enum.containsKey(Object key)?,the parameter of Enum.containsKey(Object key) should be  the key whose presence in this map is to be tested.,"['parameter', 'Enum.containsKey(Object key)']"
Enum.get(Object key),what's the return of Enum.get(Object key)?,"the return of Enum.get(Object key) should be the value to which the specified key is mapped, or null if this map contains no mapping for the key..","['return', 'Enum.get(Object key)']"
Enum.get(Object key),what's the parameter of Enum.get(Object key)?,the parameter of Enum.get(Object key) should be  the key whose associated value is to be returned.,"['parameter', 'Enum.get(Object key)']"
"Enum.put(K key, V value)","what's the return of Enum.put(K key, V value)?","the return of Enum.put(K key, V value) should be value - the value to be associated with the specified key.","['return', 'Enum.put(K key, V value)']"
"Enum.put(K key, V value)","what's the parameter of Enum.put(K key, V value)?","the parameter of Enum.put(K key, V value) should be  the key with which the specified value is to be associated.","['parameter', 'Enum.put(K key, V value)']"
Enum.remove(Object key),what's the return of Enum.remove(Object key)?,"the return of Enum.remove(Object key) should be the previous value associated with specified key, or
     null if there was no entry for key.  (A null
     return can also indicate that the map previously associated
     null with the specified key.).","['return', 'Enum.remove(Object key)']"
Enum.remove(Object key),what's the parameter of Enum.remove(Object key)?,the parameter of Enum.remove(Object key) should be  the key whose mapping is to be removed from the map.,"['parameter', 'Enum.remove(Object key)']"
"Enum.putAll(Map<? extends K,? extends V> m)","what's the parameter of Enum.putAll(Map<? extends K,? extends V> m)?","the parameter of Enum.putAll(Map<? extends K,? extends V> m) should be  the mappings to be stored in this map.","['parameter', 'Enum.putAll(Map<? extends K,? extends V> m)']"
Enum.keySet(),what's the return of Enum.keySet()?,the return of Enum.keySet() should be a Set view of the keys contained in this map. The returned set obeys the general contract outlined in Map.keySet(). The set's iterator will return the keys in their natural order (the order in which the enum constants are declared)..,"['return', 'Enum.keySet()']"
Enum.values(),what's the return of Enum.values()?,"the return of Enum.values() should be a Collection view of the values contained in this map. The returned collection obeys the general contract outlined in Map.values(). The collection's iterator will return the values in the order their corresponding keys appear in map, which is their natural order (the order in which the enum constants are declared)..","['return', 'Enum.values()']"
Enum.entrySet(),what's the return of Enum.entrySet()?,"the return of Enum.entrySet() should be a Set view of the mappings contained in this map. The returned set obeys the general contract outlined in Map.keySet(). The set's iterator will return the mappings in the order their keys appear in map, which is their natural order (the order in which the enum constants are declared)..","['return', 'Enum.entrySet()']"
Enum.equals(Object o),what's the return of Enum.equals(Object o)?,the return of Enum.equals(Object o) should be true if the specified object is equal to this map.,"['return', 'Enum.equals(Object o)']"
Enum.equals(Object o),what's the parameter of Enum.equals(Object o)?,the parameter of Enum.equals(Object o) should be  the object to be compared for equality with this map.,"['parameter', 'Enum.equals(Object o)']"
Enum.hashCode(),what's the return of Enum.hashCode()?,the return of Enum.hashCode() should be the hash code value for this map. The hash code of a map is defined to be the sum of the hash codes of each entry in the map..,"['return', 'Enum.hashCode()']"
Object.clone(),what's the return of Object.clone()?,the return of Object.clone() should be a shallow copy of this AbstractMap instance: the keys and values themselves are not cloned..,"['return', 'Object.clone()']"
EventListenerProxy<T.getListener(),what's the return of EventListenerProxy<T.getListener()?,the return of EventListenerProxy<T.getListener() should be the listener associated with the proxy..,"['return', 'EventListenerProxy<T.getListener()']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
Formatter.BigDecimalLayoutForm.values(),what's the return of Formatter.BigDecimalLayoutForm.values()?,"the return of Formatter.BigDecimalLayoutForm.values() should be an array containing the constants of this enum type, in the order they are declared. This method may be used to iterate over the constants as follows: for (Formatter.BigDecimalLayoutForm c : Formatter.BigDecimalLayoutForm.values()) System.out.println(c);.","['return', 'Formatter.BigDecimalLayoutForm.values()']"
Formatter.BigDecimalLayoutForm.valueOf(String name),what's the return of Formatter.BigDecimalLayoutForm.valueOf(String name)?,the return of Formatter.BigDecimalLayoutForm.valueOf(String name) should be the enum constant of this type with the specified name. The string must match exactly an identifier used to declare an enum constant in this type. (Extraneous whitespace characters are not permitted.).,"['return', 'Formatter.BigDecimalLayoutForm.valueOf(String name)']"
Formatter.BigDecimalLayoutForm.valueOf(String name),what's the parameter of Formatter.BigDecimalLayoutForm.valueOf(String name)?,the parameter of Formatter.BigDecimalLayoutForm.valueOf(String name) should be  the name of the enum constant to be returned..,"['parameter', 'Formatter.BigDecimalLayoutForm.valueOf(String name)']"
Formatter.locale(),what's the return of Formatter.locale()?,the return of Formatter.locale() should be the locale set by the construction of this formatter..,"['return', 'Formatter.locale()']"
Formatter.out(),what's the return of Formatter.out()?,the return of Formatter.out() should be the destination for the output..,"['return', 'Formatter.out()']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
Formatter.ioException(),what's the return of Formatter.ioException()?,the return of Formatter.ioException() should be the IOException last thrown by this formatter's Appendable..,"['return', 'Formatter.ioException()']"
"Formatter.format(String format, Object... args)","what's the return of Formatter.format(String format, Object... args)?","the return of Formatter.format(String format, Object... args) should be args - Arguments referenced by the format specifiers in the format
         string.  If there are more arguments than format specifiers, the
         extra arguments are ignored.  The maximum number of arguments is
         limited by the maximum dimension of a Java array as defined by
         The Java™ Virtual Machine Specification..","['return', 'Formatter.format(String format, Object... args)']"
"Formatter.format(String format, Object... args)","what's the parameter of Formatter.format(String format, Object... args)?","the parameter of Formatter.format(String format, Object... args) should be  A format string as described in Format string
         syntax..","['parameter', 'Formatter.format(String format, Object... args)']"
"Formatter.format(Locale l, String format, Object... args)","what's the return of Formatter.format(Locale l, String format, Object... args)?","the return of Formatter.format(Locale l, String format, Object... args) should be format - A format string as described in Format string
         syntax.","['return', 'Formatter.format(Locale l, String format, Object... args)']"
"Formatter.format(Locale l, String format, Object... args)","what's the parameter of Formatter.format(Locale l, String format, Object... args)?","the parameter of Formatter.format(Locale l, String format, Object... args) should be  The locale to apply during
         formatting.  If l is null then no localization
         is applied.  This does not change this object's locale that was
         set during construction..","['parameter', 'Formatter.format(Locale l, String format, Object... args)']"
"Formatter.format(Locale l, String format, Object... args)","what's the parameter of Formatter.format(Locale l, String format, Object... args)?","the parameter of Formatter.format(Locale l, String format, Object... args) should be  The locale to apply during
         formatting.  If l is null then no localization
         is applied.  This does not change this object's locale that was
         set during construction..","['parameter', 'Formatter.format(Locale l, String format, Object... args)']"
Map.entrySet(),what's the return of Map.entrySet()?,the return of Map.entrySet() should be a set view of the mappings contained in this map.,"['return', 'Map.entrySet()']"
"Map.getOrDefault(Object key, V defaultValue)","what's the return of Map.getOrDefault(Object key, V defaultValue)?","the return of Map.getOrDefault(Object key, V defaultValue) should be the value to which the specified key is mapped, or defaultValue if this map contains no mapping for the key..","['return', 'Map.getOrDefault(Object key, V defaultValue)']"
"Map.getOrDefault(Object key, V defaultValue)","what's the parameter of Map.getOrDefault(Object key, V defaultValue)?","the parameter of Map.getOrDefault(Object key, V defaultValue) should be  the key whose associated value is to be returned.","['parameter', 'Map.getOrDefault(Object key, V defaultValue)']"
"Map.getOrDefault(Object key, V defaultValue)","what's the parameter of Map.getOrDefault(Object key, V defaultValue)?","the parameter of Map.getOrDefault(Object key, V defaultValue) should be  the key whose associated value is to be returned.","['parameter', 'Map.getOrDefault(Object key, V defaultValue)']"
"Map.putIfAbsent(K key, V value)","what's the return of Map.putIfAbsent(K key, V value)?","the return of Map.putIfAbsent(K key, V value) should be value - value to be associated with the specified key.","['return', 'Map.putIfAbsent(K key, V value)']"
"Map.putIfAbsent(K key, V value)","what's the parameter of Map.putIfAbsent(K key, V value)?","the parameter of Map.putIfAbsent(K key, V value) should be  key with which the specified value is to be associated.","['parameter', 'Map.putIfAbsent(K key, V value)']"
"Map.remove(Object key, Object value)","what's the return of Map.remove(Object key, Object value)?","the return of Map.remove(Object key, Object value) should be value - value expected to be associated with the specified key.","['return', 'Map.remove(Object key, Object value)']"
"Map.remove(Object key, Object value)","what's the parameter of Map.remove(Object key, Object value)?","the parameter of Map.remove(Object key, Object value) should be  key with which the specified value is associated.","['parameter', 'Map.remove(Object key, Object value)']"
"Map.replace(K key, V oldValue, V newValue)","what's the return of Map.replace(K key, V oldValue, V newValue)?","the return of Map.replace(K key, V oldValue, V newValue) should be oldValue - value expected to be associated with the specified key.","['return', 'Map.replace(K key, V oldValue, V newValue)']"
"Map.replace(K key, V oldValue, V newValue)","what's the parameter of Map.replace(K key, V oldValue, V newValue)?","the parameter of Map.replace(K key, V oldValue, V newValue) should be  key with which the specified value is associated.","['parameter', 'Map.replace(K key, V oldValue, V newValue)']"
"Map.replace(K key, V value)","what's the return of Map.replace(K key, V value)?","the return of Map.replace(K key, V value) should be value - value to be associated with the specified key.","['return', 'Map.replace(K key, V value)']"
"Map.replace(K key, V value)","what's the parameter of Map.replace(K key, V value)?","the parameter of Map.replace(K key, V value) should be  key with which the specified value is associated.","['parameter', 'Map.replace(K key, V value)']"
"Map.computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction)","what's the return of Map.computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction)?","the return of Map.computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction) should be mappingFunction - the function to compute a value.","['return', 'Map.computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction)']"
"Map.computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction)","what's the parameter of Map.computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction)?","the parameter of Map.computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction) should be  key with which the specified value is to be associated.","['parameter', 'Map.computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction)']"
"Map.computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)","what's the return of Map.computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)?","the return of Map.computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction) should be remappingFunction - the function to compute a value.","['return', 'Map.computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)']"
"Map.computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)","what's the parameter of Map.computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)?","the parameter of Map.computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction) should be  key with which the specified value is to be associated.","['parameter', 'Map.computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)']"
"Map.compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)","what's the return of Map.compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)?","the return of Map.compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction) should be remappingFunction - the function to compute a value.","['return', 'Map.compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)']"
"Map.compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)","what's the parameter of Map.compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)?","the parameter of Map.compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction) should be  key with which the specified value is to be associated.","['parameter', 'Map.compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)']"
"Map.merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction)","what's the return of Map.merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction)?","the return of Map.merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction) should be value - the non-null value to be merged with the existing value
        associated with the key or, if no existing value or a null value
        is associated with the key, to be associated with the key.","['return', 'Map.merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction)']"
"Map.merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction)","what's the parameter of Map.merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction)?","the parameter of Map.merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction) should be  key with which the resulting value is to be associated.","['parameter', 'Map.merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction)']"
"Map.forEach(BiConsumer<? super K,? super V> action)","what's the parameter of Map.forEach(BiConsumer<? super K,? super V> action)?","the parameter of Map.forEach(BiConsumer<? super K,? super V> action) should be  The action to be performed for each entry.","['parameter', 'Map.forEach(BiConsumer<? super K,? super V> action)']"
"Map.replaceAll(BiFunction<? super K,? super V,? extends V> function)","what's the parameter of Map.replaceAll(BiFunction<? super K,? super V,? extends V> function)?","the parameter of Map.replaceAll(BiFunction<? super K,? super V,? extends V> function) should be  the function to apply to each entry.","['parameter', 'Map.replaceAll(BiFunction<? super K,? super V,? extends V> function)']"
Iterable.iterator(),what's the return of Iterable.iterator()?,the return of Iterable.iterator() should be an iterator over the elements in this list in proper sequence..,"['return', 'Iterable.iterator()']"
Collection.size(),what's the return of Collection.size()?,the return of Collection.size() should be the number of elements in this deque..,"['return', 'Collection.size()']"
Object.clone(),what's the return of Object.clone()?,the return of Object.clone() should be a shallow copy of this AbstractMap instance: the keys and values themselves are not cloned..,"['return', 'Object.clone()']"
Iterable.spliterator(),what's the return of Iterable.spliterator()?,the return of Iterable.spliterator() should be a Spliterator over the elements in this list.,"['return', 'Iterable.spliterator()']"
Map.size(),what's the return of Map.size()?,"the return of Map.size() should be the number of key-value mappings in this map. If the map contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE..","['return', 'Map.size()']"
Map.isEmpty(),what's the return of Map.isEmpty()?,the return of Map.isEmpty() should be true if this map contains no key-value mappings..,"['return', 'Map.isEmpty()']"
Dictionary.keys(),what's the return of Dictionary.keys()?,the return of Dictionary.keys() should be an enumeration of the keys in this dictionary. The general contract for the keys method is that an Enumeration object is returned that will generate all the keys for which this dictionary contains entries..,"['return', 'Dictionary.keys()']"
Dictionary.elements(),what's the return of Dictionary.elements()?,the return of Dictionary.elements() should be an enumeration of the values in this dictionary. The general contract for the elements method is that an Enumeration is returned that will generate all the elements contained in entries in this dictionary..,"['return', 'Dictionary.elements()']"
Hashtable.contains(Object value),what's the return of Hashtable.contains(Object value)?,"the return of Hashtable.contains(Object value) should be true if and only if some key maps to the
             value argument in this hashtable as
             determined by the equals method;
             false otherwise..","['return', 'Hashtable.contains(Object value)']"
Hashtable.contains(Object value),what's the parameter of Hashtable.contains(Object value)?,the parameter of Hashtable.contains(Object value) should be  a value to search for.,"['parameter', 'Hashtable.contains(Object value)']"
Map.containsValue(Object value),what's the return of Map.containsValue(Object value)?,"the return of Map.containsValue(Object value) should be true if this map maps one or more keys to the specified value. More formally, returns true if and only if this map contains at least one mapping to a value v such that (value==null ? v==null : value.equals(v)). This operation will probably require time linear in the map size for most implementations of the Map interface..","['return', 'Map.containsValue(Object value)']"
Map.containsValue(Object value),what's the parameter of Map.containsValue(Object value)?,the parameter of Map.containsValue(Object value) should be  value whose presence in this map is to be tested.,"['parameter', 'Map.containsValue(Object value)']"
Map.containsKey(Object key),what's the return of Map.containsKey(Object key)?,"the return of Map.containsKey(Object key) should be true if this map contains a mapping for the specified key. More formally, returns true if and only if this map contains a mapping for a key k such that (key==null ? k==null : key.equals(k)). (There can be at most one such mapping.).","['return', 'Map.containsKey(Object key)']"
Map.containsKey(Object key),what's the parameter of Map.containsKey(Object key)?,the parameter of Map.containsKey(Object key) should be  key whose presence in this map is to be tested.,"['parameter', 'Map.containsKey(Object key)']"
Map.get(Object key),what's the return of Map.get(Object key)?,"the return of Map.get(Object key) should be the value to which the specified key is mapped, or null if this map contains no mapping for the key..","['return', 'Map.get(Object key)']"
Map.get(Object key),what's the parameter of Map.get(Object key)?,the parameter of Map.get(Object key) should be  the key whose associated value is to be returned.,"['parameter', 'Map.get(Object key)']"
Map.entrySet(),what's the return of Map.entrySet()?,the return of Map.entrySet() should be a set view of the mappings contained in this map.,"['return', 'Map.entrySet()']"
"Map.forEach(BiConsumer<? super K,? super V> action)","what's the parameter of Map.forEach(BiConsumer<? super K,? super V> action)?","the parameter of Map.forEach(BiConsumer<? super K,? super V> action) should be  The action to be performed for each entry.","['parameter', 'Map.forEach(BiConsumer<? super K,? super V> action)']"
"Map.replaceAll(BiFunction<? super K,? super V,? extends V> function)","what's the parameter of Map.replaceAll(BiFunction<? super K,? super V,? extends V> function)?","the parameter of Map.replaceAll(BiFunction<? super K,? super V,? extends V> function) should be  the function to apply to each entry.","['parameter', 'Map.replaceAll(BiFunction<? super K,? super V,? extends V> function)']"
IllegalFormatFlagsException.getFlags(),what's the return of IllegalFormatFlagsException.getFlags()?,the return of IllegalFormatFlagsException.getFlags() should be the set of flags which contains an illegal combination..,"['return', 'IllegalFormatFlagsException.getFlags()']"
IllegalFormatPrecisionException.getPrecision(),what's the return of IllegalFormatPrecisionException.getPrecision()?,the return of IllegalFormatPrecisionException.getPrecision() should be the precision.,"['return', 'IllegalFormatPrecisionException.getPrecision()']"
IllformedLocaleException.getErrorIndex(),what's the return of IllformedLocaleException.getErrorIndex()?,the return of IllformedLocaleException.getErrorIndex() should be the index where the error was found. A negative value indicates either the error index is not applicable or unknown..,"['return', 'IllformedLocaleException.getErrorIndex()']"
IntSummaryStatistics.combine(IntSummaryStatistics other),what's the parameter of IntSummaryStatistics.combine(IntSummaryStatistics other)?,the parameter of IntSummaryStatistics.combine(IntSummaryStatistics other) should be  another IntSummaryStatistics.,"['parameter', 'IntSummaryStatistics.combine(IntSummaryStatistics other)']"
IntSummaryStatistics.getCount(),what's the return of IntSummaryStatistics.getCount()?,the return of IntSummaryStatistics.getCount() should be the count of values recorded..,"['return', 'IntSummaryStatistics.getCount()']"
IntSummaryStatistics.getSum(),what's the return of IntSummaryStatistics.getSum()?,"the return of IntSummaryStatistics.getSum() should be the sum of values recorded, or zero if no values have been recorded..","['return', 'IntSummaryStatistics.getSum()']"
IntSummaryStatistics.getMin(),what's the return of IntSummaryStatistics.getMin()?,"the return of IntSummaryStatistics.getMin() should be the minimum value recorded, or Integer.MAX_VALUE if no values have been recorded..","['return', 'IntSummaryStatistics.getMin()']"
IntSummaryStatistics.getMax(),what's the return of IntSummaryStatistics.getMax()?,"the return of IntSummaryStatistics.getMax() should be the maximum value recorded, or Integer.MIN_VALUE if no values have been recorded..","['return', 'IntSummaryStatistics.getMax()']"
IntSummaryStatistics.getAverage(),what's the return of IntSummaryStatistics.getAverage()?,"the return of IntSummaryStatistics.getAverage() should be the arithmetic mean of values recorded, or zero if no values have been recorded..","['return', 'IntSummaryStatistics.getAverage()']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
Iterator.hasNext(),what's the return of Iterator.hasNext()?,"the return of Iterator.hasNext() should be true if the iteration has more elements. (In other words, returns true if next() would return an element rather than throwing an exception.).","['return', 'Iterator.hasNext()']"
Iterator.next(),what's the return of Iterator.next()?,the return of Iterator.next() should be the next element in the iteration..,"['return', 'Iterator.next()']"
"LinkedHashMap.removeEldestEntry(Map.Entry<K,V> eldest)","what's the return of LinkedHashMap.removeEldestEntry(Map.Entry<K,V> eldest)?","the return of LinkedHashMap.removeEldestEntry(Map.Entry<K,V> eldest) should be true if this map should remove its eldest entry. This method is invoked by put and putAll after inserting a new entry into the map. It provides the implementor with the opportunity to remove the eldest entry each time a new one is added. This is useful if the map represents a cache: it allows the map to reduce memory consumption by deleting stale entries. private static final int MAX_ENTRIES = 100; protected boolean removeEldestEntry(Map.Entry eldest) { return size() > MAX_ENTRIES; }.","['return', 'LinkedHashMap.removeEldestEntry(Map.Entry<K,V> eldest)']"
Deque.getFirst(),what's the return of Deque.getFirst()?,the return of Deque.getFirst() should be the head of this deque.,"['return', 'Deque.getFirst()']"
Deque.getLast(),what's the return of Deque.getLast()?,the return of Deque.getLast() should be the tail of this deque.,"['return', 'Deque.getLast()']"
Deque.removeFirst(),what's the return of Deque.removeFirst()?,the return of Deque.removeFirst() should be the head of this deque.,"['return', 'Deque.removeFirst()']"
Deque.removeLast(),what's the return of Deque.removeLast()?,the return of Deque.removeLast() should be the tail of this deque.,"['return', 'Deque.removeLast()']"
Deque.addFirst(E e),what's the parameter of Deque.addFirst(E e)?,the parameter of Deque.addFirst(E e) should be  the element to add.,"['parameter', 'Deque.addFirst(E e)']"
Deque.addLast(E e),what's the parameter of Deque.addLast(E e)?,the parameter of Deque.addLast(E e) should be  the element to add.,"['parameter', 'Deque.addLast(E e)']"
Collection.size(),what's the return of Collection.size()?,the return of Collection.size() should be the number of elements in this deque..,"['return', 'Collection.size()']"
Deque.peek(),what's the return of Deque.peek()?,"the return of Deque.peek() should be the head of the queue represented by this deque, or
         null if this deque is empty.","['return', 'Deque.peek()']"
Deque.element(),what's the return of Deque.element()?,the return of Deque.element() should be the head of the queue represented by this deque.,"['return', 'Deque.element()']"
Deque.poll(),what's the return of Deque.poll()?,"the return of Deque.poll() should be the head of the queue represented by this deque, or
         null if this deque is empty.","['return', 'Deque.poll()']"
Deque.remove(),what's the return of Deque.remove()?,the return of Deque.remove() should be the head of the queue represented by this deque.,"['return', 'Deque.remove()']"
Deque.offer(E e),what's the return of Deque.offer(E e)?,the return of Deque.offer(E e) should be true (as specified by Queue.offer(E)).,"['return', 'Deque.offer(E e)']"
Deque.offer(E e),what's the parameter of Deque.offer(E e)?,the parameter of Deque.offer(E e) should be  the element to add.,"['parameter', 'Deque.offer(E e)']"
Deque.offerFirst(E e),what's the return of Deque.offerFirst(E e)?,"the return of Deque.offerFirst(E e) should be true if the element was added to this deque, else
         false.","['return', 'Deque.offerFirst(E e)']"
Deque.offerFirst(E e),what's the parameter of Deque.offerFirst(E e)?,the parameter of Deque.offerFirst(E e) should be  the element to add.,"['parameter', 'Deque.offerFirst(E e)']"
Deque.offerLast(E e),what's the return of Deque.offerLast(E e)?,"the return of Deque.offerLast(E e) should be true if the element was added to this deque, else
         false.","['return', 'Deque.offerLast(E e)']"
Deque.offerLast(E e),what's the parameter of Deque.offerLast(E e)?,the parameter of Deque.offerLast(E e) should be  the element to add.,"['parameter', 'Deque.offerLast(E e)']"
Deque.peekFirst(),what's the return of Deque.peekFirst()?,"the return of Deque.peekFirst() should be the head of this deque, or null if this deque is empty.","['return', 'Deque.peekFirst()']"
Deque.peekLast(),what's the return of Deque.peekLast()?,"the return of Deque.peekLast() should be the tail of this deque, or null if this deque is empty.","['return', 'Deque.peekLast()']"
Deque.pollFirst(),what's the return of Deque.pollFirst()?,"the return of Deque.pollFirst() should be the head of this deque, or null if this deque is empty.","['return', 'Deque.pollFirst()']"
Deque.pollLast(),what's the return of Deque.pollLast()?,"the return of Deque.pollLast() should be the tail of this deque, or null if this deque is empty.","['return', 'Deque.pollLast()']"
Deque.push(E e),what's the parameter of Deque.push(E e)?,the parameter of Deque.push(E e) should be  the element to push.,"['parameter', 'Deque.push(E e)']"
Deque.pop(),what's the return of Deque.pop()?,"the return of Deque.pop() should be the element at the front of this deque (which is the top
         of the stack represented by this deque).","['return', 'Deque.pop()']"
Deque.removeFirstOccurrence(Object o),what's the return of Deque.removeFirstOccurrence(Object o)?,the return of Deque.removeFirstOccurrence(Object o) should be true if an element was removed as a result of this call.,"['return', 'Deque.removeFirstOccurrence(Object o)']"
Deque.removeFirstOccurrence(Object o),what's the parameter of Deque.removeFirstOccurrence(Object o)?,"the parameter of Deque.removeFirstOccurrence(Object o) should be  element to be removed from this deque, if present.","['parameter', 'Deque.removeFirstOccurrence(Object o)']"
Deque.removeLastOccurrence(Object o),what's the return of Deque.removeLastOccurrence(Object o)?,the return of Deque.removeLastOccurrence(Object o) should be true if an element was removed as a result of this call.,"['return', 'Deque.removeLastOccurrence(Object o)']"
Deque.removeLastOccurrence(Object o),what's the parameter of Deque.removeLastOccurrence(Object o)?,"the parameter of Deque.removeLastOccurrence(Object o) should be  element to be removed from this deque, if present.","['parameter', 'Deque.removeLastOccurrence(Object o)']"
List.listIterator(int index),what's the return of List.listIterator(int index)?,"the return of List.listIterator(int index) should be a list iterator over the elements in this list (in proper sequence), starting at the specified position in the list. The specified index indicates the first element that would be returned by an initial call to next. An initial call to previous would return the element with the specified index minus one..","['return', 'List.listIterator(int index)']"
Deque.descendingIterator(),what's the return of Deque.descendingIterator()?,the return of Deque.descendingIterator() should be an iterator over the elements in this deque in reverse sequential order. The elements will be returned in order from last (tail) to first (head)..,"['return', 'Deque.descendingIterator()']"
Object.clone(),what's the return of Object.clone()?,the return of Object.clone() should be a shallow copy of this AbstractMap instance: the keys and values themselves are not cloned..,"['return', 'Object.clone()']"
Iterable.spliterator(),what's the return of Iterable.spliterator()?,the return of Iterable.spliterator() should be a Spliterator over the elements in this list.,"['return', 'Iterable.spliterator()']"
Collection.size(),what's the return of Collection.size()?,the return of Collection.size() should be the number of elements in this deque..,"['return', 'Collection.size()']"
Collection.isEmpty(),what's the return of Collection.isEmpty()?,the return of Collection.isEmpty() should be true if this set contains no elements..,"['return', 'Collection.isEmpty()']"
Collection.contains(Object o),what's the return of Collection.contains(Object o)?,"the return of Collection.contains(Object o) should be true if this deque contains the specified element. More formally, returns true if and only if this deque contains at least one element e such that (o==null ? e==null : o.equals(e))..","['return', 'Collection.contains(Object o)']"
Collection.contains(Object o),what's the parameter of Collection.contains(Object o)?,the parameter of Collection.contains(Object o) should be  element whose presence in this deque is to be tested.,"['parameter', 'Collection.contains(Object o)']"
Collection.iterator(),what's the return of Collection.iterator()?,the return of Collection.iterator() should be an iterator over the elements in this deque in proper sequence. The elements will be returned in order from first (head) to last (tail)..,"['return', 'Collection.iterator()']"
Collection.toArray(),what's the return of Collection.toArray()?,"the return of Collection.toArray() should be an array containing all of the elements in this set. If this set makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order..","['return', 'Collection.toArray()']"
Collection.toArray(T[] a),what's the return of Collection.toArray(T[] a)?,"the return of Collection.toArray(T[] a) should be an array containing all of the elements in this set; the runtime type of the returned array is that of the specified array. If the set fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this set. String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray()..","['return', 'Collection.toArray(T[] a)']"
Collection.add(E e),what's the return of Collection.add(E e)?,the return of Collection.add(E e) should be true (as specified by Collection.add(E)).,"['return', 'Collection.add(E e)']"
Collection.add(E e),what's the parameter of Collection.add(E e)?,the parameter of Collection.add(E e) should be  the element to add.,"['parameter', 'Collection.add(E e)']"
Collection.remove(Object o),what's the return of Collection.remove(Object o)?,the return of Collection.remove(Object o) should be true if an element was removed as a result of this call.,"['return', 'Collection.remove(Object o)']"
Collection.remove(Object o),what's the parameter of Collection.remove(Object o)?,"the parameter of Collection.remove(Object o) should be  element to be removed from this deque, if present.","['parameter', 'Collection.remove(Object o)']"
Collection.containsAll(Collection<?> c),what's the return of Collection.containsAll(Collection<?> c)?,"the return of Collection.containsAll(Collection<?> c) should be true if this set contains all of the elements of the specified collection. If the specified collection is also a set, this method returns true if it is a subset of this set..","['return', 'Collection.containsAll(Collection<?> c)']"
Collection.addAll(Collection<? extends E> c),what's the return of Collection.addAll(Collection<? extends E> c)?,the return of Collection.addAll(Collection<? extends E> c) should be true if this set changed as a result of the call.,"['return', 'Collection.addAll(Collection<? extends E> c)']"
"List.addAll(int index, Collection<? extends E> c)","what's the return of List.addAll(int index, Collection<? extends E> c)?","the return of List.addAll(int index, Collection<? extends E> c) should be c - elements to be inserted into this Vector.","['return', 'List.addAll(int index, Collection<? extends E> c)']"
Collection.removeAll(Collection<?> c),what's the return of Collection.removeAll(Collection<?> c)?,the return of Collection.removeAll(Collection<?> c) should be true if this set changed as a result of the call.,"['return', 'Collection.removeAll(Collection<?> c)']"
Collection.retainAll(Collection<?> c),what's the return of Collection.retainAll(Collection<?> c)?,the return of Collection.retainAll(Collection<?> c) should be true if this set changed as a result of the call.,"['return', 'Collection.retainAll(Collection<?> c)']"
Object.equals(Object o),what's the return of Object.equals(Object o)?,the return of Object.equals(Object o) should be true if the specified object is equal to this map.,"['return', 'Object.equals(Object o)']"
Object.equals(Object o),what's the parameter of Object.equals(Object o)?,the parameter of Object.equals(Object o) should be  object to be compared for equality with this map.,"['parameter', 'Object.equals(Object o)']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
List.get(int index),what's the return of List.get(int index)?,the return of List.get(int index) should be the element at the specified position in this Vector..,"['return', 'List.get(int index)']"
"List.set(int index, E element)","what's the return of List.set(int index, E element)?","the return of List.set(int index, E element) should be element - element to be stored at the specified position.","['return', 'List.set(int index, E element)']"
"List.set(int index, E element)","what's the parameter of List.set(int index, E element)?","the parameter of List.set(int index, E element) should be  index of the element to replace.","['parameter', 'List.set(int index, E element)']"
"List.add(int index, E element)","what's the parameter of List.add(int index, E element)?","the parameter of List.add(int index, E element) should be  index at which the specified element is to be inserted.","['parameter', 'List.add(int index, E element)']"
List.remove(int index),what's the return of List.remove(int index)?,the return of List.remove(int index) should be element that was removed.,"['return', 'List.remove(int index)']"
List.indexOf(Object o),what's the return of List.indexOf(Object o)?,"the return of List.indexOf(Object o) should be the index of the first occurrence of the specified element in this vector, or -1 if this vector does not contain the element. More formally, returns the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index..","['return', 'List.indexOf(Object o)']"
List.indexOf(Object o),what's the parameter of List.indexOf(Object o)?,the parameter of List.indexOf(Object o) should be  element to search for.,"['parameter', 'List.indexOf(Object o)']"
List.lastIndexOf(Object o),what's the return of List.lastIndexOf(Object o)?,"the return of List.lastIndexOf(Object o) should be the index of the last occurrence of the specified element in this vector, or -1 if this vector does not contain the element. More formally, returns the highest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index..","['return', 'List.lastIndexOf(Object o)']"
List.lastIndexOf(Object o),what's the parameter of List.lastIndexOf(Object o)?,the parameter of List.lastIndexOf(Object o) should be  element to search for.,"['parameter', 'List.lastIndexOf(Object o)']"
List.listIterator(),what's the return of List.listIterator()?,the return of List.listIterator() should be a list iterator over the elements in this list (in proper sequence)..,"['return', 'List.listIterator()']"
List.listIterator(int index),what's the return of List.listIterator(int index)?,"the return of List.listIterator(int index) should be a list iterator over the elements in this list (in proper sequence), starting at the specified position in the list. The specified index indicates the first element that would be returned by an initial call to next. An initial call to previous would return the element with the specified index minus one..","['return', 'List.listIterator(int index)']"
"List.subList(int fromIndex, int toIndex)","what's the return of List.subList(int fromIndex, int toIndex)?","the return of List.subList(int fromIndex, int toIndex) should be a view of the portion of this List between fromIndex, inclusive, and toIndex, exclusive. (If fromIndex and toIndex are equal, the returned List is empty.) The returned List is backed by this List, so changes in the returned List are reflected in this List, and vice-versa. The returned List supports all of the optional List operations supported by this List. list.subList(from, to).clear(); Similar idioms may be constructed for indexOf and lastIndexOf, and all of the algorithms in the Collections class can be applied to a subList..","['return', 'List.subList(int fromIndex, int toIndex)']"
Collection.spliterator(),what's the return of Collection.spliterator()?,the return of Collection.spliterator() should be a Spliterator over the elements in this set.,"['return', 'Collection.spliterator()']"
Iterator.hasNext(),what's the return of Iterator.hasNext()?,"the return of Iterator.hasNext() should be true if the iteration has more elements. (In other words, returns true if next() would return an element rather than throwing an exception.).","['return', 'Iterator.hasNext()']"
Iterator.next(),what's the return of Iterator.next()?,the return of Iterator.next() should be the next element in the iteration..,"['return', 'Iterator.next()']"
ListIterator.hasPrevious(),what's the return of ListIterator.hasPrevious()?,"the return of ListIterator.hasPrevious() should be true if this list iterator has more elements when traversing the list in the reverse direction. (In other words, returns true if previous() would return an element rather than throwing an exception.).","['return', 'ListIterator.hasPrevious()']"
ListIterator.previous(),what's the return of ListIterator.previous()?,"the return of ListIterator.previous() should be the previous element in the list and moves the cursor position backwards. This method may be called repeatedly to iterate through the list backwards, or intermixed with calls to next() to go back and forth. (Note that alternating calls to next and previous will return the same element repeatedly.).","['return', 'ListIterator.previous()']"
ListIterator.nextIndex(),what's the return of ListIterator.nextIndex()?,the return of ListIterator.nextIndex() should be the index of the element that would be returned by a subsequent call to next(). (Returns list size if the list iterator is at the end of the list.).,"['return', 'ListIterator.nextIndex()']"
ListIterator.previousIndex(),what's the return of ListIterator.previousIndex()?,the return of ListIterator.previousIndex() should be the index of the element that would be returned by a subsequent call to previous(). (Returns -1 if the list iterator is at the beginning of the list.).,"['return', 'ListIterator.previousIndex()']"
ListIterator.set(E e),what's the parameter of ListIterator.set(E e)?,"the parameter of ListIterator.set(E e) should be  the element with which to replace the last element returned by
          next or previous.","['parameter', 'ListIterator.set(E e)']"
ListIterator.add(E e),what's the parameter of ListIterator.add(E e)?,the parameter of ListIterator.add(E e) should be  the element to insert.,"['parameter', 'ListIterator.add(E e)']"
ResourceBundle.handleGetObject(String key),what's the return of ResourceBundle.handleGetObject(String key)?,"the return of ResourceBundle.handleGetObject(String key) should be the object for the given key, or null.","['return', 'ResourceBundle.handleGetObject(String key)']"
ResourceBundle.handleGetObject(String key),what's the parameter of ResourceBundle.handleGetObject(String key)?,the parameter of ResourceBundle.handleGetObject(String key) should be  the key for the desired object.,"['parameter', 'ResourceBundle.handleGetObject(String key)']"
ResourceBundle.getKeys(),what's the return of ResourceBundle.getKeys()?,the return of ResourceBundle.getKeys() should be an Enumeration of the keys contained in this ResourceBundle and its parent bundles..,"['return', 'ResourceBundle.getKeys()']"
Locale.Builder.setLocale(Locale locale),what's the return of Locale.Builder.setLocale(Locale locale)?,the return of Locale.Builder.setLocale(Locale locale) should be This builder..,"['return', 'Locale.Builder.setLocale(Locale locale)']"
Locale.Builder.setLocale(Locale locale),what's the parameter of Locale.Builder.setLocale(Locale locale)?,the parameter of Locale.Builder.setLocale(Locale locale) should be  the locale.,"['parameter', 'Locale.Builder.setLocale(Locale locale)']"
Locale.Builder.setLanguageTag(String languageTag),what's the return of Locale.Builder.setLanguageTag(String languageTag)?,the return of Locale.Builder.setLanguageTag(String languageTag) should be This builder..,"['return', 'Locale.Builder.setLanguageTag(String languageTag)']"
Locale.Builder.setLanguageTag(String languageTag),what's the parameter of Locale.Builder.setLanguageTag(String languageTag)?,the parameter of Locale.Builder.setLanguageTag(String languageTag) should be  the language tag.,"['parameter', 'Locale.Builder.setLanguageTag(String languageTag)']"
Locale.Builder.setLanguage(String language),what's the return of Locale.Builder.setLanguage(String language)?,the return of Locale.Builder.setLanguage(String language) should be This builder..,"['return', 'Locale.Builder.setLanguage(String language)']"
Locale.Builder.setLanguage(String language),what's the parameter of Locale.Builder.setLanguage(String language)?,the parameter of Locale.Builder.setLanguage(String language) should be  the language.,"['parameter', 'Locale.Builder.setLanguage(String language)']"
Locale.Builder.setScript(String script),what's the return of Locale.Builder.setScript(String script)?,the return of Locale.Builder.setScript(String script) should be This builder..,"['return', 'Locale.Builder.setScript(String script)']"
Locale.Builder.setScript(String script),what's the parameter of Locale.Builder.setScript(String script)?,the parameter of Locale.Builder.setScript(String script) should be  the script.,"['parameter', 'Locale.Builder.setScript(String script)']"
Locale.Builder.setRegion(String region),what's the return of Locale.Builder.setRegion(String region)?,the return of Locale.Builder.setRegion(String region) should be This builder..,"['return', 'Locale.Builder.setRegion(String region)']"
Locale.Builder.setRegion(String region),what's the parameter of Locale.Builder.setRegion(String region)?,the parameter of Locale.Builder.setRegion(String region) should be  the region.,"['parameter', 'Locale.Builder.setRegion(String region)']"
Locale.Builder.setVariant(String variant),what's the return of Locale.Builder.setVariant(String variant)?,the return of Locale.Builder.setVariant(String variant) should be This builder..,"['return', 'Locale.Builder.setVariant(String variant)']"
Locale.Builder.setVariant(String variant),what's the parameter of Locale.Builder.setVariant(String variant)?,the parameter of Locale.Builder.setVariant(String variant) should be  the variant.,"['parameter', 'Locale.Builder.setVariant(String variant)']"
"Locale.Builder.setExtension(char key, String value)","what's the return of Locale.Builder.setExtension(char key, String value)?","the return of Locale.Builder.setExtension(char key, String value) should be value - the extension value.","['return', 'Locale.Builder.setExtension(char key, String value)']"
"Locale.Builder.setExtension(char key, String value)","what's the parameter of Locale.Builder.setExtension(char key, String value)?","the parameter of Locale.Builder.setExtension(char key, String value) should be  the extension key.","['parameter', 'Locale.Builder.setExtension(char key, String value)']"
"Locale.Builder.setUnicodeLocaleKeyword(String key, String type)","what's the return of Locale.Builder.setUnicodeLocaleKeyword(String key, String type)?","the return of Locale.Builder.setUnicodeLocaleKeyword(String key, String type) should be type - the Unicode locale type.","['return', 'Locale.Builder.setUnicodeLocaleKeyword(String key, String type)']"
"Locale.Builder.setUnicodeLocaleKeyword(String key, String type)","what's the parameter of Locale.Builder.setUnicodeLocaleKeyword(String key, String type)?","the parameter of Locale.Builder.setUnicodeLocaleKeyword(String key, String type) should be  the Unicode locale key.","['parameter', 'Locale.Builder.setUnicodeLocaleKeyword(String key, String type)']"
Locale.Builder.addUnicodeLocaleAttribute(String attribute),what's the return of Locale.Builder.addUnicodeLocaleAttribute(String attribute)?,the return of Locale.Builder.addUnicodeLocaleAttribute(String attribute) should be This builder..,"['return', 'Locale.Builder.addUnicodeLocaleAttribute(String attribute)']"
Locale.Builder.addUnicodeLocaleAttribute(String attribute),what's the parameter of Locale.Builder.addUnicodeLocaleAttribute(String attribute)?,the parameter of Locale.Builder.addUnicodeLocaleAttribute(String attribute) should be  the attribute.,"['parameter', 'Locale.Builder.addUnicodeLocaleAttribute(String attribute)']"
Locale.Builder.removeUnicodeLocaleAttribute(String attribute),what's the return of Locale.Builder.removeUnicodeLocaleAttribute(String attribute)?,the return of Locale.Builder.removeUnicodeLocaleAttribute(String attribute) should be This builder..,"['return', 'Locale.Builder.removeUnicodeLocaleAttribute(String attribute)']"
Locale.Builder.removeUnicodeLocaleAttribute(String attribute),what's the parameter of Locale.Builder.removeUnicodeLocaleAttribute(String attribute)?,the parameter of Locale.Builder.removeUnicodeLocaleAttribute(String attribute) should be  the attribute.,"['parameter', 'Locale.Builder.removeUnicodeLocaleAttribute(String attribute)']"
Locale.Builder.clear(),what's the return of Locale.Builder.clear()?,the return of Locale.Builder.clear() should be This builder..,"['return', 'Locale.Builder.clear()']"
Locale.Builder.clearExtensions(),what's the return of Locale.Builder.clearExtensions()?,the return of Locale.Builder.clearExtensions() should be This builder..,"['return', 'Locale.Builder.clearExtensions()']"
Locale.Builder.build(),what's the return of Locale.Builder.build()?,the return of Locale.Builder.build() should be an instance of Locale created from the fields set on this builder..,"['return', 'Locale.Builder.build()']"
Locale.Category.values(),what's the return of Locale.Category.values()?,"the return of Locale.Category.values() should be an array containing the constants of this enum type, in the order they are declared. This method may be used to iterate over the constants as follows: for (Locale.Category c : Locale.Category.values()) System.out.println(c);.","['return', 'Locale.Category.values()']"
Locale.Category.valueOf(String name),what's the return of Locale.Category.valueOf(String name)?,the return of Locale.Category.valueOf(String name) should be the enum constant of this type with the specified name. The string must match exactly an identifier used to declare an enum constant in this type. (Extraneous whitespace characters are not permitted.).,"['return', 'Locale.Category.valueOf(String name)']"
Locale.Category.valueOf(String name),what's the parameter of Locale.Category.valueOf(String name)?,the parameter of Locale.Category.valueOf(String name) should be  the name of the enum constant to be returned..,"['parameter', 'Locale.Category.valueOf(String name)']"
Locale.FilteringMode.values(),what's the return of Locale.FilteringMode.values()?,"the return of Locale.FilteringMode.values() should be an array containing the constants of this enum type, in the order they are declared. This method may be used to iterate over the constants as follows: for (Locale.FilteringMode c : Locale.FilteringMode.values()) System.out.println(c);.","['return', 'Locale.FilteringMode.values()']"
Locale.FilteringMode.valueOf(String name),what's the return of Locale.FilteringMode.valueOf(String name)?,the return of Locale.FilteringMode.valueOf(String name) should be the enum constant of this type with the specified name. The string must match exactly an identifier used to declare an enum constant in this type. (Extraneous whitespace characters are not permitted.).,"['return', 'Locale.FilteringMode.valueOf(String name)']"
Locale.FilteringMode.valueOf(String name),what's the parameter of Locale.FilteringMode.valueOf(String name)?,the parameter of Locale.FilteringMode.valueOf(String name) should be  the name of the enum constant to be returned..,"['parameter', 'Locale.FilteringMode.valueOf(String name)']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
Object.clone(),what's the return of Object.clone()?,the return of Object.clone() should be a shallow copy of this AbstractMap instance: the keys and values themselves are not cloned..,"['return', 'Object.clone()']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
Object.equals(Object obj),what's the return of Object.equals(Object obj)?,"the return of Object.equals(Object obj) should be true if the objects are the same;
          false otherwise..","['return', 'Object.equals(Object obj)']"
Object.equals(Object obj),what's the parameter of Object.equals(Object obj)?,the parameter of Object.equals(Object obj) should be  the object to compare with..,"['parameter', 'Object.equals(Object obj)']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
Object.equals(Object obj),what's the return of Object.equals(Object obj)?,"the return of Object.equals(Object obj) should be true if the objects are the same;
          false otherwise..","['return', 'Object.equals(Object obj)']"
Object.equals(Object obj),what's the parameter of Object.equals(Object obj)?,the parameter of Object.equals(Object obj) should be  the object to compare with..,"['parameter', 'Object.equals(Object obj)']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
Map.Entry.getKey(),what's the return of Map.Entry.getKey()?,the return of Map.Entry.getKey() should be the key corresponding to this entry..,"['return', 'Map.Entry.getKey()']"
Map.Entry.getValue(),what's the return of Map.Entry.getValue()?,"the return of Map.Entry.getValue() should be the value corresponding to this entry. If the mapping has been removed from the backing map (by the iterator's remove operation), the results of this call are undefined..","['return', 'Map.Entry.getValue()']"
Map.Entry.setValue(V value),what's the return of Map.Entry.setValue(V value)?,the return of Map.Entry.setValue(V value) should be old value corresponding to the entry.,"['return', 'Map.Entry.setValue(V value)']"
Map.Entry.setValue(V value),what's the parameter of Map.Entry.setValue(V value)?,the parameter of Map.Entry.setValue(V value) should be  new value to be stored in this entry.,"['parameter', 'Map.Entry.setValue(V value)']"
Object.equals(Object o),what's the return of Object.equals(Object o)?,the return of Object.equals(Object o) should be true if the specified object is equal to this map.,"['return', 'Object.equals(Object o)']"
Object.equals(Object o),what's the parameter of Object.equals(Object o)?,the parameter of Object.equals(Object o) should be  object to be compared for equality with this map.,"['parameter', 'Object.equals(Object o)']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
Map.Entry.comparingByKey(),what's the return of Map.Entry.comparingByKey()?,the return of Map.Entry.comparingByKey() should be a comparator that compares Map.Entry in natural order on key..,"['return', 'Map.Entry.comparingByKey()']"
Map.Entry.comparingByValue(),what's the return of Map.Entry.comparingByValue()?,the return of Map.Entry.comparingByValue() should be a comparator that compares Map.Entry in natural order on value..,"['return', 'Map.Entry.comparingByValue()']"
Map.Entry.comparingByKey(Comparator<? super K> cmp),what's the return of Map.Entry.comparingByKey(Comparator<? super K> cmp)?,the return of Map.Entry.comparingByKey(Comparator<? super K> cmp) should be a comparator that compares Map.Entry by key using the given Comparator..,"['return', 'Map.Entry.comparingByKey(Comparator<? super K> cmp)']"
Map.Entry.comparingByValue(Comparator<? super V> cmp),what's the return of Map.Entry.comparingByValue(Comparator<? super V> cmp)?,the return of Map.Entry.comparingByValue(Comparator<? super V> cmp) should be a comparator that compares Map.Entry by value using the given Comparator..,"['return', 'Map.Entry.comparingByValue(Comparator<? super V> cmp)']"
Map.size(),what's the return of Map.size()?,"the return of Map.size() should be the number of key-value mappings in this map. If the map contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE..","['return', 'Map.size()']"
Map.isEmpty(),what's the return of Map.isEmpty()?,the return of Map.isEmpty() should be true if this map contains no key-value mappings..,"['return', 'Map.isEmpty()']"
Map.containsKey(Object key),what's the return of Map.containsKey(Object key)?,"the return of Map.containsKey(Object key) should be true if this map contains a mapping for the specified key. More formally, returns true if and only if this map contains a mapping for a key k such that (key==null ? k==null : key.equals(k)). (There can be at most one such mapping.).","['return', 'Map.containsKey(Object key)']"
Map.containsKey(Object key),what's the parameter of Map.containsKey(Object key)?,the parameter of Map.containsKey(Object key) should be  key whose presence in this map is to be tested.,"['parameter', 'Map.containsKey(Object key)']"
Map.containsValue(Object value),what's the return of Map.containsValue(Object value)?,"the return of Map.containsValue(Object value) should be true if this map maps one or more keys to the specified value. More formally, returns true if and only if this map contains at least one mapping to a value v such that (value==null ? v==null : value.equals(v)). This operation will probably require time linear in the map size for most implementations of the Map interface..","['return', 'Map.containsValue(Object value)']"
Map.containsValue(Object value),what's the parameter of Map.containsValue(Object value)?,the parameter of Map.containsValue(Object value) should be  value whose presence in this map is to be tested.,"['parameter', 'Map.containsValue(Object value)']"
Map.get(Object key),what's the return of Map.get(Object key)?,"the return of Map.get(Object key) should be the value to which the specified key is mapped, or null if this map contains no mapping for the key..","['return', 'Map.get(Object key)']"
Map.get(Object key),what's the parameter of Map.get(Object key)?,the parameter of Map.get(Object key) should be  the key whose associated value is to be returned.,"['parameter', 'Map.get(Object key)']"
"Map.put(K key, V value)","what's the return of Map.put(K key, V value)?","the return of Map.put(K key, V value) should be value - value to be associated with the specified key.","['return', 'Map.put(K key, V value)']"
"Map.put(K key, V value)","what's the parameter of Map.put(K key, V value)?","the parameter of Map.put(K key, V value) should be  key with which the specified value is to be associated.","['parameter', 'Map.put(K key, V value)']"
Map.remove(Object key),what's the return of Map.remove(Object key)?,"the return of Map.remove(Object key) should be the previous value associated with key, or
         null if there was no mapping for key..","['return', 'Map.remove(Object key)']"
Map.remove(Object key),what's the parameter of Map.remove(Object key)?,the parameter of Map.remove(Object key) should be  key whose mapping is to be removed from the map.,"['parameter', 'Map.remove(Object key)']"
"Map.putAll(Map<? extends K,? extends V> m)","what's the parameter of Map.putAll(Map<? extends K,? extends V> m)?","the parameter of Map.putAll(Map<? extends K,? extends V> m) should be  mappings to be stored in this map.","['parameter', 'Map.putAll(Map<? extends K,? extends V> m)']"
Map.keySet(),what's the return of Map.keySet()?,"the return of Map.keySet() should be a Set view of the keys contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations..","['return', 'Map.keySet()']"
Map.values(),what's the return of Map.values()?,"the return of Map.values() should be a Collection view of the values contained in this map. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Collection.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations..","['return', 'Map.values()']"
Map.entrySet(),what's the return of Map.entrySet()?,the return of Map.entrySet() should be a set view of the mappings contained in this map.,"['return', 'Map.entrySet()']"
Object.equals(Object o),what's the return of Object.equals(Object o)?,the return of Object.equals(Object o) should be true if the specified object is equal to this map.,"['return', 'Object.equals(Object o)']"
Object.equals(Object o),what's the parameter of Object.equals(Object o)?,the parameter of Object.equals(Object o) should be  object to be compared for equality with this map.,"['parameter', 'Object.equals(Object o)']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
"Map.getOrDefault(Object key, V defaultValue)","what's the return of Map.getOrDefault(Object key, V defaultValue)?","the return of Map.getOrDefault(Object key, V defaultValue) should be the value to which the specified key is mapped, or defaultValue if this map contains no mapping for the key..","['return', 'Map.getOrDefault(Object key, V defaultValue)']"
"Map.getOrDefault(Object key, V defaultValue)","what's the parameter of Map.getOrDefault(Object key, V defaultValue)?","the parameter of Map.getOrDefault(Object key, V defaultValue) should be  the key whose associated value is to be returned.","['parameter', 'Map.getOrDefault(Object key, V defaultValue)']"
"Map.getOrDefault(Object key, V defaultValue)","what's the parameter of Map.getOrDefault(Object key, V defaultValue)?","the parameter of Map.getOrDefault(Object key, V defaultValue) should be  the key whose associated value is to be returned.","['parameter', 'Map.getOrDefault(Object key, V defaultValue)']"
"Map.forEach(BiConsumer<? super K,? super V> action)","what's the parameter of Map.forEach(BiConsumer<? super K,? super V> action)?","the parameter of Map.forEach(BiConsumer<? super K,? super V> action) should be  The action to be performed for each entry.","['parameter', 'Map.forEach(BiConsumer<? super K,? super V> action)']"
"Map.replaceAll(BiFunction<? super K,? super V,? extends V> function)","what's the parameter of Map.replaceAll(BiFunction<? super K,? super V,? extends V> function)?","the parameter of Map.replaceAll(BiFunction<? super K,? super V,? extends V> function) should be  the function to apply to each entry.","['parameter', 'Map.replaceAll(BiFunction<? super K,? super V,? extends V> function)']"
"Map.putIfAbsent(K key, V value)","what's the return of Map.putIfAbsent(K key, V value)?","the return of Map.putIfAbsent(K key, V value) should be value - value to be associated with the specified key.","['return', 'Map.putIfAbsent(K key, V value)']"
"Map.putIfAbsent(K key, V value)","what's the parameter of Map.putIfAbsent(K key, V value)?","the parameter of Map.putIfAbsent(K key, V value) should be  key with which the specified value is to be associated.","['parameter', 'Map.putIfAbsent(K key, V value)']"
"Map.remove(Object key, Object value)","what's the return of Map.remove(Object key, Object value)?","the return of Map.remove(Object key, Object value) should be value - value expected to be associated with the specified key.","['return', 'Map.remove(Object key, Object value)']"
"Map.remove(Object key, Object value)","what's the parameter of Map.remove(Object key, Object value)?","the parameter of Map.remove(Object key, Object value) should be  key with which the specified value is associated.","['parameter', 'Map.remove(Object key, Object value)']"
"Map.replace(K key, V oldValue, V newValue)","what's the return of Map.replace(K key, V oldValue, V newValue)?","the return of Map.replace(K key, V oldValue, V newValue) should be oldValue - value expected to be associated with the specified key.","['return', 'Map.replace(K key, V oldValue, V newValue)']"
"Map.replace(K key, V oldValue, V newValue)","what's the parameter of Map.replace(K key, V oldValue, V newValue)?","the parameter of Map.replace(K key, V oldValue, V newValue) should be  key with which the specified value is associated.","['parameter', 'Map.replace(K key, V oldValue, V newValue)']"
"Map.replace(K key, V value)","what's the return of Map.replace(K key, V value)?","the return of Map.replace(K key, V value) should be value - value to be associated with the specified key.","['return', 'Map.replace(K key, V value)']"
"Map.replace(K key, V value)","what's the parameter of Map.replace(K key, V value)?","the parameter of Map.replace(K key, V value) should be  key with which the specified value is associated.","['parameter', 'Map.replace(K key, V value)']"
"Map.computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction)","what's the return of Map.computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction)?","the return of Map.computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction) should be mappingFunction - the function to compute a value.","['return', 'Map.computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction)']"
"Map.computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction)","what's the parameter of Map.computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction)?","the parameter of Map.computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction) should be  key with which the specified value is to be associated.","['parameter', 'Map.computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction)']"
"Map.computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)","what's the return of Map.computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)?","the return of Map.computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction) should be remappingFunction - the function to compute a value.","['return', 'Map.computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)']"
"Map.computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)","what's the parameter of Map.computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)?","the parameter of Map.computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction) should be  key with which the specified value is to be associated.","['parameter', 'Map.computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)']"
"Map.compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)","what's the return of Map.compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)?","the return of Map.compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction) should be remappingFunction - the function to compute a value.","['return', 'Map.compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)']"
"Map.compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)","what's the parameter of Map.compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)?","the parameter of Map.compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction) should be  key with which the specified value is to be associated.","['parameter', 'Map.compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)']"
"Map.merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction)","what's the return of Map.merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction)?","the return of Map.merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction) should be value - the non-null value to be merged with the existing value
        associated with the key or, if no existing value or a null value
        is associated with the key, to be associated with the key.","['return', 'Map.merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction)']"
"Map.merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction)","what's the parameter of Map.merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction)?","the parameter of Map.merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction) should be  key with which the resulting value is to be associated.","['parameter', 'Map.merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction)']"
MissingFormatArgumentException.getFormatSpecifier(),what's the return of MissingFormatArgumentException.getFormatSpecifier()?,the return of MissingFormatArgumentException.getFormatSpecifier() should be the unmatched format specifier..,"['return', 'MissingFormatArgumentException.getFormatSpecifier()']"
MissingFormatWidthException.getFormatSpecifier(),what's the return of MissingFormatWidthException.getFormatSpecifier()?,the return of MissingFormatWidthException.getFormatSpecifier() should be the format specifier which does not have a width..,"['return', 'MissingFormatWidthException.getFormatSpecifier()']"
MissingResourceException.getClassName(),what's the return of MissingResourceException.getClassName()?,the return of MissingResourceException.getClassName() should be the name of the resource class.,"['return', 'MissingResourceException.getClassName()']"
MissingResourceException.getKey(),what's the return of MissingResourceException.getKey()?,the return of MissingResourceException.getKey() should be the key for the missing resource.,"['return', 'MissingResourceException.getKey()']"
NavigableMap.lowerEntry(K key),what's the return of NavigableMap.lowerEntry(K key)?,"the return of NavigableMap.lowerEntry(K key) should be an entry with the greatest key less than key,
         or null if there is no such key.","['return', 'NavigableMap.lowerEntry(K key)']"
NavigableMap.lowerEntry(K key),what's the parameter of NavigableMap.lowerEntry(K key)?,the parameter of NavigableMap.lowerEntry(K key) should be  the key.,"['parameter', 'NavigableMap.lowerEntry(K key)']"
NavigableMap.lowerKey(K key),what's the return of NavigableMap.lowerKey(K key)?,"the return of NavigableMap.lowerKey(K key) should be the greatest key less than key,
         or null if there is no such key.","['return', 'NavigableMap.lowerKey(K key)']"
NavigableMap.lowerKey(K key),what's the parameter of NavigableMap.lowerKey(K key)?,the parameter of NavigableMap.lowerKey(K key) should be  the key.,"['parameter', 'NavigableMap.lowerKey(K key)']"
NavigableMap.floorEntry(K key),what's the return of NavigableMap.floorEntry(K key)?,"the return of NavigableMap.floorEntry(K key) should be an entry with the greatest key less than or equal to
         key, or null if there is no such key.","['return', 'NavigableMap.floorEntry(K key)']"
NavigableMap.floorEntry(K key),what's the parameter of NavigableMap.floorEntry(K key)?,the parameter of NavigableMap.floorEntry(K key) should be  the key.,"['parameter', 'NavigableMap.floorEntry(K key)']"
NavigableMap.floorKey(K key),what's the return of NavigableMap.floorKey(K key)?,"the return of NavigableMap.floorKey(K key) should be the greatest key less than or equal to key,
         or null if there is no such key.","['return', 'NavigableMap.floorKey(K key)']"
NavigableMap.floorKey(K key),what's the parameter of NavigableMap.floorKey(K key)?,the parameter of NavigableMap.floorKey(K key) should be  the key.,"['parameter', 'NavigableMap.floorKey(K key)']"
NavigableMap.ceilingEntry(K key),what's the return of NavigableMap.ceilingEntry(K key)?,"the return of NavigableMap.ceilingEntry(K key) should be an entry with the least key greater than or equal to
         key, or null if there is no such key.","['return', 'NavigableMap.ceilingEntry(K key)']"
NavigableMap.ceilingEntry(K key),what's the parameter of NavigableMap.ceilingEntry(K key)?,the parameter of NavigableMap.ceilingEntry(K key) should be  the key.,"['parameter', 'NavigableMap.ceilingEntry(K key)']"
NavigableMap.ceilingKey(K key),what's the return of NavigableMap.ceilingKey(K key)?,"the return of NavigableMap.ceilingKey(K key) should be the least key greater than or equal to key,
         or null if there is no such key.","['return', 'NavigableMap.ceilingKey(K key)']"
NavigableMap.ceilingKey(K key),what's the parameter of NavigableMap.ceilingKey(K key)?,the parameter of NavigableMap.ceilingKey(K key) should be  the key.,"['parameter', 'NavigableMap.ceilingKey(K key)']"
NavigableMap.higherEntry(K key),what's the return of NavigableMap.higherEntry(K key)?,"the return of NavigableMap.higherEntry(K key) should be an entry with the least key greater than key,
         or null if there is no such key.","['return', 'NavigableMap.higherEntry(K key)']"
NavigableMap.higherEntry(K key),what's the parameter of NavigableMap.higherEntry(K key)?,the parameter of NavigableMap.higherEntry(K key) should be  the key.,"['parameter', 'NavigableMap.higherEntry(K key)']"
NavigableMap.higherKey(K key),what's the return of NavigableMap.higherKey(K key)?,"the return of NavigableMap.higherKey(K key) should be the least key greater than key,
         or null if there is no such key.","['return', 'NavigableMap.higherKey(K key)']"
NavigableMap.higherKey(K key),what's the parameter of NavigableMap.higherKey(K key)?,the parameter of NavigableMap.higherKey(K key) should be  the key.,"['parameter', 'NavigableMap.higherKey(K key)']"
NavigableMap.firstEntry(),what's the return of NavigableMap.firstEntry()?,"the return of NavigableMap.firstEntry() should be an entry with the least key,
         or null if this map is empty.","['return', 'NavigableMap.firstEntry()']"
NavigableMap.lastEntry(),what's the return of NavigableMap.lastEntry()?,"the return of NavigableMap.lastEntry() should be an entry with the greatest key,
         or null if this map is empty.","['return', 'NavigableMap.lastEntry()']"
NavigableMap.pollFirstEntry(),what's the return of NavigableMap.pollFirstEntry()?,"the return of NavigableMap.pollFirstEntry() should be the removed first entry of this map,
         or null if this map is empty.","['return', 'NavigableMap.pollFirstEntry()']"
NavigableMap.pollLastEntry(),what's the return of NavigableMap.pollLastEntry()?,"the return of NavigableMap.pollLastEntry() should be the removed last entry of this map,
         or null if this map is empty.","['return', 'NavigableMap.pollLastEntry()']"
NavigableMap.descendingMap(),what's the return of NavigableMap.descendingMap()?,the return of NavigableMap.descendingMap() should be a reverse order view of this map.,"['return', 'NavigableMap.descendingMap()']"
NavigableMap.navigableKeySet(),what's the return of NavigableMap.navigableKeySet()?,the return of NavigableMap.navigableKeySet() should be a navigable set view of the keys in this map.,"['return', 'NavigableMap.navigableKeySet()']"
NavigableMap.descendingKeySet(),what's the return of NavigableMap.descendingKeySet()?,the return of NavigableMap.descendingKeySet() should be a reverse order navigable set view of the keys in this map.,"['return', 'NavigableMap.descendingKeySet()']"
"NavigableMap.subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)","what's the return of NavigableMap.subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)?","the return of NavigableMap.subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) should be fromInclusive - true if the low endpoint
        is to be included in the returned view.","['return', 'NavigableMap.subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)']"
"NavigableMap.subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)","what's the parameter of NavigableMap.subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)?","the parameter of NavigableMap.subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) should be  low endpoint of the keys in the returned map.","['parameter', 'NavigableMap.subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)']"
"NavigableMap.headMap(K toKey, boolean inclusive)","what's the return of NavigableMap.headMap(K toKey, boolean inclusive)?","the return of NavigableMap.headMap(K toKey, boolean inclusive) should be inclusive - true if the high endpoint
        is to be included in the returned view.","['return', 'NavigableMap.headMap(K toKey, boolean inclusive)']"
"NavigableMap.headMap(K toKey, boolean inclusive)","what's the parameter of NavigableMap.headMap(K toKey, boolean inclusive)?","the parameter of NavigableMap.headMap(K toKey, boolean inclusive) should be  high endpoint of the keys in the returned map.","['parameter', 'NavigableMap.headMap(K toKey, boolean inclusive)']"
"NavigableMap.tailMap(K fromKey, boolean inclusive)","what's the return of NavigableMap.tailMap(K fromKey, boolean inclusive)?","the return of NavigableMap.tailMap(K fromKey, boolean inclusive) should be inclusive - true if the low endpoint
        is to be included in the returned view.","['return', 'NavigableMap.tailMap(K fromKey, boolean inclusive)']"
"NavigableMap.tailMap(K fromKey, boolean inclusive)","what's the parameter of NavigableMap.tailMap(K fromKey, boolean inclusive)?","the parameter of NavigableMap.tailMap(K fromKey, boolean inclusive) should be  low endpoint of the keys in the returned map.","['parameter', 'NavigableMap.tailMap(K fromKey, boolean inclusive)']"
"SortedMap.subMap(K fromKey, K toKey)","what's the return of SortedMap.subMap(K fromKey, K toKey)?","the return of SortedMap.subMap(K fromKey, K toKey) should be a view of the portion of this map whose keys range from fromKey, inclusive, to toKey, exclusive. (If fromKey and toKey are equal, the returned map is empty.) The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports..","['return', 'SortedMap.subMap(K fromKey, K toKey)']"
"SortedMap.subMap(K fromKey, K toKey)","what's the parameter of SortedMap.subMap(K fromKey, K toKey)?","the parameter of SortedMap.subMap(K fromKey, K toKey) should be  low endpoint (inclusive) of the keys in the returned map.","['parameter', 'SortedMap.subMap(K fromKey, K toKey)']"
SortedMap.headMap(K toKey),what's the return of SortedMap.headMap(K toKey)?,"the return of SortedMap.headMap(K toKey) should be a view of the portion of this map whose keys are strictly less than toKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports..","['return', 'SortedMap.headMap(K toKey)']"
SortedMap.headMap(K toKey),what's the parameter of SortedMap.headMap(K toKey)?,the parameter of SortedMap.headMap(K toKey) should be  high endpoint (exclusive) of the keys in the returned map.,"['parameter', 'SortedMap.headMap(K toKey)']"
SortedMap.tailMap(K fromKey),what's the return of SortedMap.tailMap(K fromKey)?,"the return of SortedMap.tailMap(K fromKey) should be a view of the portion of this map whose keys are greater than or equal to fromKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports..","['return', 'SortedMap.tailMap(K fromKey)']"
SortedMap.tailMap(K fromKey),what's the parameter of SortedMap.tailMap(K fromKey)?,the parameter of SortedMap.tailMap(K fromKey) should be  low endpoint (inclusive) of the keys in the returned map.,"['parameter', 'SortedMap.tailMap(K fromKey)']"
NavigableSet.lower(E e),what's the return of NavigableSet.lower(E e)?,"the return of NavigableSet.lower(E e) should be the greatest element in this set strictly less than the given element, or null if there is no such element..","['return', 'NavigableSet.lower(E e)']"
NavigableSet.lower(E e),what's the parameter of NavigableSet.lower(E e)?,the parameter of NavigableSet.lower(E e) should be  the value to match.,"['parameter', 'NavigableSet.lower(E e)']"
NavigableSet.floor(E e),what's the return of NavigableSet.floor(E e)?,"the return of NavigableSet.floor(E e) should be the greatest element in this set less than or equal to the given element, or null if there is no such element..","['return', 'NavigableSet.floor(E e)']"
NavigableSet.floor(E e),what's the parameter of NavigableSet.floor(E e)?,the parameter of NavigableSet.floor(E e) should be  the value to match.,"['parameter', 'NavigableSet.floor(E e)']"
NavigableSet.ceiling(E e),what's the return of NavigableSet.ceiling(E e)?,"the return of NavigableSet.ceiling(E e) should be the least element in this set greater than or equal to the given element, or null if there is no such element..","['return', 'NavigableSet.ceiling(E e)']"
NavigableSet.ceiling(E e),what's the parameter of NavigableSet.ceiling(E e)?,the parameter of NavigableSet.ceiling(E e) should be  the value to match.,"['parameter', 'NavigableSet.ceiling(E e)']"
NavigableSet.higher(E e),what's the return of NavigableSet.higher(E e)?,"the return of NavigableSet.higher(E e) should be the least element in this set strictly greater than the given element, or null if there is no such element..","['return', 'NavigableSet.higher(E e)']"
NavigableSet.higher(E e),what's the parameter of NavigableSet.higher(E e)?,the parameter of NavigableSet.higher(E e) should be  the value to match.,"['parameter', 'NavigableSet.higher(E e)']"
NavigableSet.pollFirst(),what's the return of NavigableSet.pollFirst()?,"the return of NavigableSet.pollFirst() should be the first element, or null if this set is empty.","['return', 'NavigableSet.pollFirst()']"
NavigableSet.pollLast(),what's the return of NavigableSet.pollLast()?,"the return of NavigableSet.pollLast() should be the last element, or null if this set is empty.","['return', 'NavigableSet.pollLast()']"
Collection.iterator(),what's the return of Collection.iterator()?,the return of Collection.iterator() should be an iterator over the elements in this deque in proper sequence. The elements will be returned in order from first (head) to last (tail)..,"['return', 'Collection.iterator()']"
NavigableSet.descendingSet(),what's the return of NavigableSet.descendingSet()?,"the return of NavigableSet.descendingSet() should be a reverse order view of the elements contained in this set. The descending set is backed by this set, so changes to the set are reflected in the descending set, and vice-versa. If either set is modified while an iteration over either set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined..","['return', 'NavigableSet.descendingSet()']"
NavigableSet.descendingIterator(),what's the return of NavigableSet.descendingIterator()?,"the return of NavigableSet.descendingIterator() should be an iterator over the elements in this set, in descending order. Equivalent in effect to descendingSet().iterator()..","['return', 'NavigableSet.descendingIterator()']"
"NavigableSet.subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)","what's the return of NavigableSet.subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)?","the return of NavigableSet.subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) should be a view of the portion of this set whose elements range from fromElement to toElement. If fromElement and toElement are equal, the returned set is empty unless fromInclusive and toInclusive are both true. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports..","['return', 'NavigableSet.subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)']"
"NavigableSet.subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)","what's the parameter of NavigableSet.subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)?","the parameter of NavigableSet.subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) should be  low endpoint of the returned set.","['parameter', 'NavigableSet.subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)']"
"NavigableSet.headSet(E toElement, boolean inclusive)","what's the return of NavigableSet.headSet(E toElement, boolean inclusive)?","the return of NavigableSet.headSet(E toElement, boolean inclusive) should be a view of the portion of this set whose elements are less than (or equal to, if inclusive is true) toElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports..","['return', 'NavigableSet.headSet(E toElement, boolean inclusive)']"
"NavigableSet.headSet(E toElement, boolean inclusive)","what's the parameter of NavigableSet.headSet(E toElement, boolean inclusive)?","the parameter of NavigableSet.headSet(E toElement, boolean inclusive) should be  high endpoint of the returned set.","['parameter', 'NavigableSet.headSet(E toElement, boolean inclusive)']"
"NavigableSet.tailSet(E fromElement, boolean inclusive)","what's the return of NavigableSet.tailSet(E fromElement, boolean inclusive)?","the return of NavigableSet.tailSet(E fromElement, boolean inclusive) should be a view of the portion of this set whose elements are greater than (or equal to, if inclusive is true) fromElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports..","['return', 'NavigableSet.tailSet(E fromElement, boolean inclusive)']"
"NavigableSet.tailSet(E fromElement, boolean inclusive)","what's the parameter of NavigableSet.tailSet(E fromElement, boolean inclusive)?","the parameter of NavigableSet.tailSet(E fromElement, boolean inclusive) should be  low endpoint of the returned set.","['parameter', 'NavigableSet.tailSet(E fromElement, boolean inclusive)']"
"SortedSet.subSet(E fromElement, E toElement)","what's the return of SortedSet.subSet(E fromElement, E toElement)?","the return of SortedSet.subSet(E fromElement, E toElement) should be a view of the portion of this set whose elements range from fromElement, inclusive, to toElement, exclusive. (If fromElement and toElement are equal, the returned set is empty.) The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports..","['return', 'SortedSet.subSet(E fromElement, E toElement)']"
"SortedSet.subSet(E fromElement, E toElement)","what's the parameter of SortedSet.subSet(E fromElement, E toElement)?","the parameter of SortedSet.subSet(E fromElement, E toElement) should be  low endpoint (inclusive) of the returned set.","['parameter', 'SortedSet.subSet(E fromElement, E toElement)']"
SortedSet.headSet(E toElement),what's the return of SortedSet.headSet(E toElement)?,"the return of SortedSet.headSet(E toElement) should be a view of the portion of this set whose elements are strictly less than toElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports..","['return', 'SortedSet.headSet(E toElement)']"
SortedSet.headSet(E toElement),what's the parameter of SortedSet.headSet(E toElement)?,the parameter of SortedSet.headSet(E toElement) should be  high endpoint (exclusive) of the returned set.,"['parameter', 'SortedSet.headSet(E toElement)']"
SortedSet.tailSet(E fromElement),what's the return of SortedSet.tailSet(E fromElement)?,"the return of SortedSet.tailSet(E fromElement) should be a view of the portion of this set whose elements are greater than or equal to fromElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports..","['return', 'SortedSet.tailSet(E fromElement)']"
SortedSet.tailSet(E fromElement),what's the parameter of SortedSet.tailSet(E fromElement)?,the parameter of SortedSet.tailSet(E fromElement) should be  low endpoint (inclusive) of the returned set.,"['parameter', 'SortedSet.tailSet(E fromElement)']"
"Objects.equals(Object a, Object b)","what's the return of Objects.equals(Object a, Object b)?","the return of Objects.equals(Object a, Object b) should be true if the arguments are equal to each other and false otherwise. Consequently, if both arguments are null, true is returned and if exactly one argument is null, false is returned. Otherwise, equality is determined by using the equals method of the first argument..","['return', 'Objects.equals(Object a, Object b)']"
"Objects.equals(Object a, Object b)","what's the parameter of Objects.equals(Object a, Object b)?","the parameter of Objects.equals(Object a, Object b) should be  an object.","['parameter', 'Objects.equals(Object a, Object b)']"
"Objects.deepEquals(Object a, Object b)","what's the return of Objects.deepEquals(Object a, Object b)?","the return of Objects.deepEquals(Object a, Object b) should be true if the arguments are deeply equal to each other and false otherwise. Two null values are deeply equal. If both arguments are arrays, the algorithm in Arrays.deepEquals is used to determine equality. Otherwise, equality is determined by using the equals method of the first argument..","['return', 'Objects.deepEquals(Object a, Object b)']"
"Objects.deepEquals(Object a, Object b)","what's the parameter of Objects.deepEquals(Object a, Object b)?","the parameter of Objects.deepEquals(Object a, Object b) should be  an object.","['parameter', 'Objects.deepEquals(Object a, Object b)']"
Objects.hashCode(Object o),what's the return of Objects.hashCode(Object o)?,the return of Objects.hashCode(Object o) should be the hash code of a non-null argument and 0 for a null argument..,"['return', 'Objects.hashCode(Object o)']"
Objects.hashCode(Object o),what's the parameter of Objects.hashCode(Object o)?,the parameter of Objects.hashCode(Object o) should be  an object.,"['parameter', 'Objects.hashCode(Object o)']"
Objects.hash(Object... values),what's the return of Objects.hash(Object... values)?,the return of Objects.hash(Object... values) should be a hash value of the sequence of input values.,"['return', 'Objects.hash(Object... values)']"
Objects.toString(Object o),what's the return of Objects.toString(Object o)?,"the return of Objects.toString(Object o) should be the result of calling toString for a non-null argument and ""null"" for a null argument..","['return', 'Objects.toString(Object o)']"
Objects.toString(Object o),what's the parameter of Objects.toString(Object o)?,the parameter of Objects.toString(Object o) should be  an object.,"['parameter', 'Objects.toString(Object o)']"
"Objects.toString(Object o, String nullDefault)","what's the return of Objects.toString(Object o, String nullDefault)?","the return of Objects.toString(Object o, String nullDefault) should be the result of calling toString on the first argument if the first argument is not null and returns the second argument otherwise..","['return', 'Objects.toString(Object o, String nullDefault)']"
"Objects.toString(Object o, String nullDefault)","what's the parameter of Objects.toString(Object o, String nullDefault)?","the parameter of Objects.toString(Object o, String nullDefault) should be  an object.","['parameter', 'Objects.toString(Object o, String nullDefault)']"
"Objects.toString(Object o, String nullDefault)","what's the parameter of Objects.toString(Object o, String nullDefault)?","the parameter of Objects.toString(Object o, String nullDefault) should be  an object.","['parameter', 'Objects.toString(Object o, String nullDefault)']"
"Objects.compare(T a, T b, Comparator<? super T> c)","what's the return of Objects.compare(T a, T b, Comparator<? super T> c)?","the return of Objects.compare(T a, T b, Comparator<? super T> c) should be 0 if the arguments are identical and c.compare(a, b) otherwise. Consequently, if both arguments are null 0 is returned..","['return', 'Objects.compare(T a, T b, Comparator<? super T> c)']"
Objects.requireNonNull(T obj),what's the return of Objects.requireNonNull(T obj)?,the return of Objects.requireNonNull(T obj) should be obj if not null.,"['return', 'Objects.requireNonNull(T obj)']"
"Objects.requireNonNull(T obj, String message)","what's the return of Objects.requireNonNull(T obj, String message)?","the return of Objects.requireNonNull(T obj, String message) should be message - detail message to be used in the event that a NullPointerException is thrown.","['return', 'Objects.requireNonNull(T obj, String message)']"
"Objects.requireNonNull(T obj, String message)","what's the parameter of Objects.requireNonNull(T obj, String message)?","the parameter of Objects.requireNonNull(T obj, String message) should be  the object reference to check for nullity.","['parameter', 'Objects.requireNonNull(T obj, String message)']"
Objects.isNull(Object obj),what's the return of Objects.isNull(Object obj)?,the return of Objects.isNull(Object obj) should be true if the provided reference is null otherwise returns false..,"['return', 'Objects.isNull(Object obj)']"
Objects.isNull(Object obj),what's the parameter of Objects.isNull(Object obj)?,the parameter of Objects.isNull(Object obj) should be  a reference to be checked against null.,"['parameter', 'Objects.isNull(Object obj)']"
Objects.nonNull(Object obj),what's the return of Objects.nonNull(Object obj)?,the return of Objects.nonNull(Object obj) should be true if the provided reference is non-null otherwise returns false..,"['return', 'Objects.nonNull(Object obj)']"
Objects.nonNull(Object obj),what's the parameter of Objects.nonNull(Object obj)?,the parameter of Objects.nonNull(Object obj) should be  a reference to be checked against null.,"['parameter', 'Objects.nonNull(Object obj)']"
"Objects.requireNonNull(T obj, Supplier<String> messageSupplier)","what's the return of Objects.requireNonNull(T obj, Supplier<String> messageSupplier)?","the return of Objects.requireNonNull(T obj, Supplier<String> messageSupplier) should be messageSupplier - supplier of the detail message to be
 used in the event that a NullPointerException is thrown.","['return', 'Objects.requireNonNull(T obj, Supplier<String> messageSupplier)']"
Observable.addObserver(Observer o),what's the parameter of Observable.addObserver(Observer o)?,the parameter of Observable.addObserver(Observer o) should be  an observer to be added..,"['parameter', 'Observable.addObserver(Observer o)']"
Observable.deleteObserver(Observer o),what's the parameter of Observable.deleteObserver(Observer o)?,the parameter of Observable.deleteObserver(Observer o) should be  the observer to be deleted..,"['parameter', 'Observable.deleteObserver(Observer o)']"
Observable.notifyObservers(Object arg),what's the parameter of Observable.notifyObservers(Object arg)?,the parameter of Observable.notifyObservers(Object arg) should be  any object..,"['parameter', 'Observable.notifyObservers(Object arg)']"
"Observer.update(Observable o, Object arg)","what's the parameter of Observer.update(Observable o, Object arg)?","the parameter of Observer.update(Observable o, Object arg) should be  the observable object..","['parameter', 'Observer.update(Observable o, Object arg)']"
"Observer.update(Observable o, Object arg)","what's the parameter of Observer.update(Observable o, Object arg)?","the parameter of Observer.update(Observable o, Object arg) should be  the observable object..","['parameter', 'Observer.update(Observable o, Object arg)']"
Object.equals(Object obj),what's the return of Object.equals(Object obj)?,"the return of Object.equals(Object obj) should be true if the objects are the same;
          false otherwise..","['return', 'Object.equals(Object obj)']"
Object.equals(Object obj),what's the parameter of Object.equals(Object obj)?,the parameter of Object.equals(Object obj) should be  the object to compare with..,"['parameter', 'Object.equals(Object obj)']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
Object.equals(Object obj),what's the return of Object.equals(Object obj)?,"the return of Object.equals(Object obj) should be true if the objects are the same;
          false otherwise..","['return', 'Object.equals(Object obj)']"
Object.equals(Object obj),what's the parameter of Object.equals(Object obj)?,the parameter of Object.equals(Object obj) should be  the object to compare with..,"['parameter', 'Object.equals(Object obj)']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
OptionalInt.empty(),what's the return of OptionalInt.empty()?,the return of OptionalInt.empty() should be an empty OptionalInt instance. No value is present for this OptionalInt..,"['return', 'OptionalInt.empty()']"
OptionalInt.of(int value),what's the return of OptionalInt.of(int value)?,the return of OptionalInt.of(int value) should be an OptionalInt with the value present.,"['return', 'OptionalInt.of(int value)']"
OptionalInt.getAsInt(),what's the return of OptionalInt.getAsInt()?,the return of OptionalInt.getAsInt() should be the value held by this OptionalInt.,"['return', 'OptionalInt.getAsInt()']"
OptionalInt.isPresent(),what's the return of OptionalInt.isPresent()?,"the return of OptionalInt.isPresent() should be true if there is a value present, otherwise false.","['return', 'OptionalInt.isPresent()']"
OptionalInt.ifPresent(IntConsumer consumer),what's the parameter of OptionalInt.ifPresent(IntConsumer consumer)?,the parameter of OptionalInt.ifPresent(IntConsumer consumer) should be  block to be executed if a value is present.,"['parameter', 'OptionalInt.ifPresent(IntConsumer consumer)']"
OptionalInt.orElse(int other),what's the return of OptionalInt.orElse(int other)?,"the return of OptionalInt.orElse(int other) should be the value, if present, otherwise other.","['return', 'OptionalInt.orElse(int other)']"
OptionalInt.orElseGet(IntSupplier other),what's the return of OptionalInt.orElseGet(IntSupplier other)?,the return of OptionalInt.orElseGet(IntSupplier other) should be the value if present otherwise the result of other.getAsInt().,"['return', 'OptionalInt.orElseGet(IntSupplier other)']"
OptionalInt.orElseGet(IntSupplier other),what's the parameter of OptionalInt.orElseGet(IntSupplier other)?,"the parameter of OptionalInt.orElseGet(IntSupplier other) should be  a IntSupplier whose result is returned if no value
 is present.","['parameter', 'OptionalInt.orElseGet(IntSupplier other)']"
OptionalInt.orElseThrow(Supplier<X> exceptionSupplier),what's the return of OptionalInt.orElseThrow(Supplier<X> exceptionSupplier)?,the return of OptionalInt.orElseThrow(Supplier<X> exceptionSupplier) should be the present value.,"['return', 'OptionalInt.orElseThrow(Supplier<X> exceptionSupplier)']"
Object.equals(Object obj),what's the return of Object.equals(Object obj)?,"the return of Object.equals(Object obj) should be true if the objects are the same;
          false otherwise..","['return', 'Object.equals(Object obj)']"
Object.equals(Object obj),what's the parameter of Object.equals(Object obj)?,the parameter of Object.equals(Object obj) should be  the object to compare with..,"['parameter', 'Object.equals(Object obj)']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
Object.equals(Object obj),what's the return of Object.equals(Object obj)?,"the return of Object.equals(Object obj) should be true if the objects are the same;
          false otherwise..","['return', 'Object.equals(Object obj)']"
Object.equals(Object obj),what's the parameter of Object.equals(Object obj)?,the parameter of Object.equals(Object obj) should be  the object to compare with..,"['parameter', 'Object.equals(Object obj)']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
Iterator.next(),what's the return of Iterator.next()?,the return of Iterator.next() should be the next element in the iteration..,"['return', 'Iterator.next()']"
PrimitiveIterator.OfInt.nextInt(),what's the return of PrimitiveIterator.OfInt.nextInt()?,the return of PrimitiveIterator.OfInt.nextInt() should be the next int element in the iteration..,"['return', 'PrimitiveIterator.OfInt.nextInt()']"
PrimitiveIterator.forEachRemaining(IntConsumer action),what's the parameter of PrimitiveIterator.forEachRemaining(IntConsumer action)?,the parameter of PrimitiveIterator.forEachRemaining(IntConsumer action) should be  The action to be performed for each element.,"['parameter', 'PrimitiveIterator.forEachRemaining(IntConsumer action)']"
Iterator.next(),what's the return of Iterator.next()?,the return of Iterator.next() should be the next element in the iteration..,"['return', 'Iterator.next()']"
PrimitiveIterator.OfLong.nextLong(),what's the return of PrimitiveIterator.OfLong.nextLong()?,the return of PrimitiveIterator.OfLong.nextLong() should be the next long element in the iteration..,"['return', 'PrimitiveIterator.OfLong.nextLong()']"
PrimitiveIterator.forEachRemaining(LongConsumer action),what's the parameter of PrimitiveIterator.forEachRemaining(LongConsumer action)?,the parameter of PrimitiveIterator.forEachRemaining(LongConsumer action) should be  The action to be performed for each element.,"['parameter', 'PrimitiveIterator.forEachRemaining(LongConsumer action)']"
Iterator.next(),what's the return of Iterator.next()?,the return of Iterator.next() should be the next element in the iteration..,"['return', 'Iterator.next()']"
Queue.offer(E e),what's the return of Queue.offer(E e)?,"the return of Queue.offer(E e) should be true if the element was added to this deque, else
         false.","['return', 'Queue.offer(E e)']"
Queue.offer(E e),what's the parameter of Queue.offer(E e)?,the parameter of Queue.offer(E e) should be  the element to add.,"['parameter', 'Queue.offer(E e)']"
Queue.peek(),what's the return of Queue.peek()?,"the return of Queue.peek() should be the head of the queue represented by this deque, or
         null if this deque is empty.","['return', 'Queue.peek()']"
Iterable.iterator(),what's the return of Iterable.iterator()?,the return of Iterable.iterator() should be an iterator over the elements in this list in proper sequence..,"['return', 'Iterable.iterator()']"
Collection.size(),what's the return of Collection.size()?,the return of Collection.size() should be the number of elements in this deque..,"['return', 'Collection.size()']"
Queue.poll(),what's the return of Queue.poll()?,"the return of Queue.poll() should be the first element of this deque, or null if
         this deque is empty.","['return', 'Queue.poll()']"
PriorityQueue.comparator(),what's the return of PriorityQueue.comparator()?,"the return of PriorityQueue.comparator() should be the comparator used to order the elements in this queue, or null if this queue is sorted according to the natural ordering of its elements..","['return', 'PriorityQueue.comparator()']"
Iterable.spliterator(),what's the return of Iterable.spliterator()?,the return of Iterable.spliterator() should be a Spliterator over the elements in this list.,"['return', 'Iterable.spliterator()']"
"Properties.setProperty(String key, String value)","what's the return of Properties.setProperty(String key, String value)?","the return of Properties.setProperty(String key, String value) should be value - the value corresponding to key..","['return', 'Properties.setProperty(String key, String value)']"
"Properties.setProperty(String key, String value)","what's the parameter of Properties.setProperty(String key, String value)?","the parameter of Properties.setProperty(String key, String value) should be  the key to be placed into this property list..","['parameter', 'Properties.setProperty(String key, String value)']"
Properties.load(Reader reader),what's the parameter of Properties.load(Reader reader)?,the parameter of Properties.load(Reader reader) should be  the input character stream..,"['parameter', 'Properties.load(Reader reader)']"
Properties.load(InputStream inStream),what's the parameter of Properties.load(InputStream inStream)?,the parameter of Properties.load(InputStream inStream) should be  the input stream..,"['parameter', 'Properties.load(InputStream inStream)']"
"Properties.save(OutputStream out, String comments)","what's the parameter of Properties.save(OutputStream out, String comments)?","the parameter of Properties.save(OutputStream out, String comments) should be  an output stream..","['parameter', 'Properties.save(OutputStream out, String comments)']"
"Properties.save(OutputStream out, String comments)","what's the parameter of Properties.save(OutputStream out, String comments)?","the parameter of Properties.save(OutputStream out, String comments) should be  an output stream..","['parameter', 'Properties.save(OutputStream out, String comments)']"
"Properties.store(Writer writer, String comments)","what's the parameter of Properties.store(Writer writer, String comments)?","the parameter of Properties.store(Writer writer, String comments) should be  an output character stream writer..","['parameter', 'Properties.store(Writer writer, String comments)']"
"Properties.store(Writer writer, String comments)","what's the parameter of Properties.store(Writer writer, String comments)?","the parameter of Properties.store(Writer writer, String comments) should be  an output character stream writer..","['parameter', 'Properties.store(Writer writer, String comments)']"
"Properties.store(OutputStream out, String comments)","what's the parameter of Properties.store(OutputStream out, String comments)?","the parameter of Properties.store(OutputStream out, String comments) should be  an output stream..","['parameter', 'Properties.store(OutputStream out, String comments)']"
"Properties.store(OutputStream out, String comments)","what's the parameter of Properties.store(OutputStream out, String comments)?","the parameter of Properties.store(OutputStream out, String comments) should be  an output stream..","['parameter', 'Properties.store(OutputStream out, String comments)']"
Properties.loadFromXML(InputStream in),what's the parameter of Properties.loadFromXML(InputStream in)?,the parameter of Properties.loadFromXML(InputStream in) should be  the input stream from which to read the XML document..,"['parameter', 'Properties.loadFromXML(InputStream in)']"
"Properties.storeToXML(OutputStream os, String comment)","what's the parameter of Properties.storeToXML(OutputStream os, String comment)?","the parameter of Properties.storeToXML(OutputStream os, String comment) should be  the output stream on which to emit the XML document..","['parameter', 'Properties.storeToXML(OutputStream os, String comment)']"
"Properties.storeToXML(OutputStream os, String comment)","what's the parameter of Properties.storeToXML(OutputStream os, String comment)?","the parameter of Properties.storeToXML(OutputStream os, String comment) should be  the output stream on which to emit the XML document..","['parameter', 'Properties.storeToXML(OutputStream os, String comment)']"
"Properties.storeToXML(OutputStream os, String comment, String encoding)","what's the parameter of Properties.storeToXML(OutputStream os, String comment, String encoding)?","the parameter of Properties.storeToXML(OutputStream os, String comment, String encoding) should be  the output stream on which to emit the XML document..","['parameter', 'Properties.storeToXML(OutputStream os, String comment, String encoding)']"
"Properties.storeToXML(OutputStream os, String comment, String encoding)","what's the parameter of Properties.storeToXML(OutputStream os, String comment, String encoding)?","the parameter of Properties.storeToXML(OutputStream os, String comment, String encoding) should be  the output stream on which to emit the XML document..","['parameter', 'Properties.storeToXML(OutputStream os, String comment, String encoding)']"
Properties.getProperty(String key),what's the return of Properties.getProperty(String key)?,the return of Properties.getProperty(String key) should be the value in this property list with the specified key value..,"['return', 'Properties.getProperty(String key)']"
Properties.getProperty(String key),what's the parameter of Properties.getProperty(String key)?,the parameter of Properties.getProperty(String key) should be  the property key..,"['parameter', 'Properties.getProperty(String key)']"
"Properties.getProperty(String key, String defaultValue)","what's the return of Properties.getProperty(String key, String defaultValue)?","the return of Properties.getProperty(String key, String defaultValue) should be defaultValue - a default value..","['return', 'Properties.getProperty(String key, String defaultValue)']"
"Properties.getProperty(String key, String defaultValue)","what's the parameter of Properties.getProperty(String key, String defaultValue)?","the parameter of Properties.getProperty(String key, String defaultValue) should be  the hashtable key..","['parameter', 'Properties.getProperty(String key, String defaultValue)']"
Properties.propertyNames(),what's the return of Properties.propertyNames()?,"the return of Properties.propertyNames() should be an enumeration of all the keys in this property list, including distinct keys in the default property list if a key of the same name has not already been found from the main properties list..","['return', 'Properties.propertyNames()']"
Properties.stringPropertyNames(),what's the return of Properties.stringPropertyNames()?,"the return of Properties.stringPropertyNames() should be a set of keys in this property list where the key and its corresponding value are strings, including distinct keys in the default property list if a key of the same name has not already been found from the main properties list. Properties whose key or value is not of type String are omitted..","['return', 'Properties.stringPropertyNames()']"
Properties.list(PrintStream out),what's the parameter of Properties.list(PrintStream out)?,the parameter of Properties.list(PrintStream out) should be  an output stream..,"['parameter', 'Properties.list(PrintStream out)']"
Properties.list(PrintWriter out),what's the parameter of Properties.list(PrintWriter out)?,the parameter of Properties.list(PrintWriter out) should be  an output stream..,"['parameter', 'Properties.list(PrintWriter out)']"
ResourceBundle.handleGetObject(String key),what's the return of ResourceBundle.handleGetObject(String key)?,"the return of ResourceBundle.handleGetObject(String key) should be the object for the given key, or null.","['return', 'ResourceBundle.handleGetObject(String key)']"
ResourceBundle.handleGetObject(String key),what's the parameter of ResourceBundle.handleGetObject(String key)?,the parameter of ResourceBundle.handleGetObject(String key) should be  the key for the desired object.,"['parameter', 'ResourceBundle.handleGetObject(String key)']"
ResourceBundle.getKeys(),what's the return of ResourceBundle.getKeys()?,the return of ResourceBundle.getKeys() should be an Enumeration of the keys contained in this ResourceBundle and its parent bundles..,"['return', 'ResourceBundle.getKeys()']"
Collection.add(E e),what's the return of Collection.add(E e)?,the return of Collection.add(E e) should be true (as specified by Collection.add(E)).,"['return', 'Collection.add(E e)']"
Collection.add(E e),what's the parameter of Collection.add(E e)?,the parameter of Collection.add(E e) should be  the element to add.,"['parameter', 'Collection.add(E e)']"
Queue.offer(E e),what's the return of Queue.offer(E e)?,"the return of Queue.offer(E e) should be true if the element was added to this deque, else
         false.","['return', 'Queue.offer(E e)']"
Queue.offer(E e),what's the parameter of Queue.offer(E e)?,the parameter of Queue.offer(E e) should be  the element to add.,"['parameter', 'Queue.offer(E e)']"
Queue.remove(),what's the return of Queue.remove()?,the return of Queue.remove() should be the head of the queue represented by this deque.,"['return', 'Queue.remove()']"
Queue.poll(),what's the return of Queue.poll()?,"the return of Queue.poll() should be the first element of this deque, or null if
         this deque is empty.","['return', 'Queue.poll()']"
Queue.element(),what's the return of Queue.element()?,the return of Queue.element() should be the head of the queue represented by this deque.,"['return', 'Queue.element()']"
Queue.peek(),what's the return of Queue.peek()?,"the return of Queue.peek() should be the head of the queue represented by this deque, or
         null if this deque is empty.","['return', 'Queue.peek()']"
ResourceBundle.handleGetObject(String key),what's the return of ResourceBundle.handleGetObject(String key)?,"the return of ResourceBundle.handleGetObject(String key) should be the object for the given key, or null.","['return', 'ResourceBundle.handleGetObject(String key)']"
ResourceBundle.handleGetObject(String key),what's the parameter of ResourceBundle.handleGetObject(String key)?,the parameter of ResourceBundle.handleGetObject(String key) should be  the key for the desired object.,"['parameter', 'ResourceBundle.handleGetObject(String key)']"
ResourceBundle.getKeys(),what's the return of ResourceBundle.getKeys()?,the return of ResourceBundle.getKeys() should be an Enumeration of the keys contained in this ResourceBundle and its parent bundles..,"['return', 'ResourceBundle.getKeys()']"
Scanner.ioException(),what's the return of Scanner.ioException()?,the return of Scanner.ioException() should be the IOException last thrown by this Scanner's underlying Readable. This method returns null if no such exception exists..,"['return', 'Scanner.ioException()']"
Scanner.delimiter(),what's the return of Scanner.delimiter()?,the return of Scanner.delimiter() should be the Pattern this Scanner is currently using to match delimiters..,"['return', 'Scanner.delimiter()']"
Scanner.useDelimiter(Pattern pattern),what's the return of Scanner.useDelimiter(Pattern pattern)?,the return of Scanner.useDelimiter(Pattern pattern) should be this scanner.,"['return', 'Scanner.useDelimiter(Pattern pattern)']"
Scanner.useDelimiter(Pattern pattern),what's the parameter of Scanner.useDelimiter(Pattern pattern)?,the parameter of Scanner.useDelimiter(Pattern pattern) should be  A delimiting pattern.,"['parameter', 'Scanner.useDelimiter(Pattern pattern)']"
Scanner.useDelimiter(String pattern),what's the return of Scanner.useDelimiter(String pattern)?,the return of Scanner.useDelimiter(String pattern) should be this scanner.,"['return', 'Scanner.useDelimiter(String pattern)']"
Scanner.useDelimiter(String pattern),what's the parameter of Scanner.useDelimiter(String pattern)?,the parameter of Scanner.useDelimiter(String pattern) should be  A string specifying a delimiting pattern.,"['parameter', 'Scanner.useDelimiter(String pattern)']"
Scanner.locale(),what's the return of Scanner.locale()?,the return of Scanner.locale() should be this scanner's locale..,"['return', 'Scanner.locale()']"
Scanner.useLocale(Locale locale),what's the return of Scanner.useLocale(Locale locale)?,the return of Scanner.useLocale(Locale locale) should be this scanner.,"['return', 'Scanner.useLocale(Locale locale)']"
Scanner.useLocale(Locale locale),what's the parameter of Scanner.useLocale(Locale locale)?,the parameter of Scanner.useLocale(Locale locale) should be  A string specifying the locale to use.,"['parameter', 'Scanner.useLocale(Locale locale)']"
Scanner.radix(),what's the return of Scanner.radix()?,the return of Scanner.radix() should be this scanner's default radix..,"['return', 'Scanner.radix()']"
Scanner.useRadix(int radix),what's the return of Scanner.useRadix(int radix)?,the return of Scanner.useRadix(int radix) should be this scanner.,"['return', 'Scanner.useRadix(int radix)']"
Scanner.match(),what's the return of Scanner.match()?,"the return of Scanner.match() should be the match result of the last scanning operation performed by this scanner. This method throws IllegalStateException if no match has been performed, or if the last match was not successful..","['return', 'Scanner.match()']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
Iterator.hasNext(),what's the return of Iterator.hasNext()?,"the return of Iterator.hasNext() should be true if the iteration has more elements. (In other words, returns true if next() would return an element rather than throwing an exception.).","['return', 'Iterator.hasNext()']"
Iterator.next(),what's the return of Iterator.next()?,the return of Iterator.next() should be the next element in the iteration..,"['return', 'Iterator.next()']"
Scanner.hasNext(String pattern),what's the return of Scanner.hasNext(String pattern)?,the return of Scanner.hasNext(String pattern) should be true if the next token matches the pattern constructed from the specified string. The scanner does not advance past any input..,"['return', 'Scanner.hasNext(String pattern)']"
Scanner.hasNext(String pattern),what's the parameter of Scanner.hasNext(String pattern)?,the parameter of Scanner.hasNext(String pattern) should be  a string specifying the pattern to scan.,"['parameter', 'Scanner.hasNext(String pattern)']"
Scanner.next(String pattern),what's the return of Scanner.next(String pattern)?,"the return of Scanner.next(String pattern) should be the next token if it matches the pattern constructed from the specified string. If the match is successful, the scanner advances past the input that matched the pattern..","['return', 'Scanner.next(String pattern)']"
Scanner.next(String pattern),what's the parameter of Scanner.next(String pattern)?,the parameter of Scanner.next(String pattern) should be  a string specifying the pattern to scan.,"['parameter', 'Scanner.next(String pattern)']"
Scanner.hasNext(Pattern pattern),what's the return of Scanner.hasNext(Pattern pattern)?,the return of Scanner.hasNext(Pattern pattern) should be true if the next complete token matches the specified pattern. A complete token is prefixed and postfixed by input that matches the delimiter pattern. This method may block while waiting for input. The scanner does not advance past any input..,"['return', 'Scanner.hasNext(Pattern pattern)']"
Scanner.hasNext(Pattern pattern),what's the parameter of Scanner.hasNext(Pattern pattern)?,the parameter of Scanner.hasNext(Pattern pattern) should be  the pattern to scan for.,"['parameter', 'Scanner.hasNext(Pattern pattern)']"
Scanner.next(Pattern pattern),what's the return of Scanner.next(Pattern pattern)?,"the return of Scanner.next(Pattern pattern) should be the next token if it matches the specified pattern. This method may block while waiting for input to scan, even if a previous invocation of hasNext(Pattern) returned true. If the match is successful, the scanner advances past the input that matched the pattern..","['return', 'Scanner.next(Pattern pattern)']"
Scanner.next(Pattern pattern),what's the parameter of Scanner.next(Pattern pattern)?,the parameter of Scanner.next(Pattern pattern) should be  the pattern to scan for.,"['parameter', 'Scanner.next(Pattern pattern)']"
Scanner.hasNextLine(),what's the return of Scanner.hasNextLine()?,the return of Scanner.hasNextLine() should be true if there is another line in the input of this scanner. This method may block while waiting for input. The scanner does not advance past any input..,"['return', 'Scanner.hasNextLine()']"
Scanner.nextLine(),what's the return of Scanner.nextLine()?,the return of Scanner.nextLine() should be the line that was skipped.,"['return', 'Scanner.nextLine()']"
Scanner.findInLine(String pattern),what's the return of Scanner.findInLine(String pattern)?,the return of Scanner.findInLine(String pattern) should be the text that matched the specified pattern.,"['return', 'Scanner.findInLine(String pattern)']"
Scanner.findInLine(String pattern),what's the parameter of Scanner.findInLine(String pattern)?,the parameter of Scanner.findInLine(String pattern) should be  a string specifying the pattern to search for.,"['parameter', 'Scanner.findInLine(String pattern)']"
Scanner.findInLine(Pattern pattern),what's the return of Scanner.findInLine(Pattern pattern)?,the return of Scanner.findInLine(Pattern pattern) should be the text that matched the specified pattern.,"['return', 'Scanner.findInLine(Pattern pattern)']"
Scanner.findInLine(Pattern pattern),what's the parameter of Scanner.findInLine(Pattern pattern)?,the parameter of Scanner.findInLine(Pattern pattern) should be  the pattern to scan for.,"['parameter', 'Scanner.findInLine(Pattern pattern)']"
"Scanner.findWithinHorizon(String pattern, int horizon)","what's the return of Scanner.findWithinHorizon(String pattern, int horizon)?","the return of Scanner.findWithinHorizon(String pattern, int horizon) should be horizon - the search horizon.","['return', 'Scanner.findWithinHorizon(String pattern, int horizon)']"
"Scanner.findWithinHorizon(String pattern, int horizon)","what's the parameter of Scanner.findWithinHorizon(String pattern, int horizon)?","the parameter of Scanner.findWithinHorizon(String pattern, int horizon) should be  a string specifying the pattern to search for.","['parameter', 'Scanner.findWithinHorizon(String pattern, int horizon)']"
"Scanner.findWithinHorizon(Pattern pattern, int horizon)","what's the return of Scanner.findWithinHorizon(Pattern pattern, int horizon)?","the return of Scanner.findWithinHorizon(Pattern pattern, int horizon) should be horizon - the search horizon.","['return', 'Scanner.findWithinHorizon(Pattern pattern, int horizon)']"
"Scanner.findWithinHorizon(Pattern pattern, int horizon)","what's the parameter of Scanner.findWithinHorizon(Pattern pattern, int horizon)?","the parameter of Scanner.findWithinHorizon(Pattern pattern, int horizon) should be  the pattern to scan for.","['parameter', 'Scanner.findWithinHorizon(Pattern pattern, int horizon)']"
Scanner.skip(Pattern pattern),what's the return of Scanner.skip(Pattern pattern)?,the return of Scanner.skip(Pattern pattern) should be this scanner.,"['return', 'Scanner.skip(Pattern pattern)']"
Scanner.skip(Pattern pattern),what's the parameter of Scanner.skip(Pattern pattern)?,the parameter of Scanner.skip(Pattern pattern) should be  a string specifying the pattern to skip over.,"['parameter', 'Scanner.skip(Pattern pattern)']"
Scanner.skip(String pattern),what's the return of Scanner.skip(String pattern)?,the return of Scanner.skip(String pattern) should be this scanner.,"['return', 'Scanner.skip(String pattern)']"
Scanner.skip(String pattern),what's the parameter of Scanner.skip(String pattern)?,the parameter of Scanner.skip(String pattern) should be  a string specifying the pattern to skip over.,"['parameter', 'Scanner.skip(String pattern)']"
Scanner.hasNextBoolean(),what's the return of Scanner.hasNextBoolean()?,"the return of Scanner.hasNextBoolean() should be true if the next token in this scanner's input can be interpreted as a boolean value using a case insensitive pattern created from the string ""true|false"". The scanner does not advance past the input that matched..","['return', 'Scanner.hasNextBoolean()']"
Scanner.nextBoolean(),what's the return of Scanner.nextBoolean()?,the return of Scanner.nextBoolean() should be the boolean scanned from the input.,"['return', 'Scanner.nextBoolean()']"
Scanner.hasNextByte(),what's the return of Scanner.hasNextByte()?,the return of Scanner.hasNextByte() should be true if the next token in this scanner's input can be interpreted as a byte value in the default radix using the nextByte() method. The scanner does not advance past any input..,"['return', 'Scanner.hasNextByte()']"
Scanner.hasNextByte(int radix),what's the return of Scanner.hasNextByte(int radix)?,the return of Scanner.hasNextByte(int radix) should be true if the next token in this scanner's input can be interpreted as a byte value in the specified radix using the nextByte() method. The scanner does not advance past any input..,"['return', 'Scanner.hasNextByte(int radix)']"
Scanner.nextByte(),what's the return of Scanner.nextByte()?,the return of Scanner.nextByte() should be the byte scanned from the input.,"['return', 'Scanner.nextByte()']"
Scanner.nextByte(int radix),what's the return of Scanner.nextByte(int radix)?,the return of Scanner.nextByte(int radix) should be the byte scanned from the input.,"['return', 'Scanner.nextByte(int radix)']"
Scanner.hasNextShort(),what's the return of Scanner.hasNextShort()?,the return of Scanner.hasNextShort() should be true if the next token in this scanner's input can be interpreted as a short value in the default radix using the nextShort() method. The scanner does not advance past any input..,"['return', 'Scanner.hasNextShort()']"
Scanner.hasNextShort(int radix),what's the return of Scanner.hasNextShort(int radix)?,the return of Scanner.hasNextShort(int radix) should be true if the next token in this scanner's input can be interpreted as a short value in the specified radix using the nextShort() method. The scanner does not advance past any input..,"['return', 'Scanner.hasNextShort(int radix)']"
Scanner.nextShort(),what's the return of Scanner.nextShort()?,the return of Scanner.nextShort() should be the short scanned from the input.,"['return', 'Scanner.nextShort()']"
Scanner.nextShort(int radix),what's the return of Scanner.nextShort(int radix)?,the return of Scanner.nextShort(int radix) should be the short scanned from the input.,"['return', 'Scanner.nextShort(int radix)']"
Scanner.hasNextInt(),what's the return of Scanner.hasNextInt()?,the return of Scanner.hasNextInt() should be true if the next token in this scanner's input can be interpreted as an int value in the default radix using the nextInt() method. The scanner does not advance past any input..,"['return', 'Scanner.hasNextInt()']"
Scanner.hasNextInt(int radix),what's the return of Scanner.hasNextInt(int radix)?,the return of Scanner.hasNextInt(int radix) should be true if the next token in this scanner's input can be interpreted as an int value in the specified radix using the nextInt() method. The scanner does not advance past any input..,"['return', 'Scanner.hasNextInt(int radix)']"
Scanner.nextInt(),what's the return of Scanner.nextInt()?,the return of Scanner.nextInt() should be the int scanned from the input.,"['return', 'Scanner.nextInt()']"
Scanner.nextInt(int radix),what's the return of Scanner.nextInt(int radix)?,the return of Scanner.nextInt(int radix) should be the int scanned from the input.,"['return', 'Scanner.nextInt(int radix)']"
Scanner.hasNextLong(),what's the return of Scanner.hasNextLong()?,the return of Scanner.hasNextLong() should be true if the next token in this scanner's input can be interpreted as a long value in the default radix using the nextLong() method. The scanner does not advance past any input..,"['return', 'Scanner.hasNextLong()']"
Scanner.hasNextLong(int radix),what's the return of Scanner.hasNextLong(int radix)?,the return of Scanner.hasNextLong(int radix) should be true if the next token in this scanner's input can be interpreted as a long value in the specified radix using the nextLong() method. The scanner does not advance past any input..,"['return', 'Scanner.hasNextLong(int radix)']"
Scanner.nextLong(),what's the return of Scanner.nextLong()?,the return of Scanner.nextLong() should be the long scanned from the input.,"['return', 'Scanner.nextLong()']"
Scanner.nextLong(int radix),what's the return of Scanner.nextLong(int radix)?,the return of Scanner.nextLong(int radix) should be the long scanned from the input.,"['return', 'Scanner.nextLong(int radix)']"
Scanner.hasNextFloat(),what's the return of Scanner.hasNextFloat()?,the return of Scanner.hasNextFloat() should be true if the next token in this scanner's input can be interpreted as a float value using the nextFloat() method. The scanner does not advance past any input..,"['return', 'Scanner.hasNextFloat()']"
Scanner.nextFloat(),what's the return of Scanner.nextFloat()?,the return of Scanner.nextFloat() should be the float scanned from the input.,"['return', 'Scanner.nextFloat()']"
Scanner.hasNextDouble(),what's the return of Scanner.hasNextDouble()?,the return of Scanner.hasNextDouble() should be true if the next token in this scanner's input can be interpreted as a double value using the nextDouble() method. The scanner does not advance past any input..,"['return', 'Scanner.hasNextDouble()']"
Scanner.nextDouble(),what's the return of Scanner.nextDouble()?,the return of Scanner.nextDouble() should be the double scanned from the input.,"['return', 'Scanner.nextDouble()']"
Scanner.hasNextBigInteger(),what's the return of Scanner.hasNextBigInteger()?,the return of Scanner.hasNextBigInteger() should be true if the next token in this scanner's input can be interpreted as a BigInteger in the default radix using the nextBigInteger() method. The scanner does not advance past any input..,"['return', 'Scanner.hasNextBigInteger()']"
Scanner.hasNextBigInteger(int radix),what's the return of Scanner.hasNextBigInteger(int radix)?,the return of Scanner.hasNextBigInteger(int radix) should be true if the next token in this scanner's input can be interpreted as a BigInteger in the specified radix using the nextBigInteger() method. The scanner does not advance past any input..,"['return', 'Scanner.hasNextBigInteger(int radix)']"
Scanner.nextBigInteger(),what's the return of Scanner.nextBigInteger()?,the return of Scanner.nextBigInteger() should be the BigInteger scanned from the input.,"['return', 'Scanner.nextBigInteger()']"
Scanner.nextBigInteger(int radix),what's the return of Scanner.nextBigInteger(int radix)?,the return of Scanner.nextBigInteger(int radix) should be the BigInteger scanned from the input.,"['return', 'Scanner.nextBigInteger(int radix)']"
Scanner.hasNextBigDecimal(),what's the return of Scanner.hasNextBigDecimal()?,the return of Scanner.hasNextBigDecimal() should be true if the next token in this scanner's input can be interpreted as a BigDecimal using the nextBigDecimal() method. The scanner does not advance past any input..,"['return', 'Scanner.hasNextBigDecimal()']"
Scanner.nextBigDecimal(),what's the return of Scanner.nextBigDecimal()?,the return of Scanner.nextBigDecimal() should be the BigDecimal scanned from the input.,"['return', 'Scanner.nextBigDecimal()']"
Scanner.reset(),what's the return of Scanner.reset()?,the return of Scanner.reset() should be this scanner.,"['return', 'Scanner.reset()']"
Collection.size(),what's the return of Collection.size()?,the return of Collection.size() should be the number of elements in this deque..,"['return', 'Collection.size()']"
Collection.isEmpty(),what's the return of Collection.isEmpty()?,the return of Collection.isEmpty() should be true if this set contains no elements..,"['return', 'Collection.isEmpty()']"
Collection.contains(Object o),what's the return of Collection.contains(Object o)?,"the return of Collection.contains(Object o) should be true if this deque contains the specified element. More formally, returns true if and only if this deque contains at least one element e such that (o==null ? e==null : o.equals(e))..","['return', 'Collection.contains(Object o)']"
Collection.contains(Object o),what's the parameter of Collection.contains(Object o)?,the parameter of Collection.contains(Object o) should be  element whose presence in this deque is to be tested.,"['parameter', 'Collection.contains(Object o)']"
Collection.iterator(),what's the return of Collection.iterator()?,the return of Collection.iterator() should be an iterator over the elements in this deque in proper sequence. The elements will be returned in order from first (head) to last (tail)..,"['return', 'Collection.iterator()']"
Collection.toArray(),what's the return of Collection.toArray()?,"the return of Collection.toArray() should be an array containing all of the elements in this set. If this set makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order..","['return', 'Collection.toArray()']"
Collection.toArray(T[] a),what's the return of Collection.toArray(T[] a)?,"the return of Collection.toArray(T[] a) should be an array containing all of the elements in this set; the runtime type of the returned array is that of the specified array. If the set fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this set. String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray()..","['return', 'Collection.toArray(T[] a)']"
Collection.add(E e),what's the return of Collection.add(E e)?,the return of Collection.add(E e) should be true (as specified by Collection.add(E)).,"['return', 'Collection.add(E e)']"
Collection.add(E e),what's the parameter of Collection.add(E e)?,the parameter of Collection.add(E e) should be  the element to add.,"['parameter', 'Collection.add(E e)']"
Collection.remove(Object o),what's the return of Collection.remove(Object o)?,the return of Collection.remove(Object o) should be true if an element was removed as a result of this call.,"['return', 'Collection.remove(Object o)']"
Collection.remove(Object o),what's the parameter of Collection.remove(Object o)?,"the parameter of Collection.remove(Object o) should be  element to be removed from this deque, if present.","['parameter', 'Collection.remove(Object o)']"
Collection.containsAll(Collection<?> c),what's the return of Collection.containsAll(Collection<?> c)?,"the return of Collection.containsAll(Collection<?> c) should be true if this set contains all of the elements of the specified collection. If the specified collection is also a set, this method returns true if it is a subset of this set..","['return', 'Collection.containsAll(Collection<?> c)']"
Collection.addAll(Collection<? extends E> c),what's the return of Collection.addAll(Collection<? extends E> c)?,the return of Collection.addAll(Collection<? extends E> c) should be true if this set changed as a result of the call.,"['return', 'Collection.addAll(Collection<? extends E> c)']"
Collection.retainAll(Collection<?> c),what's the return of Collection.retainAll(Collection<?> c)?,the return of Collection.retainAll(Collection<?> c) should be true if this set changed as a result of the call.,"['return', 'Collection.retainAll(Collection<?> c)']"
Collection.removeAll(Collection<?> c),what's the return of Collection.removeAll(Collection<?> c)?,the return of Collection.removeAll(Collection<?> c) should be true if this set changed as a result of the call.,"['return', 'Collection.removeAll(Collection<?> c)']"
Object.equals(Object o),what's the return of Object.equals(Object o)?,the return of Object.equals(Object o) should be true if the specified object is equal to this map.,"['return', 'Object.equals(Object o)']"
Object.equals(Object o),what's the parameter of Object.equals(Object o)?,the parameter of Object.equals(Object o) should be  object to be compared for equality with this map.,"['parameter', 'Object.equals(Object o)']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
Collection.spliterator(),what's the return of Collection.spliterator()?,the return of Collection.spliterator() should be a Spliterator over the elements in this set.,"['return', 'Collection.spliterator()']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
Object.equals(Object obj),what's the return of Object.equals(Object obj)?,"the return of Object.equals(Object obj) should be true if the objects are the same;
          false otherwise..","['return', 'Object.equals(Object obj)']"
Object.equals(Object obj),what's the parameter of Object.equals(Object obj)?,the parameter of Object.equals(Object obj) should be  the object to compare with..,"['parameter', 'Object.equals(Object obj)']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
SortedMap.comparator(),what's the return of SortedMap.comparator()?,"the return of SortedMap.comparator() should be the comparator used to order the keys in this map, or null if this map uses the natural ordering of its keys..","['return', 'SortedMap.comparator()']"
"SortedMap.subMap(K fromKey, K toKey)","what's the return of SortedMap.subMap(K fromKey, K toKey)?","the return of SortedMap.subMap(K fromKey, K toKey) should be a view of the portion of this map whose keys range from fromKey, inclusive, to toKey, exclusive. (If fromKey and toKey are equal, the returned map is empty.) The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports..","['return', 'SortedMap.subMap(K fromKey, K toKey)']"
"SortedMap.subMap(K fromKey, K toKey)","what's the parameter of SortedMap.subMap(K fromKey, K toKey)?","the parameter of SortedMap.subMap(K fromKey, K toKey) should be  low endpoint (inclusive) of the keys in the returned map.","['parameter', 'SortedMap.subMap(K fromKey, K toKey)']"
SortedMap.headMap(K toKey),what's the return of SortedMap.headMap(K toKey)?,"the return of SortedMap.headMap(K toKey) should be a view of the portion of this map whose keys are strictly less than toKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports..","['return', 'SortedMap.headMap(K toKey)']"
SortedMap.headMap(K toKey),what's the parameter of SortedMap.headMap(K toKey)?,the parameter of SortedMap.headMap(K toKey) should be  high endpoint (exclusive) of the keys in the returned map.,"['parameter', 'SortedMap.headMap(K toKey)']"
SortedMap.tailMap(K fromKey),what's the return of SortedMap.tailMap(K fromKey)?,"the return of SortedMap.tailMap(K fromKey) should be a view of the portion of this map whose keys are greater than or equal to fromKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports..","['return', 'SortedMap.tailMap(K fromKey)']"
SortedMap.tailMap(K fromKey),what's the parameter of SortedMap.tailMap(K fromKey)?,the parameter of SortedMap.tailMap(K fromKey) should be  low endpoint (inclusive) of the keys in the returned map.,"['parameter', 'SortedMap.tailMap(K fromKey)']"
SortedMap.firstKey(),what's the return of SortedMap.firstKey()?,the return of SortedMap.firstKey() should be the first (lowest) key currently in this map..,"['return', 'SortedMap.firstKey()']"
SortedMap.lastKey(),what's the return of SortedMap.lastKey()?,the return of SortedMap.lastKey() should be the last (highest) key currently in this map..,"['return', 'SortedMap.lastKey()']"
Map.keySet(),what's the return of Map.keySet()?,"the return of Map.keySet() should be a Set view of the keys contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations..","['return', 'Map.keySet()']"
Map.values(),what's the return of Map.values()?,"the return of Map.values() should be a Collection view of the values contained in this map. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Collection.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations..","['return', 'Map.values()']"
Map.entrySet(),what's the return of Map.entrySet()?,the return of Map.entrySet() should be a set view of the mappings contained in this map.,"['return', 'Map.entrySet()']"
"SortedSet.subSet(E fromElement, E toElement)","what's the return of SortedSet.subSet(E fromElement, E toElement)?","the return of SortedSet.subSet(E fromElement, E toElement) should be a view of the portion of this set whose elements range from fromElement, inclusive, to toElement, exclusive. (If fromElement and toElement are equal, the returned set is empty.) The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports..","['return', 'SortedSet.subSet(E fromElement, E toElement)']"
"SortedSet.subSet(E fromElement, E toElement)","what's the parameter of SortedSet.subSet(E fromElement, E toElement)?","the parameter of SortedSet.subSet(E fromElement, E toElement) should be  low endpoint (inclusive) of the returned set.","['parameter', 'SortedSet.subSet(E fromElement, E toElement)']"
SortedSet.headSet(E toElement),what's the return of SortedSet.headSet(E toElement)?,"the return of SortedSet.headSet(E toElement) should be a view of the portion of this set whose elements are strictly less than toElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports..","['return', 'SortedSet.headSet(E toElement)']"
SortedSet.headSet(E toElement),what's the parameter of SortedSet.headSet(E toElement)?,the parameter of SortedSet.headSet(E toElement) should be  high endpoint (exclusive) of the returned set.,"['parameter', 'SortedSet.headSet(E toElement)']"
SortedSet.tailSet(E fromElement),what's the return of SortedSet.tailSet(E fromElement)?,"the return of SortedSet.tailSet(E fromElement) should be a view of the portion of this set whose elements are greater than or equal to fromElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports..","['return', 'SortedSet.tailSet(E fromElement)']"
SortedSet.tailSet(E fromElement),what's the parameter of SortedSet.tailSet(E fromElement)?,the parameter of SortedSet.tailSet(E fromElement) should be  low endpoint (inclusive) of the returned set.,"['parameter', 'SortedSet.tailSet(E fromElement)']"
Collection.spliterator(),what's the return of Collection.spliterator()?,the return of Collection.spliterator() should be a Spliterator over the elements in this set.,"['return', 'Collection.spliterator()']"
Spliterator.tryAdvance(Consumer<? super T> action),what's the return of Spliterator.tryAdvance(Consumer<? super T> action)?,"the return of Spliterator.tryAdvance(Consumer<? super T> action) should be false if no remaining elements existed
 upon entry to this method, else true..","['return', 'Spliterator.tryAdvance(Consumer<? super T> action)']"
Spliterator.trySplit(),what's the return of Spliterator.trySplit()?,"the return of Spliterator.trySplit() should be a Spliterator covering some portion of the
 elements, or null if this spliterator cannot be split.","['return', 'Spliterator.trySplit()']"
Spliterator.estimateSize(),what's the return of Spliterator.estimateSize()?,"the return of Spliterator.estimateSize() should be an estimate of the number of elements that would be encountered by a forEachRemaining(java.util.function.Consumer<? super T>) traversal, or returns Long.MAX_VALUE if infinite, unknown, or too expensive to compute..","['return', 'Spliterator.estimateSize()']"
Spliterator.getExactSizeIfKnown(),what's the return of Spliterator.getExactSizeIfKnown()?,"the return of Spliterator.getExactSizeIfKnown() should be the exact size, if known, else -1..","['return', 'Spliterator.getExactSizeIfKnown()']"
Spliterator.characteristics(),what's the return of Spliterator.characteristics()?,"the return of Spliterator.characteristics() should be a set of characteristics of this Spliterator and its elements. The result is represented as ORed values from ORDERED, DISTINCT, SORTED, SIZED, NONNULL, IMMUTABLE, CONCURRENT, SUBSIZED. Repeated calls to characteristics() on a given spliterator, prior to or in-between calls to trySplit, should always return the same result..","['return', 'Spliterator.characteristics()']"
Spliterator.hasCharacteristics(int characteristics),what's the return of Spliterator.hasCharacteristics(int characteristics)?,the return of Spliterator.hasCharacteristics(int characteristics) should be true if this Spliterator's characteristics() contain all of the given characteristics..,"['return', 'Spliterator.hasCharacteristics(int characteristics)']"
Spliterator.getComparator(),what's the return of Spliterator.getComparator()?,"the return of Spliterator.getComparator() should be a Comparator, or null if the elements are sorted in the
 natural order..","['return', 'Spliterator.getComparator()']"
Spliterator.trySplit(),what's the return of Spliterator.trySplit()?,"the return of Spliterator.trySplit() should be a Spliterator covering some portion of the
 elements, or null if this spliterator cannot be split.","['return', 'Spliterator.trySplit()']"
Spliterator.OfPrimitive.tryAdvance(DoubleConsumer action),what's the return of Spliterator.OfPrimitive.tryAdvance(DoubleConsumer action)?,"the return of Spliterator.OfPrimitive.tryAdvance(DoubleConsumer action) should be false if no remaining elements existed
 upon entry to this method, else true..","['return', 'Spliterator.OfPrimitive.tryAdvance(DoubleConsumer action)']"
Spliterator.OfPrimitive.tryAdvance(DoubleConsumer action),what's the parameter of Spliterator.OfPrimitive.tryAdvance(DoubleConsumer action)?,the parameter of Spliterator.OfPrimitive.tryAdvance(DoubleConsumer action) should be  The action.,"['parameter', 'Spliterator.OfPrimitive.tryAdvance(DoubleConsumer action)']"
Spliterator.OfPrimitive.forEachRemaining(DoubleConsumer action),what's the parameter of Spliterator.OfPrimitive.forEachRemaining(DoubleConsumer action)?,the parameter of Spliterator.OfPrimitive.forEachRemaining(DoubleConsumer action) should be  The action.,"['parameter', 'Spliterator.OfPrimitive.forEachRemaining(DoubleConsumer action)']"
Spliterator.tryAdvance(Consumer<? super Double> action),what's the return of Spliterator.tryAdvance(Consumer<? super Double> action)?,"the return of Spliterator.tryAdvance(Consumer<? super Double> action) should be false if no remaining elements existed
 upon entry to this method, else true..","['return', 'Spliterator.tryAdvance(Consumer<? super Double> action)']"
Spliterator.trySplit(),what's the return of Spliterator.trySplit()?,"the return of Spliterator.trySplit() should be a Spliterator covering some portion of the
 elements, or null if this spliterator cannot be split.","['return', 'Spliterator.trySplit()']"
Spliterator.OfPrimitive.tryAdvance(IntConsumer action),what's the return of Spliterator.OfPrimitive.tryAdvance(IntConsumer action)?,"the return of Spliterator.OfPrimitive.tryAdvance(IntConsumer action) should be false if no remaining elements existed
 upon entry to this method, else true..","['return', 'Spliterator.OfPrimitive.tryAdvance(IntConsumer action)']"
Spliterator.OfPrimitive.tryAdvance(IntConsumer action),what's the parameter of Spliterator.OfPrimitive.tryAdvance(IntConsumer action)?,the parameter of Spliterator.OfPrimitive.tryAdvance(IntConsumer action) should be  The action.,"['parameter', 'Spliterator.OfPrimitive.tryAdvance(IntConsumer action)']"
Spliterator.OfPrimitive.forEachRemaining(IntConsumer action),what's the parameter of Spliterator.OfPrimitive.forEachRemaining(IntConsumer action)?,the parameter of Spliterator.OfPrimitive.forEachRemaining(IntConsumer action) should be  The action.,"['parameter', 'Spliterator.OfPrimitive.forEachRemaining(IntConsumer action)']"
Spliterator.tryAdvance(Consumer<? super Integer> action),what's the return of Spliterator.tryAdvance(Consumer<? super Integer> action)?,"the return of Spliterator.tryAdvance(Consumer<? super Integer> action) should be false if no remaining elements existed
 upon entry to this method, else true..","['return', 'Spliterator.tryAdvance(Consumer<? super Integer> action)']"
Spliterator.trySplit(),what's the return of Spliterator.trySplit()?,"the return of Spliterator.trySplit() should be a Spliterator covering some portion of the
 elements, or null if this spliterator cannot be split.","['return', 'Spliterator.trySplit()']"
Spliterator.trySplit(),what's the return of Spliterator.trySplit()?,"the return of Spliterator.trySplit() should be a Spliterator covering some portion of the
 elements, or null if this spliterator cannot be split.","['return', 'Spliterator.trySplit()']"
"Spliterator.OfPrimitive<T,T_CONS,T_SPLITR.tryAdvance(T CONS action)","what's the return of Spliterator.OfPrimitive<T,T_CONS,T_SPLITR.tryAdvance(T CONS action)?","the return of Spliterator.OfPrimitive<T,T_CONS,T_SPLITR.tryAdvance(T CONS action) should be false if no remaining elements existed
 upon entry to this method, else true..","['return', 'Spliterator.OfPrimitive<T,T_CONS,T_SPLITR.tryAdvance(T CONS action)']"
Spliterator.trySplit(),what's the return of Spliterator.trySplit()?,"the return of Spliterator.trySplit() should be a Spliterator covering some portion of the
 elements, or null if this spliterator cannot be split.","['return', 'Spliterator.trySplit()']"
Spliterator.estimateSize(),what's the return of Spliterator.estimateSize()?,"the return of Spliterator.estimateSize() should be an estimate of the number of elements that would be encountered by a forEachRemaining(java.util.function.Consumer<? super T>) traversal, or returns Long.MAX_VALUE if infinite, unknown, or too expensive to compute..","['return', 'Spliterator.estimateSize()']"
Spliterator.characteristics(),what's the return of Spliterator.characteristics()?,"the return of Spliterator.characteristics() should be a set of characteristics of this Spliterator and its elements. The result is represented as ORed values from ORDERED, DISTINCT, SORTED, SIZED, NONNULL, IMMUTABLE, CONCURRENT, SUBSIZED. Repeated calls to characteristics() on a given spliterator, prior to or in-between calls to trySplit, should always return the same result..","['return', 'Spliterator.characteristics()']"
Spliterator.trySplit(),what's the return of Spliterator.trySplit()?,"the return of Spliterator.trySplit() should be a Spliterator covering some portion of the
 elements, or null if this spliterator cannot be split.","['return', 'Spliterator.trySplit()']"
Spliterator.estimateSize(),what's the return of Spliterator.estimateSize()?,"the return of Spliterator.estimateSize() should be an estimate of the number of elements that would be encountered by a forEachRemaining(java.util.function.Consumer<? super T>) traversal, or returns Long.MAX_VALUE if infinite, unknown, or too expensive to compute..","['return', 'Spliterator.estimateSize()']"
Spliterator.characteristics(),what's the return of Spliterator.characteristics()?,"the return of Spliterator.characteristics() should be a set of characteristics of this Spliterator and its elements. The result is represented as ORed values from ORDERED, DISTINCT, SORTED, SIZED, NONNULL, IMMUTABLE, CONCURRENT, SUBSIZED. Repeated calls to characteristics() on a given spliterator, prior to or in-between calls to trySplit, should always return the same result..","['return', 'Spliterator.characteristics()']"
Spliterator.trySplit(),what's the return of Spliterator.trySplit()?,"the return of Spliterator.trySplit() should be a Spliterator covering some portion of the
 elements, or null if this spliterator cannot be split.","['return', 'Spliterator.trySplit()']"
Spliterator.estimateSize(),what's the return of Spliterator.estimateSize()?,"the return of Spliterator.estimateSize() should be an estimate of the number of elements that would be encountered by a forEachRemaining(java.util.function.Consumer<? super T>) traversal, or returns Long.MAX_VALUE if infinite, unknown, or too expensive to compute..","['return', 'Spliterator.estimateSize()']"
Spliterator.characteristics(),what's the return of Spliterator.characteristics()?,"the return of Spliterator.characteristics() should be a set of characteristics of this Spliterator and its elements. The result is represented as ORed values from ORDERED, DISTINCT, SORTED, SIZED, NONNULL, IMMUTABLE, CONCURRENT, SUBSIZED. Repeated calls to characteristics() on a given spliterator, prior to or in-between calls to trySplit, should always return the same result..","['return', 'Spliterator.characteristics()']"
Spliterator.trySplit(),what's the return of Spliterator.trySplit()?,"the return of Spliterator.trySplit() should be a Spliterator covering some portion of the
 elements, or null if this spliterator cannot be split.","['return', 'Spliterator.trySplit()']"
Spliterator.estimateSize(),what's the return of Spliterator.estimateSize()?,"the return of Spliterator.estimateSize() should be an estimate of the number of elements that would be encountered by a forEachRemaining(java.util.function.Consumer<? super T>) traversal, or returns Long.MAX_VALUE if infinite, unknown, or too expensive to compute..","['return', 'Spliterator.estimateSize()']"
Spliterator.characteristics(),what's the return of Spliterator.characteristics()?,"the return of Spliterator.characteristics() should be a set of characteristics of this Spliterator and its elements. The result is represented as ORed values from ORDERED, DISTINCT, SORTED, SIZED, NONNULL, IMMUTABLE, CONCURRENT, SUBSIZED. Repeated calls to characteristics() on a given spliterator, prior to or in-between calls to trySplit, should always return the same result..","['return', 'Spliterator.characteristics()']"
Spliterators.emptySpliterator(),what's the return of Spliterators.emptySpliterator()?,the return of Spliterators.emptySpliterator() should be An empty spliterator.,"['return', 'Spliterators.emptySpliterator()']"
Spliterators.emptyIntSpliterator(),what's the return of Spliterators.emptyIntSpliterator()?,the return of Spliterators.emptyIntSpliterator() should be An empty spliterator.,"['return', 'Spliterators.emptyIntSpliterator()']"
Spliterators.emptyLongSpliterator(),what's the return of Spliterators.emptyLongSpliterator()?,the return of Spliterators.emptyLongSpliterator() should be An empty spliterator.,"['return', 'Spliterators.emptyLongSpliterator()']"
Spliterators.emptyDoubleSpliterator(),what's the return of Spliterators.emptyDoubleSpliterator()?,the return of Spliterators.emptyDoubleSpliterator() should be An empty spliterator.,"['return', 'Spliterators.emptyDoubleSpliterator()']"
"Spliterators.spliterator(Object[] array, int additionalCharacteristics)","what's the return of Spliterators.spliterator(Object[] array, int additionalCharacteristics)?","the return of Spliterators.spliterator(Object[] array, int additionalCharacteristics) should be additionalCharacteristics - Additional spliterator characteristics
        of this spliterator's source or elements beyond SIZED and
        SUBSIZED which are are always reported.","['return', 'Spliterators.spliterator(Object[] array, int additionalCharacteristics)']"
"Spliterators.spliterator(Object[] array, int fromIndex, int toIndex, int additionalCharacteristics)","what's the return of Spliterators.spliterator(Object[] array, int fromIndex, int toIndex, int additionalCharacteristics)?","the return of Spliterators.spliterator(Object[] array, int fromIndex, int toIndex, int additionalCharacteristics) should be fromIndex - The least index (inclusive) to cover.","['return', 'Spliterators.spliterator(Object[] array, int fromIndex, int toIndex, int additionalCharacteristics)']"
"Spliterators.spliterator(int[] array, int additionalCharacteristics)","what's the return of Spliterators.spliterator(int[] array, int additionalCharacteristics)?","the return of Spliterators.spliterator(int[] array, int additionalCharacteristics) should be additionalCharacteristics - Additional spliterator characteristics
        of this spliterator's source or elements beyond SIZED and
        SUBSIZED which are are always reported.","['return', 'Spliterators.spliterator(int[] array, int additionalCharacteristics)']"
"Spliterators.spliterator(int[] array, int fromIndex, int toIndex, int additionalCharacteristics)","what's the return of Spliterators.spliterator(int[] array, int fromIndex, int toIndex, int additionalCharacteristics)?","the return of Spliterators.spliterator(int[] array, int fromIndex, int toIndex, int additionalCharacteristics) should be fromIndex - The least index (inclusive) to cover.","['return', 'Spliterators.spliterator(int[] array, int fromIndex, int toIndex, int additionalCharacteristics)']"
"Spliterators.spliterator(long[] array, int additionalCharacteristics)","what's the return of Spliterators.spliterator(long[] array, int additionalCharacteristics)?","the return of Spliterators.spliterator(long[] array, int additionalCharacteristics) should be additionalCharacteristics - Additional spliterator characteristics
        of this spliterator's source or elements beyond SIZED and
        SUBSIZED which are are always reported.","['return', 'Spliterators.spliterator(long[] array, int additionalCharacteristics)']"
"Spliterators.spliterator(long[] array, int fromIndex, int toIndex, int additionalCharacteristics)","what's the return of Spliterators.spliterator(long[] array, int fromIndex, int toIndex, int additionalCharacteristics)?","the return of Spliterators.spliterator(long[] array, int fromIndex, int toIndex, int additionalCharacteristics) should be fromIndex - The least index (inclusive) to cover.","['return', 'Spliterators.spliterator(long[] array, int fromIndex, int toIndex, int additionalCharacteristics)']"
"Spliterators.spliterator(double[] array, int additionalCharacteristics)","what's the return of Spliterators.spliterator(double[] array, int additionalCharacteristics)?","the return of Spliterators.spliterator(double[] array, int additionalCharacteristics) should be additionalCharacteristics - Additional spliterator characteristics
        of this spliterator's source or elements beyond SIZED and
        SUBSIZED which are are always reported.","['return', 'Spliterators.spliterator(double[] array, int additionalCharacteristics)']"
"Spliterators.spliterator(double[] array, int fromIndex, int toIndex, int additionalCharacteristics)","what's the return of Spliterators.spliterator(double[] array, int fromIndex, int toIndex, int additionalCharacteristics)?","the return of Spliterators.spliterator(double[] array, int fromIndex, int toIndex, int additionalCharacteristics) should be fromIndex - The least index (inclusive) to cover.","['return', 'Spliterators.spliterator(double[] array, int fromIndex, int toIndex, int additionalCharacteristics)']"
"Spliterators.spliterator(Collection<? extends T> c, int characteristics)","what's the return of Spliterators.spliterator(Collection<? extends T> c, int characteristics)?","the return of Spliterators.spliterator(Collection<? extends T> c, int characteristics) should be characteristics - Characteristics of this spliterator's source or
        elements.  The characteristics SIZED and SUBSIZED
        are additionally reported unless CONCURRENT is supplied..","['return', 'Spliterators.spliterator(Collection<? extends T> c, int characteristics)']"
"Spliterators.spliterator(Iterator<? extends T> iterator, long size, int characteristics)","what's the return of Spliterators.spliterator(Iterator<? extends T> iterator, long size, int characteristics)?","the return of Spliterators.spliterator(Iterator<? extends T> iterator, long size, int characteristics) should be size - The number of elements in the source, to be reported as
        initial estimateSize.","['return', 'Spliterators.spliterator(Iterator<? extends T> iterator, long size, int characteristics)']"
"Spliterators.spliteratorUnknownSize(Iterator<? extends T> iterator, int characteristics)","what's the return of Spliterators.spliteratorUnknownSize(Iterator<? extends T> iterator, int characteristics)?","the return of Spliterators.spliteratorUnknownSize(Iterator<? extends T> iterator, int characteristics) should be characteristics - Characteristics of this spliterator's source
        or elements (SIZED and SUBSIZED, if supplied, are
        ignored and are not reported.).","['return', 'Spliterators.spliteratorUnknownSize(Iterator<? extends T> iterator, int characteristics)']"
"Spliterators.spliterator(PrimitiveIterator.OfInt iterator, long size, int characteristics)","what's the return of Spliterators.spliterator(PrimitiveIterator.OfInt iterator, long size, int characteristics)?","the return of Spliterators.spliterator(PrimitiveIterator.OfInt iterator, long size, int characteristics) should be size - The number of elements in the source, to be reported as
        initial estimateSize..","['return', 'Spliterators.spliterator(PrimitiveIterator.OfInt iterator, long size, int characteristics)']"
"Spliterators.spliterator(PrimitiveIterator.OfInt iterator, long size, int characteristics)","what's the parameter of Spliterators.spliterator(PrimitiveIterator.OfInt iterator, long size, int characteristics)?","the parameter of Spliterators.spliterator(PrimitiveIterator.OfInt iterator, long size, int characteristics) should be  The iterator for the source.","['parameter', 'Spliterators.spliterator(PrimitiveIterator.OfInt iterator, long size, int characteristics)']"
"Spliterators.spliteratorUnknownSize(PrimitiveIterator.OfInt iterator, int characteristics)","what's the return of Spliterators.spliteratorUnknownSize(PrimitiveIterator.OfInt iterator, int characteristics)?","the return of Spliterators.spliteratorUnknownSize(PrimitiveIterator.OfInt iterator, int characteristics) should be characteristics - Characteristics of this spliterator's source
        or elements (SIZED and SUBSIZED, if supplied, are
        ignored and are not reported.).","['return', 'Spliterators.spliteratorUnknownSize(PrimitiveIterator.OfInt iterator, int characteristics)']"
"Spliterators.spliteratorUnknownSize(PrimitiveIterator.OfInt iterator, int characteristics)","what's the parameter of Spliterators.spliteratorUnknownSize(PrimitiveIterator.OfInt iterator, int characteristics)?","the parameter of Spliterators.spliteratorUnknownSize(PrimitiveIterator.OfInt iterator, int characteristics) should be  The iterator for the source.","['parameter', 'Spliterators.spliteratorUnknownSize(PrimitiveIterator.OfInt iterator, int characteristics)']"
"Spliterators.spliterator(PrimitiveIterator.OfLong iterator, long size, int characteristics)","what's the return of Spliterators.spliterator(PrimitiveIterator.OfLong iterator, long size, int characteristics)?","the return of Spliterators.spliterator(PrimitiveIterator.OfLong iterator, long size, int characteristics) should be size - The number of elements in the source, to be reported as
        initial estimateSize..","['return', 'Spliterators.spliterator(PrimitiveIterator.OfLong iterator, long size, int characteristics)']"
"Spliterators.spliterator(PrimitiveIterator.OfLong iterator, long size, int characteristics)","what's the parameter of Spliterators.spliterator(PrimitiveIterator.OfLong iterator, long size, int characteristics)?","the parameter of Spliterators.spliterator(PrimitiveIterator.OfLong iterator, long size, int characteristics) should be  The iterator for the source.","['parameter', 'Spliterators.spliterator(PrimitiveIterator.OfLong iterator, long size, int characteristics)']"
"Spliterators.spliteratorUnknownSize(PrimitiveIterator.OfLong iterator, int characteristics)","what's the return of Spliterators.spliteratorUnknownSize(PrimitiveIterator.OfLong iterator, int characteristics)?","the return of Spliterators.spliteratorUnknownSize(PrimitiveIterator.OfLong iterator, int characteristics) should be characteristics - Characteristics of this spliterator's source
        or elements (SIZED and SUBSIZED, if supplied, are
        ignored and are not reported.).","['return', 'Spliterators.spliteratorUnknownSize(PrimitiveIterator.OfLong iterator, int characteristics)']"
"Spliterators.spliteratorUnknownSize(PrimitiveIterator.OfLong iterator, int characteristics)","what's the parameter of Spliterators.spliteratorUnknownSize(PrimitiveIterator.OfLong iterator, int characteristics)?","the parameter of Spliterators.spliteratorUnknownSize(PrimitiveIterator.OfLong iterator, int characteristics) should be  The iterator for the source.","['parameter', 'Spliterators.spliteratorUnknownSize(PrimitiveIterator.OfLong iterator, int characteristics)']"
"Spliterators.spliterator(PrimitiveIterator.OfDouble iterator, long size, int characteristics)","what's the return of Spliterators.spliterator(PrimitiveIterator.OfDouble iterator, long size, int characteristics)?","the return of Spliterators.spliterator(PrimitiveIterator.OfDouble iterator, long size, int characteristics) should be size - The number of elements in the source, to be reported as
        initial estimateSize.","['return', 'Spliterators.spliterator(PrimitiveIterator.OfDouble iterator, long size, int characteristics)']"
"Spliterators.spliterator(PrimitiveIterator.OfDouble iterator, long size, int characteristics)","what's the parameter of Spliterators.spliterator(PrimitiveIterator.OfDouble iterator, long size, int characteristics)?","the parameter of Spliterators.spliterator(PrimitiveIterator.OfDouble iterator, long size, int characteristics) should be  The iterator for the source.","['parameter', 'Spliterators.spliterator(PrimitiveIterator.OfDouble iterator, long size, int characteristics)']"
"Spliterators.spliteratorUnknownSize(PrimitiveIterator.OfDouble iterator, int characteristics)","what's the return of Spliterators.spliteratorUnknownSize(PrimitiveIterator.OfDouble iterator, int characteristics)?","the return of Spliterators.spliteratorUnknownSize(PrimitiveIterator.OfDouble iterator, int characteristics) should be characteristics - Characteristics of this spliterator's source
        or elements (SIZED and SUBSIZED, if supplied, are
        ignored and are not reported.).","['return', 'Spliterators.spliteratorUnknownSize(PrimitiveIterator.OfDouble iterator, int characteristics)']"
"Spliterators.spliteratorUnknownSize(PrimitiveIterator.OfDouble iterator, int characteristics)","what's the parameter of Spliterators.spliteratorUnknownSize(PrimitiveIterator.OfDouble iterator, int characteristics)?","the parameter of Spliterators.spliteratorUnknownSize(PrimitiveIterator.OfDouble iterator, int characteristics) should be  The iterator for the source.","['parameter', 'Spliterators.spliteratorUnknownSize(PrimitiveIterator.OfDouble iterator, int characteristics)']"
Spliterators.iterator(Spliterator<? extends T> spliterator),what's the return of Spliterators.iterator(Spliterator<? extends T> spliterator)?,the return of Spliterators.iterator(Spliterator<? extends T> spliterator) should be An iterator.,"['return', 'Spliterators.iterator(Spliterator<? extends T> spliterator)']"
Spliterators.iterator(Spliterator.OfInt spliterator),what's the return of Spliterators.iterator(Spliterator.OfInt spliterator)?,the return of Spliterators.iterator(Spliterator.OfInt spliterator) should be An iterator.,"['return', 'Spliterators.iterator(Spliterator.OfInt spliterator)']"
Spliterators.iterator(Spliterator.OfInt spliterator),what's the parameter of Spliterators.iterator(Spliterator.OfInt spliterator)?,the parameter of Spliterators.iterator(Spliterator.OfInt spliterator) should be  The spliterator.,"['parameter', 'Spliterators.iterator(Spliterator.OfInt spliterator)']"
Spliterators.iterator(Spliterator.OfLong spliterator),what's the return of Spliterators.iterator(Spliterator.OfLong spliterator)?,the return of Spliterators.iterator(Spliterator.OfLong spliterator) should be An iterator.,"['return', 'Spliterators.iterator(Spliterator.OfLong spliterator)']"
Spliterators.iterator(Spliterator.OfLong spliterator),what's the parameter of Spliterators.iterator(Spliterator.OfLong spliterator)?,the parameter of Spliterators.iterator(Spliterator.OfLong spliterator) should be  The spliterator.,"['parameter', 'Spliterators.iterator(Spliterator.OfLong spliterator)']"
Spliterators.iterator(Spliterator.OfDouble spliterator),what's the return of Spliterators.iterator(Spliterator.OfDouble spliterator)?,the return of Spliterators.iterator(Spliterator.OfDouble spliterator) should be An iterator.,"['return', 'Spliterators.iterator(Spliterator.OfDouble spliterator)']"
Spliterators.iterator(Spliterator.OfDouble spliterator),what's the parameter of Spliterators.iterator(Spliterator.OfDouble spliterator)?,the parameter of Spliterators.iterator(Spliterator.OfDouble spliterator) should be  The spliterator.,"['parameter', 'Spliterators.iterator(Spliterator.OfDouble spliterator)']"
SplittableRandom.split(),what's the return of SplittableRandom.split()?,the return of SplittableRandom.split() should be the new SplittableRandom instance.,"['return', 'SplittableRandom.split()']"
SplittableRandom.nextInt(),what's the return of SplittableRandom.nextInt()?,the return of SplittableRandom.nextInt() should be a pseudorandom int value..,"['return', 'SplittableRandom.nextInt()']"
SplittableRandom.nextInt(int bound),what's the return of SplittableRandom.nextInt(int bound)?,the return of SplittableRandom.nextInt(int bound) should be a pseudorandom int value between zero (inclusive) and the specified bound (exclusive)..,"['return', 'SplittableRandom.nextInt(int bound)']"
"SplittableRandom.nextInt(int origin, int bound)","what's the return of SplittableRandom.nextInt(int origin, int bound)?","the return of SplittableRandom.nextInt(int origin, int bound) should be a pseudorandom int value between the specified origin (inclusive) and the specified bound (exclusive)..","['return', 'SplittableRandom.nextInt(int origin, int bound)']"
SplittableRandom.nextLong(),what's the return of SplittableRandom.nextLong()?,the return of SplittableRandom.nextLong() should be a pseudorandom long value..,"['return', 'SplittableRandom.nextLong()']"
SplittableRandom.nextLong(long bound),what's the return of SplittableRandom.nextLong(long bound)?,the return of SplittableRandom.nextLong(long bound) should be a pseudorandom long value between zero (inclusive) and the specified bound (exclusive)..,"['return', 'SplittableRandom.nextLong(long bound)']"
"SplittableRandom.nextLong(long origin, long bound)","what's the return of SplittableRandom.nextLong(long origin, long bound)?","the return of SplittableRandom.nextLong(long origin, long bound) should be a pseudorandom long value between the specified origin (inclusive) and the specified bound (exclusive)..","['return', 'SplittableRandom.nextLong(long origin, long bound)']"
SplittableRandom.nextDouble(),what's the return of SplittableRandom.nextDouble()?,the return of SplittableRandom.nextDouble() should be a pseudorandom double value between zero (inclusive) and one (exclusive)..,"['return', 'SplittableRandom.nextDouble()']"
SplittableRandom.nextDouble(double bound),what's the return of SplittableRandom.nextDouble(double bound)?,the return of SplittableRandom.nextDouble(double bound) should be a pseudorandom double value between 0.0 (inclusive) and the specified bound (exclusive)..,"['return', 'SplittableRandom.nextDouble(double bound)']"
"SplittableRandom.nextDouble(double origin, double bound)","what's the return of SplittableRandom.nextDouble(double origin, double bound)?","the return of SplittableRandom.nextDouble(double origin, double bound) should be a pseudorandom double value between the specified origin (inclusive) and bound (exclusive)..","['return', 'SplittableRandom.nextDouble(double origin, double bound)']"
SplittableRandom.nextBoolean(),what's the return of SplittableRandom.nextBoolean()?,the return of SplittableRandom.nextBoolean() should be a pseudorandom boolean value..,"['return', 'SplittableRandom.nextBoolean()']"
SplittableRandom.ints(long streamSize),what's the return of SplittableRandom.ints(long streamSize)?,the return of SplittableRandom.ints(long streamSize) should be a stream producing the given streamSize number of pseudorandom int values from this generator and/or one split from it..,"['return', 'SplittableRandom.ints(long streamSize)']"
SplittableRandom.ints(),what's the return of SplittableRandom.ints()?,the return of SplittableRandom.ints() should be an effectively unlimited stream of pseudorandom int values from this generator and/or one split from it..,"['return', 'SplittableRandom.ints()']"
"SplittableRandom.ints(long streamSize, int randomNumberOrigin, int randomNumberBound)","what's the return of SplittableRandom.ints(long streamSize, int randomNumberOrigin, int randomNumberBound)?","the return of SplittableRandom.ints(long streamSize, int randomNumberOrigin, int randomNumberBound) should be a stream producing the given streamSize number of pseudorandom int values from this generator and/or one split from it; each value conforms to the given origin (inclusive) and bound (exclusive)..","['return', 'SplittableRandom.ints(long streamSize, int randomNumberOrigin, int randomNumberBound)']"
"SplittableRandom.ints(int randomNumberOrigin, int randomNumberBound)","what's the return of SplittableRandom.ints(int randomNumberOrigin, int randomNumberBound)?","the return of SplittableRandom.ints(int randomNumberOrigin, int randomNumberBound) should be an effectively unlimited stream of pseudorandom int values from this generator and/or one split from it; each value conforms to the given origin (inclusive) and bound (exclusive)..","['return', 'SplittableRandom.ints(int randomNumberOrigin, int randomNumberBound)']"
SplittableRandom.longs(long streamSize),what's the return of SplittableRandom.longs(long streamSize)?,the return of SplittableRandom.longs(long streamSize) should be a stream producing the given streamSize number of pseudorandom long values from this generator and/or one split from it..,"['return', 'SplittableRandom.longs(long streamSize)']"
SplittableRandom.longs(),what's the return of SplittableRandom.longs()?,the return of SplittableRandom.longs() should be an effectively unlimited stream of pseudorandom long values from this generator and/or one split from it..,"['return', 'SplittableRandom.longs()']"
"SplittableRandom.longs(long streamSize, long randomNumberOrigin, long randomNumberBound)","what's the return of SplittableRandom.longs(long streamSize, long randomNumberOrigin, long randomNumberBound)?","the return of SplittableRandom.longs(long streamSize, long randomNumberOrigin, long randomNumberBound) should be a stream producing the given streamSize number of pseudorandom long values from this generator and/or one split from it; each value conforms to the given origin (inclusive) and bound (exclusive)..","['return', 'SplittableRandom.longs(long streamSize, long randomNumberOrigin, long randomNumberBound)']"
"SplittableRandom.longs(long randomNumberOrigin, long randomNumberBound)","what's the return of SplittableRandom.longs(long randomNumberOrigin, long randomNumberBound)?","the return of SplittableRandom.longs(long randomNumberOrigin, long randomNumberBound) should be an effectively unlimited stream of pseudorandom long values from this generator and/or one split from it; each value conforms to the given origin (inclusive) and bound (exclusive)..","['return', 'SplittableRandom.longs(long randomNumberOrigin, long randomNumberBound)']"
SplittableRandom.doubles(long streamSize),what's the return of SplittableRandom.doubles(long streamSize)?,the return of SplittableRandom.doubles(long streamSize) should be a stream producing the given streamSize number of pseudorandom double values from this generator and/or one split from it; each value is between zero (inclusive) and one (exclusive)..,"['return', 'SplittableRandom.doubles(long streamSize)']"
SplittableRandom.doubles(),what's the return of SplittableRandom.doubles()?,the return of SplittableRandom.doubles() should be an effectively unlimited stream of pseudorandom double values from this generator and/or one split from it; each value is between zero (inclusive) and one (exclusive)..,"['return', 'SplittableRandom.doubles()']"
"SplittableRandom.doubles(long streamSize, double randomNumberOrigin, double randomNumberBound)","what's the return of SplittableRandom.doubles(long streamSize, double randomNumberOrigin, double randomNumberBound)?","the return of SplittableRandom.doubles(long streamSize, double randomNumberOrigin, double randomNumberBound) should be a stream producing the given streamSize number of pseudorandom double values from this generator and/or one split from it; each value conforms to the given origin (inclusive) and bound (exclusive)..","['return', 'SplittableRandom.doubles(long streamSize, double randomNumberOrigin, double randomNumberBound)']"
"SplittableRandom.doubles(double randomNumberOrigin, double randomNumberBound)","what's the return of SplittableRandom.doubles(double randomNumberOrigin, double randomNumberBound)?","the return of SplittableRandom.doubles(double randomNumberOrigin, double randomNumberBound) should be an effectively unlimited stream of pseudorandom double values from this generator and/or one split from it; each value conforms to the given origin (inclusive) and bound (exclusive)..","['return', 'SplittableRandom.doubles(double randomNumberOrigin, double randomNumberBound)']"
Stack.push(E item),what's the return of Stack.push(E item)?,the return of Stack.push(E item) should be the item argument..,"['return', 'Stack.push(E item)']"
Stack.push(E item),what's the parameter of Stack.push(E item)?,the parameter of Stack.push(E item) should be  the item to be pushed onto this stack..,"['parameter', 'Stack.push(E item)']"
Stack.pop(),what's the return of Stack.pop()?,"the return of Stack.pop() should be The object at the top of this stack (the last item
          of the Vector object)..","['return', 'Stack.pop()']"
Stack.peek(),what's the return of Stack.peek()?,"the return of Stack.peek() should be the object at the top of this stack (the last item
          of the Vector object)..","['return', 'Stack.peek()']"
Stack.empty(),what's the return of Stack.empty()?,"the return of Stack.empty() should be true if and only if this stack contains
          no items; false otherwise..","['return', 'Stack.empty()']"
Stack.search(Object o),what's the return of Stack.search(Object o)?,"the return of Stack.search(Object o) should be the 1-based position where an object is on this stack. If the object o occurs as an item in this stack, this method returns the distance from the top of the stack of the occurrence nearest the top of the stack; the topmost item on the stack is considered to be at distance 1. The equals method is used to compare o to the items in this stack..","['return', 'Stack.search(Object o)']"
Stack.search(Object o),what's the parameter of Stack.search(Object o)?,the parameter of Stack.search(Object o) should be  the desired object..,"['parameter', 'Stack.search(Object o)']"
StringJoiner.setEmptyValue(CharSequence emptyValue),what's the return of StringJoiner.setEmptyValue(CharSequence emptyValue)?,the return of StringJoiner.setEmptyValue(CharSequence emptyValue) should be this StringJoiner itself so the calls may be chained.,"['return', 'StringJoiner.setEmptyValue(CharSequence emptyValue)']"
StringJoiner.setEmptyValue(CharSequence emptyValue),what's the parameter of StringJoiner.setEmptyValue(CharSequence emptyValue)?,"the parameter of StringJoiner.setEmptyValue(CharSequence emptyValue) should be  the characters to return as the value of an empty
         StringJoiner.","['parameter', 'StringJoiner.setEmptyValue(CharSequence emptyValue)']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
StringJoiner.add(CharSequence newElement),what's the return of StringJoiner.add(CharSequence newElement)?,the return of StringJoiner.add(CharSequence newElement) should be a reference to this StringJoiner.,"['return', 'StringJoiner.add(CharSequence newElement)']"
StringJoiner.add(CharSequence newElement),what's the parameter of StringJoiner.add(CharSequence newElement)?,the parameter of StringJoiner.add(CharSequence newElement) should be  The element to add.,"['parameter', 'StringJoiner.add(CharSequence newElement)']"
StringJoiner.merge(StringJoiner other),what's the return of StringJoiner.merge(StringJoiner other)?,the return of StringJoiner.merge(StringJoiner other) should be This StringJoiner.,"['return', 'StringJoiner.merge(StringJoiner other)']"
StringJoiner.merge(StringJoiner other),what's the parameter of StringJoiner.merge(StringJoiner other)?,"the parameter of StringJoiner.merge(StringJoiner other) should be  The StringJoiner whose contents should be merged
              into this one.","['parameter', 'StringJoiner.merge(StringJoiner other)']"
StringJoiner.length(),what's the return of StringJoiner.length()?,"the return of StringJoiner.length() should be the length of the String representation of this StringJoiner. Note that if no add methods have been called, then the length of the String representation (either prefix + suffix or emptyValue) will be returned. The value should be equivalent to toString().length()..","['return', 'StringJoiner.length()']"
Enumeration.hasMoreElements(),what's the return of Enumeration.hasMoreElements()?,"the return of Enumeration.hasMoreElements() should be true if and only if this enumeration object
           contains at least one more element to provide;
          false otherwise..","['return', 'Enumeration.hasMoreElements()']"
Enumeration.nextElement(),what's the return of Enumeration.nextElement()?,the return of Enumeration.nextElement() should be the next element of this enumeration if this enumeration object has at least one more element to provide..,"['return', 'Enumeration.nextElement()']"
"Timer.schedule(TimerTask task, long delay)","what's the parameter of Timer.schedule(TimerTask task, long delay)?","the parameter of Timer.schedule(TimerTask task, long delay) should be  task to be scheduled..","['parameter', 'Timer.schedule(TimerTask task, long delay)']"
"Timer.schedule(TimerTask task, Date time)","what's the parameter of Timer.schedule(TimerTask task, Date time)?","the parameter of Timer.schedule(TimerTask task, Date time) should be  task to be scheduled..","['parameter', 'Timer.schedule(TimerTask task, Date time)']"
"Timer.schedule(TimerTask task, Date time)","what's the parameter of Timer.schedule(TimerTask task, Date time)?","the parameter of Timer.schedule(TimerTask task, Date time) should be  task to be scheduled..","['parameter', 'Timer.schedule(TimerTask task, Date time)']"
"Timer.schedule(TimerTask task, long delay, long period)","what's the parameter of Timer.schedule(TimerTask task, long delay, long period)?","the parameter of Timer.schedule(TimerTask task, long delay, long period) should be  task to be scheduled..","['parameter', 'Timer.schedule(TimerTask task, long delay, long period)']"
"Timer.schedule(TimerTask task, Date firstTime, long period)","what's the parameter of Timer.schedule(TimerTask task, Date firstTime, long period)?","the parameter of Timer.schedule(TimerTask task, Date firstTime, long period) should be  task to be scheduled..","['parameter', 'Timer.schedule(TimerTask task, Date firstTime, long period)']"
"Timer.schedule(TimerTask task, Date firstTime, long period)","what's the parameter of Timer.schedule(TimerTask task, Date firstTime, long period)?","the parameter of Timer.schedule(TimerTask task, Date firstTime, long period) should be  task to be scheduled..","['parameter', 'Timer.schedule(TimerTask task, Date firstTime, long period)']"
"Timer.scheduleAtFixedRate(TimerTask task, long delay, long period)","what's the parameter of Timer.scheduleAtFixedRate(TimerTask task, long delay, long period)?","the parameter of Timer.scheduleAtFixedRate(TimerTask task, long delay, long period) should be  task to be scheduled..","['parameter', 'Timer.scheduleAtFixedRate(TimerTask task, long delay, long period)']"
"Timer.scheduleAtFixedRate(TimerTask task, Date firstTime, long period)","what's the parameter of Timer.scheduleAtFixedRate(TimerTask task, Date firstTime, long period)?","the parameter of Timer.scheduleAtFixedRate(TimerTask task, Date firstTime, long period) should be  task to be scheduled..","['parameter', 'Timer.scheduleAtFixedRate(TimerTask task, Date firstTime, long period)']"
"Timer.scheduleAtFixedRate(TimerTask task, Date firstTime, long period)","what's the parameter of Timer.scheduleAtFixedRate(TimerTask task, Date firstTime, long period)?","the parameter of Timer.scheduleAtFixedRate(TimerTask task, Date firstTime, long period) should be  task to be scheduled..","['parameter', 'Timer.scheduleAtFixedRate(TimerTask task, Date firstTime, long period)']"
TimerTask.cancel(),what's the return of TimerTask.cancel()?,"the return of TimerTask.cancel() should be true if this task is scheduled for one-time execution and has
         not yet run, or this task is scheduled for repeated execution.
         Returns false if the task was scheduled for one-time execution
         and has already run, or if the task was never scheduled, or if
         the task was already cancelled.  (Loosely speaking, this method
         returns true if it prevents one or more scheduled
         executions from taking place.).","['return', 'TimerTask.cancel()']"
TimerTask.scheduledExecutionTime(),what's the return of TimerTask.scheduledExecutionTime()?,"the return of TimerTask.scheduledExecutionTime() should be the scheduled execution time of the most recent actual execution of this task. (If this method is invoked while task execution is in progress, the return value is the scheduled execution time of the ongoing task execution.) public void run() { if (System.currentTimeMillis() - scheduledExecutionTime() >= MAX_TARDINESS) return; // Too late; skip this execution. // Perform the task } This method is typically not used in conjunction with fixed-delay execution repeating tasks, as their scheduled execution times are allowed to drift over time, and so are not terribly significant..","['return', 'TimerTask.scheduledExecutionTime()']"
Object.clone(),what's the return of Object.clone()?,the return of Object.clone() should be a shallow copy of this AbstractMap instance: the keys and values themselves are not cloned..,"['return', 'Object.clone()']"
SortedMap.comparator(),what's the return of SortedMap.comparator()?,"the return of SortedMap.comparator() should be the comparator used to order the keys in this map, or null if this map uses the natural ordering of its keys..","['return', 'SortedMap.comparator()']"
SortedMap.firstKey(),what's the return of SortedMap.firstKey()?,the return of SortedMap.firstKey() should be the first (lowest) key currently in this map..,"['return', 'SortedMap.firstKey()']"
SortedMap.lastKey(),what's the return of SortedMap.lastKey()?,the return of SortedMap.lastKey() should be the last (highest) key currently in this map..,"['return', 'SortedMap.lastKey()']"
NavigableMap.firstEntry(),what's the return of NavigableMap.firstEntry()?,"the return of NavigableMap.firstEntry() should be an entry with the least key,
         or null if this map is empty.","['return', 'NavigableMap.firstEntry()']"
NavigableMap.lastEntry(),what's the return of NavigableMap.lastEntry()?,"the return of NavigableMap.lastEntry() should be an entry with the greatest key,
         or null if this map is empty.","['return', 'NavigableMap.lastEntry()']"
NavigableMap.pollFirstEntry(),what's the return of NavigableMap.pollFirstEntry()?,"the return of NavigableMap.pollFirstEntry() should be the removed first entry of this map,
         or null if this map is empty.","['return', 'NavigableMap.pollFirstEntry()']"
NavigableMap.pollLastEntry(),what's the return of NavigableMap.pollLastEntry()?,"the return of NavigableMap.pollLastEntry() should be the removed last entry of this map,
         or null if this map is empty.","['return', 'NavigableMap.pollLastEntry()']"
NavigableMap.lowerEntry(K key),what's the return of NavigableMap.lowerEntry(K key)?,"the return of NavigableMap.lowerEntry(K key) should be an entry with the greatest key less than key,
         or null if there is no such key.","['return', 'NavigableMap.lowerEntry(K key)']"
NavigableMap.lowerEntry(K key),what's the parameter of NavigableMap.lowerEntry(K key)?,the parameter of NavigableMap.lowerEntry(K key) should be  the key.,"['parameter', 'NavigableMap.lowerEntry(K key)']"
NavigableMap.lowerKey(K key),what's the return of NavigableMap.lowerKey(K key)?,"the return of NavigableMap.lowerKey(K key) should be the greatest key less than key,
         or null if there is no such key.","['return', 'NavigableMap.lowerKey(K key)']"
NavigableMap.lowerKey(K key),what's the parameter of NavigableMap.lowerKey(K key)?,the parameter of NavigableMap.lowerKey(K key) should be  the key.,"['parameter', 'NavigableMap.lowerKey(K key)']"
NavigableMap.floorEntry(K key),what's the return of NavigableMap.floorEntry(K key)?,"the return of NavigableMap.floorEntry(K key) should be an entry with the greatest key less than or equal to
         key, or null if there is no such key.","['return', 'NavigableMap.floorEntry(K key)']"
NavigableMap.floorEntry(K key),what's the parameter of NavigableMap.floorEntry(K key)?,the parameter of NavigableMap.floorEntry(K key) should be  the key.,"['parameter', 'NavigableMap.floorEntry(K key)']"
NavigableMap.floorKey(K key),what's the return of NavigableMap.floorKey(K key)?,"the return of NavigableMap.floorKey(K key) should be the greatest key less than or equal to key,
         or null if there is no such key.","['return', 'NavigableMap.floorKey(K key)']"
NavigableMap.floorKey(K key),what's the parameter of NavigableMap.floorKey(K key)?,the parameter of NavigableMap.floorKey(K key) should be  the key.,"['parameter', 'NavigableMap.floorKey(K key)']"
NavigableMap.ceilingEntry(K key),what's the return of NavigableMap.ceilingEntry(K key)?,"the return of NavigableMap.ceilingEntry(K key) should be an entry with the least key greater than or equal to
         key, or null if there is no such key.","['return', 'NavigableMap.ceilingEntry(K key)']"
NavigableMap.ceilingEntry(K key),what's the parameter of NavigableMap.ceilingEntry(K key)?,the parameter of NavigableMap.ceilingEntry(K key) should be  the key.,"['parameter', 'NavigableMap.ceilingEntry(K key)']"
NavigableMap.ceilingKey(K key),what's the return of NavigableMap.ceilingKey(K key)?,"the return of NavigableMap.ceilingKey(K key) should be the least key greater than or equal to key,
         or null if there is no such key.","['return', 'NavigableMap.ceilingKey(K key)']"
NavigableMap.ceilingKey(K key),what's the parameter of NavigableMap.ceilingKey(K key)?,the parameter of NavigableMap.ceilingKey(K key) should be  the key.,"['parameter', 'NavigableMap.ceilingKey(K key)']"
NavigableMap.higherEntry(K key),what's the return of NavigableMap.higherEntry(K key)?,"the return of NavigableMap.higherEntry(K key) should be an entry with the least key greater than key,
         or null if there is no such key.","['return', 'NavigableMap.higherEntry(K key)']"
NavigableMap.higherEntry(K key),what's the parameter of NavigableMap.higherEntry(K key)?,the parameter of NavigableMap.higherEntry(K key) should be  the key.,"['parameter', 'NavigableMap.higherEntry(K key)']"
NavigableMap.higherKey(K key),what's the return of NavigableMap.higherKey(K key)?,"the return of NavigableMap.higherKey(K key) should be the least key greater than key,
         or null if there is no such key.","['return', 'NavigableMap.higherKey(K key)']"
NavigableMap.higherKey(K key),what's the parameter of NavigableMap.higherKey(K key)?,the parameter of NavigableMap.higherKey(K key) should be  the key.,"['parameter', 'NavigableMap.higherKey(K key)']"
NavigableMap.navigableKeySet(),what's the return of NavigableMap.navigableKeySet()?,the return of NavigableMap.navigableKeySet() should be a navigable set view of the keys in this map.,"['return', 'NavigableMap.navigableKeySet()']"
NavigableMap.descendingKeySet(),what's the return of NavigableMap.descendingKeySet()?,the return of NavigableMap.descendingKeySet() should be a reverse order navigable set view of the keys in this map.,"['return', 'NavigableMap.descendingKeySet()']"
Map.entrySet(),what's the return of Map.entrySet()?,the return of Map.entrySet() should be a set view of the mappings contained in this map.,"['return', 'Map.entrySet()']"
NavigableMap.descendingMap(),what's the return of NavigableMap.descendingMap()?,the return of NavigableMap.descendingMap() should be a reverse order view of this map.,"['return', 'NavigableMap.descendingMap()']"
"NavigableMap.subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)","what's the return of NavigableMap.subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)?","the return of NavigableMap.subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) should be fromInclusive - true if the low endpoint
        is to be included in the returned view.","['return', 'NavigableMap.subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)']"
"NavigableMap.subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)","what's the parameter of NavigableMap.subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)?","the parameter of NavigableMap.subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) should be  low endpoint of the keys in the returned map.","['parameter', 'NavigableMap.subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)']"
"NavigableMap.headMap(K toKey, boolean inclusive)","what's the return of NavigableMap.headMap(K toKey, boolean inclusive)?","the return of NavigableMap.headMap(K toKey, boolean inclusive) should be inclusive - true if the high endpoint
        is to be included in the returned view.","['return', 'NavigableMap.headMap(K toKey, boolean inclusive)']"
"NavigableMap.headMap(K toKey, boolean inclusive)","what's the parameter of NavigableMap.headMap(K toKey, boolean inclusive)?","the parameter of NavigableMap.headMap(K toKey, boolean inclusive) should be  high endpoint of the keys in the returned map.","['parameter', 'NavigableMap.headMap(K toKey, boolean inclusive)']"
"NavigableMap.tailMap(K fromKey, boolean inclusive)","what's the return of NavigableMap.tailMap(K fromKey, boolean inclusive)?","the return of NavigableMap.tailMap(K fromKey, boolean inclusive) should be inclusive - true if the low endpoint
        is to be included in the returned view.","['return', 'NavigableMap.tailMap(K fromKey, boolean inclusive)']"
"NavigableMap.tailMap(K fromKey, boolean inclusive)","what's the parameter of NavigableMap.tailMap(K fromKey, boolean inclusive)?","the parameter of NavigableMap.tailMap(K fromKey, boolean inclusive) should be  low endpoint of the keys in the returned map.","['parameter', 'NavigableMap.tailMap(K fromKey, boolean inclusive)']"
"NavigableMap.subMap(K fromKey, K toKey)","what's the return of NavigableMap.subMap(K fromKey, K toKey)?","the return of NavigableMap.subMap(K fromKey, K toKey) should be toKey - high endpoint (exclusive) of the keys in the returned map.","['return', 'NavigableMap.subMap(K fromKey, K toKey)']"
"NavigableMap.subMap(K fromKey, K toKey)","what's the parameter of NavigableMap.subMap(K fromKey, K toKey)?","the parameter of NavigableMap.subMap(K fromKey, K toKey) should be  low endpoint (inclusive) of the keys in the returned map.","['parameter', 'NavigableMap.subMap(K fromKey, K toKey)']"
NavigableMap.headMap(K toKey),what's the return of NavigableMap.headMap(K toKey)?,"the return of NavigableMap.headMap(K toKey) should be a view of the portion of this map whose keys are strictly
         less than toKey.","['return', 'NavigableMap.headMap(K toKey)']"
NavigableMap.headMap(K toKey),what's the parameter of NavigableMap.headMap(K toKey)?,the parameter of NavigableMap.headMap(K toKey) should be  high endpoint (exclusive) of the keys in the returned map.,"['parameter', 'NavigableMap.headMap(K toKey)']"
NavigableMap.tailMap(K fromKey),what's the return of NavigableMap.tailMap(K fromKey)?,"the return of NavigableMap.tailMap(K fromKey) should be a view of the portion of this map whose keys are greater
         than or equal to fromKey.","['return', 'NavigableMap.tailMap(K fromKey)']"
NavigableMap.tailMap(K fromKey),what's the parameter of NavigableMap.tailMap(K fromKey)?,the parameter of NavigableMap.tailMap(K fromKey) should be  low endpoint (inclusive) of the keys in the returned map.,"['parameter', 'NavigableMap.tailMap(K fromKey)']"
"Map.replace(K key, V oldValue, V newValue)","what's the return of Map.replace(K key, V oldValue, V newValue)?","the return of Map.replace(K key, V oldValue, V newValue) should be oldValue - value expected to be associated with the specified key.","['return', 'Map.replace(K key, V oldValue, V newValue)']"
"Map.replace(K key, V oldValue, V newValue)","what's the parameter of Map.replace(K key, V oldValue, V newValue)?","the parameter of Map.replace(K key, V oldValue, V newValue) should be  key with which the specified value is associated.","['parameter', 'Map.replace(K key, V oldValue, V newValue)']"
"Map.replace(K key, V value)","what's the return of Map.replace(K key, V value)?","the return of Map.replace(K key, V value) should be value - value to be associated with the specified key.","['return', 'Map.replace(K key, V value)']"
"Map.replace(K key, V value)","what's the parameter of Map.replace(K key, V value)?","the parameter of Map.replace(K key, V value) should be  key with which the specified value is associated.","['parameter', 'Map.replace(K key, V value)']"
"Map.forEach(BiConsumer<? super K,? super V> action)","what's the parameter of Map.forEach(BiConsumer<? super K,? super V> action)?","the parameter of Map.forEach(BiConsumer<? super K,? super V> action) should be  The action to be performed for each entry.","['parameter', 'Map.forEach(BiConsumer<? super K,? super V> action)']"
"Map.replaceAll(BiFunction<? super K,? super V,? extends V> function)","what's the parameter of Map.replaceAll(BiFunction<? super K,? super V,? extends V> function)?","the parameter of Map.replaceAll(BiFunction<? super K,? super V,? extends V> function) should be  the function to apply to each entry.","['parameter', 'Map.replaceAll(BiFunction<? super K,? super V,? extends V> function)']"
Iterable.iterator(),what's the return of Iterable.iterator()?,the return of Iterable.iterator() should be an iterator over the elements in this list in proper sequence..,"['return', 'Iterable.iterator()']"
NavigableSet.descendingIterator(),what's the return of NavigableSet.descendingIterator()?,"the return of NavigableSet.descendingIterator() should be an iterator over the elements in this set, in descending order. Equivalent in effect to descendingSet().iterator()..","['return', 'NavigableSet.descendingIterator()']"
NavigableSet.descendingSet(),what's the return of NavigableSet.descendingSet()?,"the return of NavigableSet.descendingSet() should be a reverse order view of the elements contained in this set. The descending set is backed by this set, so changes to the set are reflected in the descending set, and vice-versa. If either set is modified while an iteration over either set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined..","['return', 'NavigableSet.descendingSet()']"
Collection.size(),what's the return of Collection.size()?,the return of Collection.size() should be the number of elements in this deque..,"['return', 'Collection.size()']"
"NavigableSet.subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)","what's the return of NavigableSet.subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)?","the return of NavigableSet.subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) should be a view of the portion of this set whose elements range from fromElement to toElement. If fromElement and toElement are equal, the returned set is empty unless fromInclusive and toInclusive are both true. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports..","['return', 'NavigableSet.subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)']"
"NavigableSet.subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)","what's the parameter of NavigableSet.subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)?","the parameter of NavigableSet.subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) should be  low endpoint of the returned set.","['parameter', 'NavigableSet.subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)']"
"NavigableSet.headSet(E toElement, boolean inclusive)","what's the return of NavigableSet.headSet(E toElement, boolean inclusive)?","the return of NavigableSet.headSet(E toElement, boolean inclusive) should be a view of the portion of this set whose elements are less than (or equal to, if inclusive is true) toElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports..","['return', 'NavigableSet.headSet(E toElement, boolean inclusive)']"
"NavigableSet.headSet(E toElement, boolean inclusive)","what's the parameter of NavigableSet.headSet(E toElement, boolean inclusive)?","the parameter of NavigableSet.headSet(E toElement, boolean inclusive) should be  high endpoint of the returned set.","['parameter', 'NavigableSet.headSet(E toElement, boolean inclusive)']"
"NavigableSet.tailSet(E fromElement, boolean inclusive)","what's the return of NavigableSet.tailSet(E fromElement, boolean inclusive)?","the return of NavigableSet.tailSet(E fromElement, boolean inclusive) should be a view of the portion of this set whose elements are greater than (or equal to, if inclusive is true) fromElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports..","['return', 'NavigableSet.tailSet(E fromElement, boolean inclusive)']"
"NavigableSet.tailSet(E fromElement, boolean inclusive)","what's the parameter of NavigableSet.tailSet(E fromElement, boolean inclusive)?","the parameter of NavigableSet.tailSet(E fromElement, boolean inclusive) should be  low endpoint of the returned set.","['parameter', 'NavigableSet.tailSet(E fromElement, boolean inclusive)']"
NavigableSet.lower(E e),what's the return of NavigableSet.lower(E e)?,"the return of NavigableSet.lower(E e) should be the greatest element in this set strictly less than the given element, or null if there is no such element..","['return', 'NavigableSet.lower(E e)']"
NavigableSet.lower(E e),what's the parameter of NavigableSet.lower(E e)?,the parameter of NavigableSet.lower(E e) should be  the value to match.,"['parameter', 'NavigableSet.lower(E e)']"
NavigableSet.floor(E e),what's the return of NavigableSet.floor(E e)?,"the return of NavigableSet.floor(E e) should be the greatest element in this set less than or equal to the given element, or null if there is no such element..","['return', 'NavigableSet.floor(E e)']"
NavigableSet.floor(E e),what's the parameter of NavigableSet.floor(E e)?,the parameter of NavigableSet.floor(E e) should be  the value to match.,"['parameter', 'NavigableSet.floor(E e)']"
NavigableSet.ceiling(E e),what's the return of NavigableSet.ceiling(E e)?,"the return of NavigableSet.ceiling(E e) should be the least element in this set greater than or equal to the given element, or null if there is no such element..","['return', 'NavigableSet.ceiling(E e)']"
NavigableSet.ceiling(E e),what's the parameter of NavigableSet.ceiling(E e)?,the parameter of NavigableSet.ceiling(E e) should be  the value to match.,"['parameter', 'NavigableSet.ceiling(E e)']"
NavigableSet.higher(E e),what's the return of NavigableSet.higher(E e)?,"the return of NavigableSet.higher(E e) should be the least element in this set strictly greater than the given element, or null if there is no such element..","['return', 'NavigableSet.higher(E e)']"
NavigableSet.higher(E e),what's the parameter of NavigableSet.higher(E e)?,the parameter of NavigableSet.higher(E e) should be  the value to match.,"['parameter', 'NavigableSet.higher(E e)']"
NavigableSet.pollFirst(),what's the return of NavigableSet.pollFirst()?,"the return of NavigableSet.pollFirst() should be the first element, or null if this set is empty.","['return', 'NavigableSet.pollFirst()']"
NavigableSet.pollLast(),what's the return of NavigableSet.pollLast()?,"the return of NavigableSet.pollLast() should be the last element, or null if this set is empty.","['return', 'NavigableSet.pollLast()']"
Object.clone(),what's the return of Object.clone()?,the return of Object.clone() should be a shallow copy of this AbstractMap instance: the keys and values themselves are not cloned..,"['return', 'Object.clone()']"
Iterable.spliterator(),what's the return of Iterable.spliterator()?,the return of Iterable.spliterator() should be a Spliterator over the elements in this list.,"['return', 'Iterable.spliterator()']"
UnknownFormatFlagsException.getFlags(),what's the return of UnknownFormatFlagsException.getFlags()?,the return of UnknownFormatFlagsException.getFlags() should be the set of flags which contains an unknown flag..,"['return', 'UnknownFormatFlagsException.getFlags()']"
UUID.randomUUID(),what's the return of UUID.randomUUID()?,the return of UUID.randomUUID() should be A randomly generated UUID.,"['return', 'UUID.randomUUID()']"
UUID.nameUUIDFromBytes(byte[] name),what's the return of UUID.nameUUIDFromBytes(byte[] name)?,the return of UUID.nameUUIDFromBytes(byte[] name) should be A UUID generated from the specified array.,"['return', 'UUID.nameUUIDFromBytes(byte[] name)']"
UUID.fromString(String name),what's the return of UUID.fromString(String name)?,the return of UUID.fromString(String name) should be A UUID with the specified value.,"['return', 'UUID.fromString(String name)']"
UUID.fromString(String name),what's the parameter of UUID.fromString(String name)?,the parameter of UUID.fromString(String name) should be  A string that specifies a UUID.,"['parameter', 'UUID.fromString(String name)']"
UUID.getLeastSignificantBits(),what's the return of UUID.getLeastSignificantBits()?,the return of UUID.getLeastSignificantBits() should be the least significant 64 bits of this UUID's 128 bit value..,"['return', 'UUID.getLeastSignificantBits()']"
UUID.getMostSignificantBits(),what's the return of UUID.getMostSignificantBits()?,the return of UUID.getMostSignificantBits() should be the most significant 64 bits of this UUID's 128 bit value..,"['return', 'UUID.getMostSignificantBits()']"
UUID.version(),what's the return of UUID.version()?,the return of UUID.version() should be The version number of this UUID.,"['return', 'UUID.version()']"
UUID.variant(),what's the return of UUID.variant()?,the return of UUID.variant() should be The variant number of this UUID.,"['return', 'UUID.variant()']"
UUID.timestamp(),what's the return of UUID.timestamp()?,the return of UUID.timestamp() should be The timestamp of this UUID..,"['return', 'UUID.timestamp()']"
UUID.clockSequence(),what's the return of UUID.clockSequence()?,the return of UUID.clockSequence() should be The clock sequence of this UUID.,"['return', 'UUID.clockSequence()']"
UUID.node(),what's the return of UUID.node()?,the return of UUID.node() should be The node value of this UUID.,"['return', 'UUID.node()']"
Object.toString(),what's the return of Object.toString()?,"the return of Object.toString() should be the string representation of this Package. Its value is the string ""package "" and the package name. If the package title is defined it is appended. If the package version is defined it is appended..","['return', 'Object.toString()']"
Object.hashCode(),what's the return of Object.hashCode()?,the return of Object.hashCode() should be the hash code computed from the package name..,"['return', 'Object.hashCode()']"
Object.equals(Object obj),what's the return of Object.equals(Object obj)?,"the return of Object.equals(Object obj) should be true if the objects are the same;
          false otherwise..","['return', 'Object.equals(Object obj)']"
Object.equals(Object obj),what's the parameter of Object.equals(Object obj)?,the parameter of Object.equals(Object obj) should be  the object to compare with..,"['parameter', 'Object.equals(Object obj)']"
Comparable.compareTo(UUID val),what's the return of Comparable.compareTo(UUID val)?,"the return of Comparable.compareTo(UUID val) should be -1, 0 or 1 as this UUID is less than, equal to, or
          greater than val.","['return', 'Comparable.compareTo(UUID val)']"
Comparable.compareTo(UUID val),what's the parameter of Comparable.compareTo(UUID val)?,the parameter of Comparable.compareTo(UUID val) should be  UUID to which this UUID is to be compared.,"['parameter', 'Comparable.compareTo(UUID val)']"
Map.entrySet(),what's the return of Map.entrySet()?,the return of Map.entrySet() should be a set view of the mappings contained in this map.,"['return', 'Map.entrySet()']"
"Map.forEach(BiConsumer<? super K,? super V> action)","what's the parameter of Map.forEach(BiConsumer<? super K,? super V> action)?","the parameter of Map.forEach(BiConsumer<? super K,? super V> action) should be  The action to be performed for each entry.","['parameter', 'Map.forEach(BiConsumer<? super K,? super V> action)']"
"Map.replaceAll(BiFunction<? super K,? super V,? extends V> function)","what's the parameter of Map.replaceAll(BiFunction<? super K,? super V,? extends V> function)?","the parameter of Map.replaceAll(BiFunction<? super K,? super V,? extends V> function) should be  the function to apply to each entry.","['parameter', 'Map.replaceAll(BiFunction<? super K,? super V,? extends V> function)']"
java.lang.AbstractMethodError,Did your class or interface extends the java.lang.IncompatibleClassChangeError ?,,['java.lang.IncompatibleClassChangeError']
java.lang.AbstractMethodError,"If you use a method belongs to java.lang.AbstractMethodError , which method do you use?",,"['method', 'java.lang.AbstractMethodError', 'method']"
java.lang.AbstractMethodError,"if you use a constructor belongs to  java.lang.AbstractMethodError,which type do you use？",,"['constructor', 'java.lang.AbstractMethodError']"
java.lang.Appendable,"If you use a method belongs to java.lang.Appendable , which method do you use?",,"['method', 'java.lang.Appendable', 'method']"
java.lang.ArithmeticException,Did your class or interface extends the java.lang.RuntimeException ?,,['java.lang.RuntimeException']
java.lang.ArithmeticException,"If you use a method belongs to java.lang.ArithmeticException , which method do you use?",,"['method', 'java.lang.ArithmeticException', 'method']"
java.lang.ArithmeticException,"if you use a constructor belongs to  java.lang.ArithmeticException,which type do you use？",,"['constructor', 'java.lang.ArithmeticException']"
java.lang.ArrayIndexOutOfBoundsException,Did your class or interface extends the java.lang.IndexOutOfBoundsException ?,,['java.lang.IndexOutOfBoundsException']
java.lang.ArrayIndexOutOfBoundsException,"If you use a method belongs to java.lang.ArrayIndexOutOfBoundsException , which method do you use?",,"['method', 'java.lang.ArrayIndexOutOfBoundsException', 'method']"
java.lang.ArrayIndexOutOfBoundsException,"if you use a constructor belongs to  java.lang.ArrayIndexOutOfBoundsException,which type do you use？",,"['constructor', 'java.lang.ArrayIndexOutOfBoundsException']"
java.lang.ArrayStoreException,"If you use a method belongs to java.lang.ArrayStoreException , which method do you use?",,"['method', 'java.lang.ArrayStoreException', 'method']"
java.lang.ArrayStoreException,"if you use a constructor belongs to  java.lang.ArrayStoreException,which type do you use？",,"['constructor', 'java.lang.ArrayStoreException']"
java.lang.AssertionError,Did your class or interface extends the java.lang.Error ?,,['java.lang.Error']
java.lang.AssertionError,"If you use a method belongs to java.lang.AssertionError , which method do you use?",,"['method', 'java.lang.AssertionError', 'method']"
java.lang.AssertionError,"if you use a constructor belongs to  java.lang.AssertionError,which type do you use？",,"['constructor', 'java.lang.AssertionError']"
java.lang.AutoCloseable,"If you use a method belongs to java.lang.AutoCloseable , which method do you use?",,"['method', 'java.lang.AutoCloseable', 'method']"
java.lang.Boolean,Did your class or interface extends the java.lang.Object ?,,['java.lang.Object']
java.lang.Boolean,"If you use a method belongs to java.lang.Boolean , which method do you use?",,"['method', 'java.lang.Boolean', 'method']"
java.lang.Boolean,"if you use a constructor belongs to  java.lang.Boolean,which type do you use？",,"['constructor', 'java.lang.Boolean']"
java.lang.BootstrapMethodError,Did your class or interface extends the java.lang.LinkageError ?,,['java.lang.LinkageError']
java.lang.BootstrapMethodError,"If you use a method belongs to java.lang.BootstrapMethodError , which method do you use?",,"['method', 'java.lang.BootstrapMethodError', 'method']"
java.lang.BootstrapMethodError,"if you use a constructor belongs to  java.lang.BootstrapMethodError,which type do you use？",,"['constructor', 'java.lang.BootstrapMethodError']"
java.lang.Byte,Did your class or interface extends the java.lang.Number ?,,['java.lang.Number']
java.lang.Byte,"If you use a method belongs to java.lang.Byte , which method do you use?",,"['method', 'java.lang.Byte', 'method']"
java.lang.Byte,"if you use a constructor belongs to  java.lang.Byte,which type do you use？",,"['constructor', 'java.lang.Byte']"
java.lang.Character,"If you use a method belongs to java.lang.Character , which method do you use?",,"['method', 'java.lang.Character', 'method']"
java.lang.Character,"if you use a constructor belongs to  java.lang.Character,which type do you use？",,"['constructor', 'java.lang.Character']"
java.lang.Character.Subset,"If you use a method belongs to java.lang.Character.Subset , which method do you use?",,"['method', 'java.lang.Character.Subset', 'method']"
java.lang.Character.Subset,"if you use a constructor belongs to  java.lang.Character.Subset,which type do you use？",,"['constructor', 'java.lang.Character.Subset']"
java.lang.Character.UnicodeBlock,Did your class or interface extends the java.lang.Character.Subset ?,,['java.lang.Character.Subset']
java.lang.Character.UnicodeBlock,"If you use a method belongs to java.lang.Character.UnicodeBlock , which method do you use?",,"['method', 'java.lang.Character.UnicodeBlock', 'method']"
java.lang.Character.UnicodeScript,Did your class or interface extends the java.lang.Enum ?,,['java.lang.Enum']
java.lang.Character.UnicodeScript,"If you use a method belongs to java.lang.Character.UnicodeScript , which method do you use?",,"['method', 'java.lang.Character.UnicodeScript', 'method']"
java.lang.CharSequence,"If you use a method belongs to java.lang.CharSequence , which method do you use?",,"['method', 'java.lang.CharSequence', 'method']"
java.lang.Class,"If you use a method belongs to java.lang.Class , which method do you use?",,"['method', 'java.lang.Class', 'method']"
java.lang.ClassCastException,"If you use a method belongs to java.lang.ClassCastException , which method do you use?",,"['method', 'java.lang.ClassCastException', 'method']"
java.lang.ClassCastException,"if you use a constructor belongs to  java.lang.ClassCastException,which type do you use？",,"['constructor', 'java.lang.ClassCastException']"
java.lang.ClassCircularityError,"If you use a method belongs to java.lang.ClassCircularityError , which method do you use?",,"['method', 'java.lang.ClassCircularityError', 'method']"
java.lang.ClassCircularityError,"if you use a constructor belongs to  java.lang.ClassCircularityError,which type do you use？",,"['constructor', 'java.lang.ClassCircularityError']"
java.lang.ClassFormatError,"If you use a method belongs to java.lang.ClassFormatError , which method do you use?",,"['method', 'java.lang.ClassFormatError', 'method']"
java.lang.ClassFormatError,"if you use a constructor belongs to  java.lang.ClassFormatError,which type do you use？",,"['constructor', 'java.lang.ClassFormatError']"
java.lang.ClassLoader,"If you use a method belongs to java.lang.ClassLoader , which method do you use?",,"['method', 'java.lang.ClassLoader', 'method']"
java.lang.ClassLoader,"if you use a constructor belongs to  java.lang.ClassLoader,which type do you use？",,"['constructor', 'java.lang.ClassLoader']"
java.lang.ClassNotFoundException,Did your class or interface extends the java.lang.ReflectiveOperationException ?,,['java.lang.ReflectiveOperationException']
java.lang.ClassNotFoundException,"If you use a method belongs to java.lang.ClassNotFoundException , which method do you use?",,"['method', 'java.lang.ClassNotFoundException', 'method']"
java.lang.ClassNotFoundException,"if you use a constructor belongs to  java.lang.ClassNotFoundException,which type do you use？",,"['constructor', 'java.lang.ClassNotFoundException']"
java.lang.ClassValue,"If you use a method belongs to java.lang.ClassValue , which method do you use?",,"['method', 'java.lang.ClassValue', 'method']"
java.lang.ClassValue,"if you use a constructor belongs to  java.lang.ClassValue,which type do you use？",,"['constructor', 'java.lang.ClassValue']"
java.lang.CloneNotSupportedException,Did your class or interface extends the java.lang.Exception ?,,['java.lang.Exception']
java.lang.CloneNotSupportedException,"If you use a method belongs to java.lang.CloneNotSupportedException , which method do you use?",,"['method', 'java.lang.CloneNotSupportedException', 'method']"
java.lang.CloneNotSupportedException,"if you use a constructor belongs to  java.lang.CloneNotSupportedException,which type do you use？",,"['constructor', 'java.lang.CloneNotSupportedException']"
java.lang.Comparable,"If you use a method belongs to java.lang.Comparable , which method do you use?",,"['method', 'java.lang.Comparable', 'method']"
java.lang.Compiler,"If you use a method belongs to java.lang.Compiler , which method do you use?",,"['method', 'java.lang.Compiler', 'method']"
java.lang.Double,"If you use a method belongs to java.lang.Double , which method do you use?",,"['method', 'java.lang.Double', 'method']"
java.lang.Double,"if you use a constructor belongs to  java.lang.Double,which type do you use？",,"['constructor', 'java.lang.Double']"
java.lang.Enum<E,"If you use a method belongs to java.lang.Enum<E , which method do you use?",,"['method', 'java.lang.Enum<E', 'method']"
java.lang.Enum<E,"if you use a constructor belongs to  java.lang.Enum<E,which type do you use？",,"['constructor', 'java.lang.Enum<E']"
java.lang.EnumConstantNotPresentException,"If you use a method belongs to java.lang.EnumConstantNotPresentException , which method do you use?",,"['method', 'java.lang.EnumConstantNotPresentException', 'method']"
java.lang.EnumConstantNotPresentException,"if you use a constructor belongs to  java.lang.EnumConstantNotPresentException,which type do you use？",,"['constructor', 'java.lang.EnumConstantNotPresentException']"
java.lang.Error,Did your class or interface extends the java.lang.Throwable ?,,['java.lang.Throwable']
java.lang.Error,"If you use a method belongs to java.lang.Error , which method do you use?",,"['method', 'java.lang.Error', 'method']"
java.lang.Error,"if you use a constructor belongs to  java.lang.Error,which type do you use？",,"['constructor', 'java.lang.Error']"
java.lang.Exception,"If you use a method belongs to java.lang.Exception , which method do you use?",,"['method', 'java.lang.Exception', 'method']"
java.lang.Exception,"if you use a constructor belongs to  java.lang.Exception,which type do you use？",,"['constructor', 'java.lang.Exception']"
java.lang.ExceptionInInitializerError,"If you use a method belongs to java.lang.ExceptionInInitializerError , which method do you use?",,"['method', 'java.lang.ExceptionInInitializerError', 'method']"
java.lang.ExceptionInInitializerError,"if you use a constructor belongs to  java.lang.ExceptionInInitializerError,which type do you use？",,"['constructor', 'java.lang.ExceptionInInitializerError']"
java.lang.Float,"If you use a method belongs to java.lang.Float , which method do you use?",,"['method', 'java.lang.Float', 'method']"
java.lang.Float,"if you use a constructor belongs to  java.lang.Float,which type do you use？",,"['constructor', 'java.lang.Float']"
java.lang.IllegalAccessError,"If you use a method belongs to java.lang.IllegalAccessError , which method do you use?",,"['method', 'java.lang.IllegalAccessError', 'method']"
java.lang.IllegalAccessError,"if you use a constructor belongs to  java.lang.IllegalAccessError,which type do you use？",,"['constructor', 'java.lang.IllegalAccessError']"
java.lang.IllegalAccessException,"If you use a method belongs to java.lang.IllegalAccessException , which method do you use?",,"['method', 'java.lang.IllegalAccessException', 'method']"
java.lang.IllegalAccessException,"if you use a constructor belongs to  java.lang.IllegalAccessException,which type do you use？",,"['constructor', 'java.lang.IllegalAccessException']"
java.lang.IllegalArgumentException,"If you use a method belongs to java.lang.IllegalArgumentException , which method do you use?",,"['method', 'java.lang.IllegalArgumentException', 'method']"
java.lang.IllegalArgumentException,"if you use a constructor belongs to  java.lang.IllegalArgumentException,which type do you use？",,"['constructor', 'java.lang.IllegalArgumentException']"
java.lang.IllegalMonitorStateException,"If you use a method belongs to java.lang.IllegalMonitorStateException , which method do you use?",,"['method', 'java.lang.IllegalMonitorStateException', 'method']"
java.lang.IllegalMonitorStateException,"if you use a constructor belongs to  java.lang.IllegalMonitorStateException,which type do you use？",,"['constructor', 'java.lang.IllegalMonitorStateException']"
java.lang.IllegalStateException,"If you use a method belongs to java.lang.IllegalStateException , which method do you use?",,"['method', 'java.lang.IllegalStateException', 'method']"
java.lang.IllegalStateException,"if you use a constructor belongs to  java.lang.IllegalStateException,which type do you use？",,"['constructor', 'java.lang.IllegalStateException']"
java.lang.IllegalThreadStateException,Did your class or interface extends the java.lang.IllegalArgumentException ?,,['java.lang.IllegalArgumentException']
java.lang.IllegalThreadStateException,"If you use a method belongs to java.lang.IllegalThreadStateException , which method do you use?",,"['method', 'java.lang.IllegalThreadStateException', 'method']"
java.lang.IllegalThreadStateException,"if you use a constructor belongs to  java.lang.IllegalThreadStateException,which type do you use？",,"['constructor', 'java.lang.IllegalThreadStateException']"
java.lang.IncompatibleClassChangeError,"If you use a method belongs to java.lang.IncompatibleClassChangeError , which method do you use?",,"['method', 'java.lang.IncompatibleClassChangeError', 'method']"
java.lang.IncompatibleClassChangeError,"if you use a constructor belongs to  java.lang.IncompatibleClassChangeError,which type do you use？",,"['constructor', 'java.lang.IncompatibleClassChangeError']"
java.lang.IndexOutOfBoundsException,"If you use a method belongs to java.lang.IndexOutOfBoundsException , which method do you use?",,"['method', 'java.lang.IndexOutOfBoundsException', 'method']"
java.lang.IndexOutOfBoundsException,"if you use a constructor belongs to  java.lang.IndexOutOfBoundsException,which type do you use？",,"['constructor', 'java.lang.IndexOutOfBoundsException']"
java.lang.InheritableThreadLocal,Did your class or interface extends the java.lang.ThreadLocal ?,,['java.lang.ThreadLocal']
java.lang.InheritableThreadLocal,"If you use a method belongs to java.lang.InheritableThreadLocal , which method do you use?",,"['method', 'java.lang.InheritableThreadLocal', 'method']"
java.lang.InheritableThreadLocal,"if you use a constructor belongs to  java.lang.InheritableThreadLocal,which type do you use？",,"['constructor', 'java.lang.InheritableThreadLocal']"
java.lang.InstantiationError,"If you use a method belongs to java.lang.InstantiationError , which method do you use?",,"['method', 'java.lang.InstantiationError', 'method']"
java.lang.InstantiationError,"if you use a constructor belongs to  java.lang.InstantiationError,which type do you use？",,"['constructor', 'java.lang.InstantiationError']"
java.lang.InstantiationException,"If you use a method belongs to java.lang.InstantiationException , which method do you use?",,"['method', 'java.lang.InstantiationException', 'method']"
java.lang.InstantiationException,"if you use a constructor belongs to  java.lang.InstantiationException,which type do you use？",,"['constructor', 'java.lang.InstantiationException']"
java.lang.Integer,"If you use a method belongs to java.lang.Integer , which method do you use?",,"['method', 'java.lang.Integer', 'method']"
java.lang.Integer,"if you use a constructor belongs to  java.lang.Integer,which type do you use？",,"['constructor', 'java.lang.Integer']"
java.lang.InternalError,Did your class or interface extends the java.lang.VirtualMachineError ?,,['java.lang.VirtualMachineError']
java.lang.InternalError,"If you use a method belongs to java.lang.InternalError , which method do you use?",,"['method', 'java.lang.InternalError', 'method']"
java.lang.InternalError,"if you use a constructor belongs to  java.lang.InternalError,which type do you use？",,"['constructor', 'java.lang.InternalError']"
java.lang.InterruptedException,"If you use a method belongs to java.lang.InterruptedException , which method do you use?",,"['method', 'java.lang.InterruptedException', 'method']"
java.lang.InterruptedException,"if you use a constructor belongs to  java.lang.InterruptedException,which type do you use？",,"['constructor', 'java.lang.InterruptedException']"
java.lang.Iterable,"If you use a method belongs to java.lang.Iterable , which method do you use?",,"['method', 'java.lang.Iterable', 'method']"
java.lang.LinkageError,"If you use a method belongs to java.lang.LinkageError , which method do you use?",,"['method', 'java.lang.LinkageError', 'method']"
java.lang.LinkageError,"if you use a constructor belongs to  java.lang.LinkageError,which type do you use？",,"['constructor', 'java.lang.LinkageError']"
java.lang.Long,"If you use a method belongs to java.lang.Long , which method do you use?",,"['method', 'java.lang.Long', 'method']"
java.lang.Long,"if you use a constructor belongs to  java.lang.Long,which type do you use？",,"['constructor', 'java.lang.Long']"
java.lang.Math,"If you use a method belongs to java.lang.Math , which method do you use?",,"['method', 'java.lang.Math', 'method']"
java.lang.NegativeArraySizeException,"If you use a method belongs to java.lang.NegativeArraySizeException , which method do you use?",,"['method', 'java.lang.NegativeArraySizeException', 'method']"
java.lang.NegativeArraySizeException,"if you use a constructor belongs to  java.lang.NegativeArraySizeException,which type do you use？",,"['constructor', 'java.lang.NegativeArraySizeException']"
java.lang.NoClassDefFoundError,"If you use a method belongs to java.lang.NoClassDefFoundError , which method do you use?",,"['method', 'java.lang.NoClassDefFoundError', 'method']"
java.lang.NoClassDefFoundError,"if you use a constructor belongs to  java.lang.NoClassDefFoundError,which type do you use？",,"['constructor', 'java.lang.NoClassDefFoundError']"
java.lang.NoSuchFieldError,"If you use a method belongs to java.lang.NoSuchFieldError , which method do you use?",,"['method', 'java.lang.NoSuchFieldError', 'method']"
java.lang.NoSuchFieldError,"if you use a constructor belongs to  java.lang.NoSuchFieldError,which type do you use？",,"['constructor', 'java.lang.NoSuchFieldError']"
java.lang.NoSuchFieldException,"If you use a method belongs to java.lang.NoSuchFieldException , which method do you use?",,"['method', 'java.lang.NoSuchFieldException', 'method']"
java.lang.NoSuchFieldException,"if you use a constructor belongs to  java.lang.NoSuchFieldException,which type do you use？",,"['constructor', 'java.lang.NoSuchFieldException']"
java.lang.NoSuchMethodError,"If you use a method belongs to java.lang.NoSuchMethodError , which method do you use?",,"['method', 'java.lang.NoSuchMethodError', 'method']"
java.lang.NoSuchMethodError,"if you use a constructor belongs to  java.lang.NoSuchMethodError,which type do you use？",,"['constructor', 'java.lang.NoSuchMethodError']"
java.lang.NoSuchMethodException,"If you use a method belongs to java.lang.NoSuchMethodException , which method do you use?",,"['method', 'java.lang.NoSuchMethodException', 'method']"
java.lang.NoSuchMethodException,"if you use a constructor belongs to  java.lang.NoSuchMethodException,which type do you use？",,"['constructor', 'java.lang.NoSuchMethodException']"
java.lang.NullPointerException,"If you use a method belongs to java.lang.NullPointerException , which method do you use?",,"['method', 'java.lang.NullPointerException', 'method']"
java.lang.NullPointerException,"if you use a constructor belongs to  java.lang.NullPointerException,which type do you use？",,"['constructor', 'java.lang.NullPointerException']"
java.lang.Number,"If you use a method belongs to java.lang.Number , which method do you use?",,"['method', 'java.lang.Number', 'method']"
java.lang.Number,"if you use a constructor belongs to  java.lang.Number,which type do you use？",,"['constructor', 'java.lang.Number']"
java.lang.NumberFormatException,"If you use a method belongs to java.lang.NumberFormatException , which method do you use?",,"['method', 'java.lang.NumberFormatException', 'method']"
java.lang.NumberFormatException,"if you use a constructor belongs to  java.lang.NumberFormatException,which type do you use？",,"['constructor', 'java.lang.NumberFormatException']"
java.lang.Object,"if you use a constructor belongs to  java.lang.Object,which type do you use？",,"['constructor', 'java.lang.Object']"
java.lang.Object,"If you use a method belongs to java.lang.Object , which method do you use?",,"['method', 'java.lang.Object', 'method']"
java.lang.OutOfMemoryError,"If you use a method belongs to java.lang.OutOfMemoryError , which method do you use?",,"['method', 'java.lang.OutOfMemoryError', 'method']"
java.lang.OutOfMemoryError,"if you use a constructor belongs to  java.lang.OutOfMemoryError,which type do you use？",,"['constructor', 'java.lang.OutOfMemoryError']"
java.lang.Package,"If you use a method belongs to java.lang.Package , which method do you use?",,"['method', 'java.lang.Package', 'method']"
java.lang.Process,"If you use a method belongs to java.lang.Process , which method do you use?",,"['method', 'java.lang.Process', 'method']"
java.lang.Process,"if you use a constructor belongs to  java.lang.Process,which type do you use？",,"['constructor', 'java.lang.Process']"
java.lang.ProcessBuilder,"If you use a method belongs to java.lang.ProcessBuilder , which method do you use?",,"['method', 'java.lang.ProcessBuilder', 'method']"
java.lang.ProcessBuilder,"if you use a constructor belongs to  java.lang.ProcessBuilder,which type do you use？",,"['constructor', 'java.lang.ProcessBuilder']"
java.lang.ProcessBuilder.Redirect,"If you use a method belongs to java.lang.ProcessBuilder.Redirect , which method do you use?",,"['method', 'java.lang.ProcessBuilder.Redirect', 'method']"
java.lang.ProcessBuilder.Redirect.Type,"If you use a method belongs to java.lang.ProcessBuilder.Redirect.Type , which method do you use?",,"['method', 'java.lang.ProcessBuilder.Redirect.Type', 'method']"
java.lang.Readable,"If you use a method belongs to java.lang.Readable , which method do you use?",,"['method', 'java.lang.Readable', 'method']"
java.lang.ReflectiveOperationException,"If you use a method belongs to java.lang.ReflectiveOperationException , which method do you use?",,"['method', 'java.lang.ReflectiveOperationException', 'method']"
java.lang.ReflectiveOperationException,"if you use a constructor belongs to  java.lang.ReflectiveOperationException,which type do you use？",,"['constructor', 'java.lang.ReflectiveOperationException']"
java.lang.Runnable,"If you use a method belongs to java.lang.Runnable , which method do you use?",,"['method', 'java.lang.Runnable', 'method']"
java.lang.Runtime,"If you use a method belongs to java.lang.Runtime , which method do you use?",,"['method', 'java.lang.Runtime', 'method']"
java.lang.RuntimeException,"If you use a method belongs to java.lang.RuntimeException , which method do you use?",,"['method', 'java.lang.RuntimeException', 'method']"
java.lang.RuntimeException,"if you use a constructor belongs to  java.lang.RuntimeException,which type do you use？",,"['constructor', 'java.lang.RuntimeException']"
java.lang.RuntimePermission,Did your class or interface extends the java.security.BasicPermission ?,,['java.security.BasicPermission']
java.lang.RuntimePermission,"If you use a method belongs to java.lang.RuntimePermission , which method do you use?",,"['method', 'java.lang.RuntimePermission', 'method']"
java.lang.RuntimePermission,"if you use a constructor belongs to  java.lang.RuntimePermission,which type do you use？",,"['constructor', 'java.lang.RuntimePermission']"
java.lang.SecurityException,"If you use a method belongs to java.lang.SecurityException , which method do you use?",,"['method', 'java.lang.SecurityException', 'method']"
java.lang.SecurityException,"if you use a constructor belongs to  java.lang.SecurityException,which type do you use？",,"['constructor', 'java.lang.SecurityException']"
java.lang.SecurityManager,"If you use a method belongs to java.lang.SecurityManager , which method do you use?",,"['method', 'java.lang.SecurityManager', 'method']"
java.lang.SecurityManager,"if you use a constructor belongs to  java.lang.SecurityManager,which type do you use？",,"['constructor', 'java.lang.SecurityManager']"
java.lang.Short,"If you use a method belongs to java.lang.Short , which method do you use?",,"['method', 'java.lang.Short', 'method']"
java.lang.Short,"if you use a constructor belongs to  java.lang.Short,which type do you use？",,"['constructor', 'java.lang.Short']"
java.lang.StackOverflowError,"If you use a method belongs to java.lang.StackOverflowError , which method do you use?",,"['method', 'java.lang.StackOverflowError', 'method']"
java.lang.StackOverflowError,"if you use a constructor belongs to  java.lang.StackOverflowError,which type do you use？",,"['constructor', 'java.lang.StackOverflowError']"
java.lang.StackTraceElement,"If you use a method belongs to java.lang.StackTraceElement , which method do you use?",,"['method', 'java.lang.StackTraceElement', 'method']"
java.lang.StackTraceElement,"if you use a constructor belongs to  java.lang.StackTraceElement,which type do you use？",,"['constructor', 'java.lang.StackTraceElement']"
java.lang.StrictMath,"If you use a method belongs to java.lang.StrictMath , which method do you use?",,"['method', 'java.lang.StrictMath', 'method']"
java.lang.String,"If you use a method belongs to java.lang.String , which method do you use?",,"['method', 'java.lang.String', 'method']"
java.lang.String,"if you use a constructor belongs to  java.lang.String,which type do you use？",,"['constructor', 'java.lang.String']"
java.lang.StringBuffer,"If you use a method belongs to java.lang.StringBuffer , which method do you use?",,"['method', 'java.lang.StringBuffer', 'method']"
java.lang.StringBuffer,"if you use a constructor belongs to  java.lang.StringBuffer,which type do you use？",,"['constructor', 'java.lang.StringBuffer']"
java.lang.StringBuilder,"If you use a method belongs to java.lang.StringBuilder , which method do you use?",,"['method', 'java.lang.StringBuilder', 'method']"
java.lang.StringBuilder,"if you use a constructor belongs to  java.lang.StringBuilder,which type do you use？",,"['constructor', 'java.lang.StringBuilder']"
java.lang.StringIndexOutOfBoundsException,"If you use a method belongs to java.lang.StringIndexOutOfBoundsException , which method do you use?",,"['method', 'java.lang.StringIndexOutOfBoundsException', 'method']"
java.lang.StringIndexOutOfBoundsException,"if you use a constructor belongs to  java.lang.StringIndexOutOfBoundsException,which type do you use？",,"['constructor', 'java.lang.StringIndexOutOfBoundsException']"
java.lang.System,"If you use a method belongs to java.lang.System , which method do you use?",,"['method', 'java.lang.System', 'method']"
java.lang.Thread,"If you use a method belongs to java.lang.Thread , which method do you use?",,"['method', 'java.lang.Thread', 'method']"
java.lang.Thread,"if you use a constructor belongs to  java.lang.Thread,which type do you use？",,"['constructor', 'java.lang.Thread']"
java.lang.Thread.State,"If you use a method belongs to java.lang.Thread.State , which method do you use?",,"['method', 'java.lang.Thread.State', 'method']"
java.lang.Thread.UncaughtExceptionHandler,"If you use a method belongs to java.lang.Thread.UncaughtExceptionHandler , which method do you use?",,"['method', 'java.lang.Thread.UncaughtExceptionHandler', 'method']"
java.lang.ThreadDeath,"If you use a method belongs to java.lang.ThreadDeath , which method do you use?",,"['method', 'java.lang.ThreadDeath', 'method']"
java.lang.ThreadDeath,"if you use a constructor belongs to  java.lang.ThreadDeath,which type do you use？",,"['constructor', 'java.lang.ThreadDeath']"
java.lang.ThreadGroup,"If you use a method belongs to java.lang.ThreadGroup , which method do you use?",,"['method', 'java.lang.ThreadGroup', 'method']"
java.lang.ThreadGroup,"if you use a constructor belongs to  java.lang.ThreadGroup,which type do you use？",,"['constructor', 'java.lang.ThreadGroup']"
java.lang.ThreadLocal,"If you use a method belongs to java.lang.ThreadLocal , which method do you use?",,"['method', 'java.lang.ThreadLocal', 'method']"
java.lang.ThreadLocal,"if you use a constructor belongs to  java.lang.ThreadLocal,which type do you use？",,"['constructor', 'java.lang.ThreadLocal']"
java.lang.Throwable,"If you use a method belongs to java.lang.Throwable , which method do you use?",,"['method', 'java.lang.Throwable', 'method']"
java.lang.Throwable,"if you use a constructor belongs to  java.lang.Throwable,which type do you use？",,"['constructor', 'java.lang.Throwable']"
java.lang.TypeNotPresentException,"If you use a method belongs to java.lang.TypeNotPresentException , which method do you use?",,"['method', 'java.lang.TypeNotPresentException', 'method']"
java.lang.TypeNotPresentException,"if you use a constructor belongs to  java.lang.TypeNotPresentException,which type do you use？",,"['constructor', 'java.lang.TypeNotPresentException']"
java.lang.UnknownError,"If you use a method belongs to java.lang.UnknownError , which method do you use?",,"['method', 'java.lang.UnknownError', 'method']"
java.lang.UnknownError,"if you use a constructor belongs to  java.lang.UnknownError,which type do you use？",,"['constructor', 'java.lang.UnknownError']"
java.lang.UnsatisfiedLinkError,"If you use a method belongs to java.lang.UnsatisfiedLinkError , which method do you use?",,"['method', 'java.lang.UnsatisfiedLinkError', 'method']"
java.lang.UnsatisfiedLinkError,"if you use a constructor belongs to  java.lang.UnsatisfiedLinkError,which type do you use？",,"['constructor', 'java.lang.UnsatisfiedLinkError']"
java.lang.UnsupportedClassVersionError,Did your class or interface extends the java.lang.ClassFormatError ?,,['java.lang.ClassFormatError']
java.lang.UnsupportedClassVersionError,"If you use a method belongs to java.lang.UnsupportedClassVersionError , which method do you use?",,"['method', 'java.lang.UnsupportedClassVersionError', 'method']"
java.lang.UnsupportedClassVersionError,"if you use a constructor belongs to  java.lang.UnsupportedClassVersionError,which type do you use？",,"['constructor', 'java.lang.UnsupportedClassVersionError']"
java.lang.UnsupportedOperationException,"If you use a method belongs to java.lang.UnsupportedOperationException , which method do you use?",,"['method', 'java.lang.UnsupportedOperationException', 'method']"
java.lang.UnsupportedOperationException,"if you use a constructor belongs to  java.lang.UnsupportedOperationException,which type do you use？",,"['constructor', 'java.lang.UnsupportedOperationException']"
java.lang.VerifyError,"If you use a method belongs to java.lang.VerifyError , which method do you use?",,"['method', 'java.lang.VerifyError', 'method']"
java.lang.VerifyError,"if you use a constructor belongs to  java.lang.VerifyError,which type do you use？",,"['constructor', 'java.lang.VerifyError']"
java.lang.VirtualMachineError,"If you use a method belongs to java.lang.VirtualMachineError , which method do you use?",,"['method', 'java.lang.VirtualMachineError', 'method']"
java.lang.VirtualMachineError,"if you use a constructor belongs to  java.lang.VirtualMachineError,which type do you use？",,"['constructor', 'java.lang.VirtualMachineError']"
java.lang.Void,"If you use a method belongs to java.lang.Void , which method do you use?",,"['method', 'java.lang.Void', 'method']"
java.util.AbstractCollection,"If you use a method belongs to java.util.AbstractCollection , which method do you use?",,"['method', 'java.util.AbstractCollection', 'method']"
java.util.AbstractCollection,"if you use a constructor belongs to  java.util.AbstractCollection,which type do you use？",,"['constructor', 'java.util.AbstractCollection']"
java.util.AbstractList,Did your class or interface extends the java.util.AbstractCollection ?,,['java.util.AbstractCollection']
java.util.AbstractList,"If you use a method belongs to java.util.AbstractList , which method do you use?",,"['method', 'java.util.AbstractList', 'method']"
java.util.AbstractList,"if you use a constructor belongs to  java.util.AbstractList,which type do you use？",,"['constructor', 'java.util.AbstractList']"
java.util.AbstractMap,"If you use a method belongs to java.util.AbstractMap , which method do you use?",,"['method', 'java.util.AbstractMap', 'method']"
java.util.AbstractMap,"if you use a constructor belongs to  java.util.AbstractMap,which type do you use？",,"['constructor', 'java.util.AbstractMap']"
java.util.AbstractMap.SimpleEntry,"If you use a method belongs to java.util.AbstractMap.SimpleEntry , which method do you use?",,"['method', 'java.util.AbstractMap.SimpleEntry', 'method']"
java.util.AbstractMap.SimpleEntry,"if you use a constructor belongs to  java.util.AbstractMap.SimpleEntry,which type do you use？",,"['constructor', 'java.util.AbstractMap.SimpleEntry']"
java.util.AbstractMap.SimpleImmutableEntry,"If you use a method belongs to java.util.AbstractMap.SimpleImmutableEntry , which method do you use?",,"['method', 'java.util.AbstractMap.SimpleImmutableEntry', 'method']"
java.util.AbstractMap.SimpleImmutableEntry,"if you use a constructor belongs to  java.util.AbstractMap.SimpleImmutableEntry,which type do you use？",,"['constructor', 'java.util.AbstractMap.SimpleImmutableEntry']"
java.util.AbstractQueue,"If you use a method belongs to java.util.AbstractQueue , which method do you use?",,"['method', 'java.util.AbstractQueue', 'method']"
java.util.AbstractQueue,"if you use a constructor belongs to  java.util.AbstractQueue,which type do you use？",,"['constructor', 'java.util.AbstractQueue']"
java.util.AbstractSequentialList,Did your class or interface extends the java.util.AbstractList ?,,['java.util.AbstractList']
java.util.AbstractSequentialList,"If you use a method belongs to java.util.AbstractSequentialList , which method do you use?",,"['method', 'java.util.AbstractSequentialList', 'method']"
java.util.AbstractSequentialList,"if you use a constructor belongs to  java.util.AbstractSequentialList,which type do you use？",,"['constructor', 'java.util.AbstractSequentialList']"
java.util.AbstractSet,"If you use a method belongs to java.util.AbstractSet , which method do you use?",,"['method', 'java.util.AbstractSet', 'method']"
java.util.AbstractSet,"if you use a constructor belongs to  java.util.AbstractSet,which type do you use？",,"['constructor', 'java.util.AbstractSet']"
java.util.ArrayDeque,"If you use a method belongs to java.util.ArrayDeque , which method do you use?",,"['method', 'java.util.ArrayDeque', 'method']"
java.util.ArrayDeque,"if you use a constructor belongs to  java.util.ArrayDeque,which type do you use？",,"['constructor', 'java.util.ArrayDeque']"
java.util.ArrayList,"If you use a method belongs to java.util.ArrayList , which method do you use?",,"['method', 'java.util.ArrayList', 'method']"
java.util.ArrayList,"if you use a constructor belongs to  java.util.ArrayList,which type do you use？",,"['constructor', 'java.util.ArrayList']"
java.util.Arrays,"If you use a method belongs to java.util.Arrays , which method do you use?",,"['method', 'java.util.Arrays', 'method']"
java.util.Base64.Decoder,"If you use a method belongs to java.util.Base64.Decoder , which method do you use?",,"['method', 'java.util.Base64.Decoder', 'method']"
java.util.Base64.Encoder,"If you use a method belongs to java.util.Base64.Encoder , which method do you use?",,"['method', 'java.util.Base64.Encoder', 'method']"
java.util.Base64,"If you use a method belongs to java.util.Base64 , which method do you use?",,"['method', 'java.util.Base64', 'method']"
java.util.BitSet,"If you use a method belongs to java.util.BitSet , which method do you use?",,"['method', 'java.util.BitSet', 'method']"
java.util.BitSet,"if you use a constructor belongs to  java.util.BitSet,which type do you use？",,"['constructor', 'java.util.BitSet']"
java.util.Calendar.Builder,"If you use a method belongs to java.util.Calendar.Builder , which method do you use?",,"['method', 'java.util.Calendar.Builder', 'method']"
java.util.Calendar.Builder,"if you use a constructor belongs to  java.util.Calendar.Builder,which type do you use？",,"['constructor', 'java.util.Calendar.Builder']"
java.util.Calendar,"If you use a method belongs to java.util.Calendar , which method do you use?",,"['method', 'java.util.Calendar', 'method']"
java.util.Calendar,"if you use a constructor belongs to  java.util.Calendar,which type do you use？",,"['constructor', 'java.util.Calendar']"
java.util.Collection,Did your class or interface extends the java.lang.Iterable ?,,['java.lang.Iterable']
java.util.Collection,"If you use a method belongs to java.util.Collection , which method do you use?",,"['method', 'java.util.Collection', 'method']"
java.util.Collections,"If you use a method belongs to java.util.Collections , which method do you use?",,"['method', 'java.util.Collections', 'method']"
java.util.Comparator,"If you use a method belongs to java.util.Comparator , which method do you use?",,"['method', 'java.util.Comparator', 'method']"
java.util.ConcurrentModificationException,"If you use a method belongs to java.util.ConcurrentModificationException , which method do you use?",,"['method', 'java.util.ConcurrentModificationException', 'method']"
java.util.ConcurrentModificationException,"if you use a constructor belongs to  java.util.ConcurrentModificationException,which type do you use？",,"['constructor', 'java.util.ConcurrentModificationException']"
java.util.Currency,"If you use a method belongs to java.util.Currency , which method do you use?",,"['method', 'java.util.Currency', 'method']"
java.util.Date,"If you use a method belongs to java.util.Date , which method do you use?",,"['method', 'java.util.Date', 'method']"
java.util.Date,"if you use a constructor belongs to  java.util.Date,which type do you use？",,"['constructor', 'java.util.Date']"
java.util.Deque,Did your class or interface extends the java.util.Queue ?,,['java.util.Queue']
java.util.Deque,"If you use a method belongs to java.util.Deque , which method do you use?",,"['method', 'java.util.Deque', 'method']"
java.util.Dictionary,"If you use a method belongs to java.util.Dictionary , which method do you use?",,"['method', 'java.util.Dictionary', 'method']"
java.util.Dictionary,"if you use a constructor belongs to  java.util.Dictionary,which type do you use？",,"['constructor', 'java.util.Dictionary']"
java.util.DoubleSummaryStatistics,"If you use a method belongs to java.util.DoubleSummaryStatistics , which method do you use?",,"['method', 'java.util.DoubleSummaryStatistics', 'method']"
java.util.DoubleSummaryStatistics,"if you use a constructor belongs to  java.util.DoubleSummaryStatistics,which type do you use？",,"['constructor', 'java.util.DoubleSummaryStatistics']"
java.util.DuplicateFormatFlagsException,Did your class or interface extends the java.util.IllegalFormatException ?,,['java.util.IllegalFormatException']
java.util.DuplicateFormatFlagsException,"If you use a method belongs to java.util.DuplicateFormatFlagsException , which method do you use?",,"['method', 'java.util.DuplicateFormatFlagsException', 'method']"
java.util.DuplicateFormatFlagsException,"if you use a constructor belongs to  java.util.DuplicateFormatFlagsException,which type do you use？",,"['constructor', 'java.util.DuplicateFormatFlagsException']"
java.util.EmptyStackException,"If you use a method belongs to java.util.EmptyStackException , which method do you use?",,"['method', 'java.util.EmptyStackException', 'method']"
java.util.EmptyStackException,"if you use a constructor belongs to  java.util.EmptyStackException,which type do you use？",,"['constructor', 'java.util.EmptyStackException']"
java.util.Enumeration,"If you use a method belongs to java.util.Enumeration , which method do you use?",,"['method', 'java.util.Enumeration', 'method']"
java.util.EnumMap<K,Did your class or interface extends the java.lang.AbstractMap ?,,['java.lang.AbstractMap']
java.util.EnumMap<K,"If you use a method belongs to java.util.EnumMap<K , which method do you use?",,"['method', 'java.util.EnumMap<K', 'method']"
java.util.EnumMap<K,"if you use a constructor belongs to  java.util.EnumMap<K,which type do you use？",,"['constructor', 'java.util.EnumMap<K']"
java.util.EnumSet<E,Did your class or interface extends the java.lang.AbstractSet ?,,['java.lang.AbstractSet']
java.util.EnumSet<E,"If you use a method belongs to java.util.EnumSet<E , which method do you use?",,"['method', 'java.util.EnumSet<E', 'method']"
java.util.EventListenerProxy<T,Did your class or interface extends the java.util.Object ?,,['java.util.Object']
java.util.EventListenerProxy<T,"If you use a method belongs to java.util.EventListenerProxy<T , which method do you use?",,"['method', 'java.util.EventListenerProxy<T', 'method']"
java.util.EventListenerProxy<T,"if you use a constructor belongs to  java.util.EventListenerProxy<T,which type do you use？",,"['constructor', 'java.util.EventListenerProxy<T']"
java.util.EventObject,"If you use a method belongs to java.util.EventObject , which method do you use?",,"['method', 'java.util.EventObject', 'method']"
java.util.EventObject,"if you use a constructor belongs to  java.util.EventObject,which type do you use？",,"['constructor', 'java.util.EventObject']"
java.util.FormatFlagsConversionMismatchException,"If you use a method belongs to java.util.FormatFlagsConversionMismatchException , which method do you use?",,"['method', 'java.util.FormatFlagsConversionMismatchException', 'method']"
java.util.FormatFlagsConversionMismatchException,"if you use a constructor belongs to  java.util.FormatFlagsConversionMismatchException,which type do you use？",,"['constructor', 'java.util.FormatFlagsConversionMismatchException']"
java.util.Formattable,"If you use a method belongs to java.util.Formattable , which method do you use?",,"['method', 'java.util.Formattable', 'method']"
java.util.FormattableFlags,"If you use a method belongs to java.util.FormattableFlags , which method do you use?",,"['method', 'java.util.FormattableFlags', 'method']"
java.util.Formatter.BigDecimalLayoutForm,"If you use a method belongs to java.util.Formatter.BigDecimalLayoutForm , which method do you use?",,"['method', 'java.util.Formatter.BigDecimalLayoutForm', 'method']"
java.util.Formatter,"If you use a method belongs to java.util.Formatter , which method do you use?",,"['method', 'java.util.Formatter', 'method']"
java.util.Formatter,"if you use a constructor belongs to  java.util.Formatter,which type do you use？",,"['constructor', 'java.util.Formatter']"
java.util.FormatterClosedException,Did your class or interface extends the java.lang.IllegalStateException ?,,['java.lang.IllegalStateException']
java.util.FormatterClosedException,"If you use a method belongs to java.util.FormatterClosedException , which method do you use?",,"['method', 'java.util.FormatterClosedException', 'method']"
java.util.FormatterClosedException,"if you use a constructor belongs to  java.util.FormatterClosedException,which type do you use？",,"['constructor', 'java.util.FormatterClosedException']"
java.util.GregorianCalendar,Did your class or interface extends the java.util.Calendar ?,,['java.util.Calendar']
java.util.GregorianCalendar,"If you use a method belongs to java.util.GregorianCalendar , which method do you use?",,"['method', 'java.util.GregorianCalendar', 'method']"
java.util.GregorianCalendar,"if you use a constructor belongs to  java.util.GregorianCalendar,which type do you use？",,"['constructor', 'java.util.GregorianCalendar']"
java.util.HashMap,Did your class or interface extends the java.util.AbstractMap ?,,['java.util.AbstractMap']
java.util.HashMap,"If you use a method belongs to java.util.HashMap , which method do you use?",,"['method', 'java.util.HashMap', 'method']"
java.util.HashMap,"if you use a constructor belongs to  java.util.HashMap,which type do you use？",,"['constructor', 'java.util.HashMap']"
java.util.HashSet,Did your class or interface extends the java.util.AbstractSet ?,,['java.util.AbstractSet']
java.util.HashSet,"If you use a method belongs to java.util.HashSet , which method do you use?",,"['method', 'java.util.HashSet', 'method']"
java.util.HashSet,"if you use a constructor belongs to  java.util.HashSet,which type do you use？",,"['constructor', 'java.util.HashSet']"
java.util.Hashtable,Did your class or interface extends the java.util.Dictionary ?,,['java.util.Dictionary']
java.util.Hashtable,"If you use a method belongs to java.util.Hashtable , which method do you use?",,"['method', 'java.util.Hashtable', 'method']"
java.util.Hashtable,"if you use a constructor belongs to  java.util.Hashtable,which type do you use？",,"['constructor', 'java.util.Hashtable']"
java.util.IdentityHashMap,"If you use a method belongs to java.util.IdentityHashMap , which method do you use?",,"['method', 'java.util.IdentityHashMap', 'method']"
java.util.IdentityHashMap,"if you use a constructor belongs to  java.util.IdentityHashMap,which type do you use？",,"['constructor', 'java.util.IdentityHashMap']"
java.util.IllegalFormatCodePointException,"If you use a method belongs to java.util.IllegalFormatCodePointException , which method do you use?",,"['method', 'java.util.IllegalFormatCodePointException', 'method']"
java.util.IllegalFormatCodePointException,"if you use a constructor belongs to  java.util.IllegalFormatCodePointException,which type do you use？",,"['constructor', 'java.util.IllegalFormatCodePointException']"
java.util.IllegalFormatConversionException,"If you use a method belongs to java.util.IllegalFormatConversionException , which method do you use?",,"['method', 'java.util.IllegalFormatConversionException', 'method']"
java.util.IllegalFormatConversionException,"if you use a constructor belongs to  java.util.IllegalFormatConversionException,which type do you use？",,"['constructor', 'java.util.IllegalFormatConversionException']"
java.util.IllegalFormatException,"If you use a method belongs to java.util.IllegalFormatException , which method do you use?",,"['method', 'java.util.IllegalFormatException', 'method']"
java.util.IllegalFormatFlagsException,"If you use a method belongs to java.util.IllegalFormatFlagsException , which method do you use?",,"['method', 'java.util.IllegalFormatFlagsException', 'method']"
java.util.IllegalFormatFlagsException,"if you use a constructor belongs to  java.util.IllegalFormatFlagsException,which type do you use？",,"['constructor', 'java.util.IllegalFormatFlagsException']"
java.util.IllegalFormatPrecisionException,"If you use a method belongs to java.util.IllegalFormatPrecisionException , which method do you use?",,"['method', 'java.util.IllegalFormatPrecisionException', 'method']"
java.util.IllegalFormatPrecisionException,"if you use a constructor belongs to  java.util.IllegalFormatPrecisionException,which type do you use？",,"['constructor', 'java.util.IllegalFormatPrecisionException']"
java.util.IllegalFormatWidthException,"If you use a method belongs to java.util.IllegalFormatWidthException , which method do you use?",,"['method', 'java.util.IllegalFormatWidthException', 'method']"
java.util.IllegalFormatWidthException,"if you use a constructor belongs to  java.util.IllegalFormatWidthException,which type do you use？",,"['constructor', 'java.util.IllegalFormatWidthException']"
java.util.IllformedLocaleException,"If you use a method belongs to java.util.IllformedLocaleException , which method do you use?",,"['method', 'java.util.IllformedLocaleException', 'method']"
java.util.IllformedLocaleException,"if you use a constructor belongs to  java.util.IllformedLocaleException,which type do you use？",,"['constructor', 'java.util.IllformedLocaleException']"
java.util.InputMismatchException,Did your class or interface extends the java.util.NoSuchElementException ?,,['java.util.NoSuchElementException']
java.util.InputMismatchException,"If you use a method belongs to java.util.InputMismatchException , which method do you use?",,"['method', 'java.util.InputMismatchException', 'method']"
java.util.InputMismatchException,"if you use a constructor belongs to  java.util.InputMismatchException,which type do you use？",,"['constructor', 'java.util.InputMismatchException']"
java.util.IntSummaryStatistics,"If you use a method belongs to java.util.IntSummaryStatistics , which method do you use?",,"['method', 'java.util.IntSummaryStatistics', 'method']"
java.util.IntSummaryStatistics,"if you use a constructor belongs to  java.util.IntSummaryStatistics,which type do you use？",,"['constructor', 'java.util.IntSummaryStatistics']"
java.util.InvalidPropertiesFormatException,Did your class or interface extends the java.io.IOException ?,,['java.io.IOException']
java.util.InvalidPropertiesFormatException,"If you use a method belongs to java.util.InvalidPropertiesFormatException , which method do you use?",,"['method', 'java.util.InvalidPropertiesFormatException', 'method']"
java.util.InvalidPropertiesFormatException,"if you use a constructor belongs to  java.util.InvalidPropertiesFormatException,which type do you use？",,"['constructor', 'java.util.InvalidPropertiesFormatException']"
java.util.Iterator,"If you use a method belongs to java.util.Iterator , which method do you use?",,"['method', 'java.util.Iterator', 'method']"
java.util.LinkedHashMap,Did your class or interface extends the java.util.HashMap ?,,['java.util.HashMap']
java.util.LinkedHashMap,"If you use a method belongs to java.util.LinkedHashMap , which method do you use?",,"['method', 'java.util.LinkedHashMap', 'method']"
java.util.LinkedHashMap,"if you use a constructor belongs to  java.util.LinkedHashMap,which type do you use？",,"['constructor', 'java.util.LinkedHashMap']"
java.util.LinkedHashSet,Did your class or interface extends the java.util.HashSet ?,,['java.util.HashSet']
java.util.LinkedHashSet,"If you use a method belongs to java.util.LinkedHashSet , which method do you use?",,"['method', 'java.util.LinkedHashSet', 'method']"
java.util.LinkedHashSet,"if you use a constructor belongs to  java.util.LinkedHashSet,which type do you use？",,"['constructor', 'java.util.LinkedHashSet']"
java.util.LinkedList,Did your class or interface extends the java.util.AbstractSequentialList ?,,['java.util.AbstractSequentialList']
java.util.LinkedList,"If you use a method belongs to java.util.LinkedList , which method do you use?",,"['method', 'java.util.LinkedList', 'method']"
java.util.LinkedList,"if you use a constructor belongs to  java.util.LinkedList,which type do you use？",,"['constructor', 'java.util.LinkedList']"
java.util.List,Did your class or interface extends the java.util.Collection ?,,['java.util.Collection']
java.util.List,"If you use a method belongs to java.util.List , which method do you use?",,"['method', 'java.util.List', 'method']"
java.util.ListIterator,Did your class or interface extends the java.util.Iterator ?,,['java.util.Iterator']
java.util.ListIterator,"If you use a method belongs to java.util.ListIterator , which method do you use?",,"['method', 'java.util.ListIterator', 'method']"
java.util.ListResourceBundle,Did your class or interface extends the java.util.ResourceBundle ?,,['java.util.ResourceBundle']
java.util.ListResourceBundle,"If you use a method belongs to java.util.ListResourceBundle , which method do you use?",,"['method', 'java.util.ListResourceBundle', 'method']"
java.util.ListResourceBundle,"if you use a constructor belongs to  java.util.ListResourceBundle,which type do you use？",,"['constructor', 'java.util.ListResourceBundle']"
java.util.Locale.Builder,"If you use a method belongs to java.util.Locale.Builder , which method do you use?",,"['method', 'java.util.Locale.Builder', 'method']"
java.util.Locale.Builder,"if you use a constructor belongs to  java.util.Locale.Builder,which type do you use？",,"['constructor', 'java.util.Locale.Builder']"
java.util.Locale.Category,"If you use a method belongs to java.util.Locale.Category , which method do you use?",,"['method', 'java.util.Locale.Category', 'method']"
java.util.Locale.FilteringMode,"If you use a method belongs to java.util.Locale.FilteringMode , which method do you use?",,"['method', 'java.util.Locale.FilteringMode', 'method']"
java.util.Locale,"If you use a method belongs to java.util.Locale , which method do you use?",,"['method', 'java.util.Locale', 'method']"
java.util.Locale,"if you use a constructor belongs to  java.util.Locale,which type do you use？",,"['constructor', 'java.util.Locale']"
java.util.Locale.LanguageRange,"If you use a method belongs to java.util.Locale.LanguageRange , which method do you use?",,"['method', 'java.util.Locale.LanguageRange', 'method']"
java.util.Locale.LanguageRange,"if you use a constructor belongs to  java.util.Locale.LanguageRange,which type do you use？",,"['constructor', 'java.util.Locale.LanguageRange']"
java.util.LongSummaryStatistics,"If you use a method belongs to java.util.LongSummaryStatistics , which method do you use?",,"['method', 'java.util.LongSummaryStatistics', 'method']"
java.util.LongSummaryStatistics,"if you use a constructor belongs to  java.util.LongSummaryStatistics,which type do you use？",,"['constructor', 'java.util.LongSummaryStatistics']"
java.util.Map.Entry,"If you use a method belongs to java.util.Map.Entry , which method do you use?",,"['method', 'java.util.Map.Entry', 'method']"
java.util.Map,"If you use a method belongs to java.util.Map , which method do you use?",,"['method', 'java.util.Map', 'method']"
java.util.MissingFormatArgumentException,"If you use a method belongs to java.util.MissingFormatArgumentException , which method do you use?",,"['method', 'java.util.MissingFormatArgumentException', 'method']"
java.util.MissingFormatArgumentException,"if you use a constructor belongs to  java.util.MissingFormatArgumentException,which type do you use？",,"['constructor', 'java.util.MissingFormatArgumentException']"
java.util.MissingFormatWidthException,"If you use a method belongs to java.util.MissingFormatWidthException , which method do you use?",,"['method', 'java.util.MissingFormatWidthException', 'method']"
java.util.MissingFormatWidthException,"if you use a constructor belongs to  java.util.MissingFormatWidthException,which type do you use？",,"['constructor', 'java.util.MissingFormatWidthException']"
java.util.MissingResourceException,"If you use a method belongs to java.util.MissingResourceException , which method do you use?",,"['method', 'java.util.MissingResourceException', 'method']"
java.util.MissingResourceException,"if you use a constructor belongs to  java.util.MissingResourceException,which type do you use？",,"['constructor', 'java.util.MissingResourceException']"
java.util.NavigableMap,Did your class or interface extends the java.util.SortedMap ?,,['java.util.SortedMap']
java.util.NavigableMap,"If you use a method belongs to java.util.NavigableMap , which method do you use?",,"['method', 'java.util.NavigableMap', 'method']"
java.util.NavigableSet,Did your class or interface extends the java.util.SortedSet ?,,['java.util.SortedSet']
java.util.NavigableSet,"If you use a method belongs to java.util.NavigableSet , which method do you use?",,"['method', 'java.util.NavigableSet', 'method']"
java.util.NoSuchElementException,"If you use a method belongs to java.util.NoSuchElementException , which method do you use?",,"['method', 'java.util.NoSuchElementException', 'method']"
java.util.NoSuchElementException,"if you use a constructor belongs to  java.util.NoSuchElementException,which type do you use？",,"['constructor', 'java.util.NoSuchElementException']"
java.util.Objects,"If you use a method belongs to java.util.Objects , which method do you use?",,"['method', 'java.util.Objects', 'method']"
java.util.Observable,"If you use a method belongs to java.util.Observable , which method do you use?",,"['method', 'java.util.Observable', 'method']"
java.util.Observable,"if you use a constructor belongs to  java.util.Observable,which type do you use？",,"['constructor', 'java.util.Observable']"
java.util.Observer,"If you use a method belongs to java.util.Observer , which method do you use?",,"['method', 'java.util.Observer', 'method']"
java.util.Optional,"If you use a method belongs to java.util.Optional , which method do you use?",,"['method', 'java.util.Optional', 'method']"
java.util.OptionalDouble,"If you use a method belongs to java.util.OptionalDouble , which method do you use?",,"['method', 'java.util.OptionalDouble', 'method']"
java.util.OptionalInt,"If you use a method belongs to java.util.OptionalInt , which method do you use?",,"['method', 'java.util.OptionalInt', 'method']"
java.util.OptionalLong,"If you use a method belongs to java.util.OptionalLong , which method do you use?",,"['method', 'java.util.OptionalLong', 'method']"
java.util.PrimitiveIterator,"If you use a method belongs to java.util.PrimitiveIterator , which method do you use?",,"['method', 'java.util.PrimitiveIterator', 'method']"
java.util.PrimitiveIterator.OfDouble,Did your class or interface extends the java.util.PrimitiveIterator ?,,['java.util.PrimitiveIterator']
java.util.PrimitiveIterator.OfDouble,"If you use a method belongs to java.util.PrimitiveIterator.OfDouble , which method do you use?",,"['method', 'java.util.PrimitiveIterator.OfDouble', 'method']"
java.util.PrimitiveIterator.OfInt,"If you use a method belongs to java.util.PrimitiveIterator.OfInt , which method do you use?",,"['method', 'java.util.PrimitiveIterator.OfInt', 'method']"
java.util.PrimitiveIterator.OfLong,"If you use a method belongs to java.util.PrimitiveIterator.OfLong , which method do you use?",,"['method', 'java.util.PrimitiveIterator.OfLong', 'method']"
java.util.PriorityQueue,Did your class or interface extends the java.util.AbstractQueue ?,,['java.util.AbstractQueue']
java.util.PriorityQueue,"If you use a method belongs to java.util.PriorityQueue , which method do you use?",,"['method', 'java.util.PriorityQueue', 'method']"
java.util.PriorityQueue,"if you use a constructor belongs to  java.util.PriorityQueue,which type do you use？",,"['constructor', 'java.util.PriorityQueue']"
java.util.Properties,Did your class or interface extends the java.util.Hashtable ?,,['java.util.Hashtable']
java.util.Properties,"If you use a method belongs to java.util.Properties , which method do you use?",,"['method', 'java.util.Properties', 'method']"
java.util.Properties,"if you use a constructor belongs to  java.util.Properties,which type do you use？",,"['constructor', 'java.util.Properties']"
java.util.PropertyPermission,"If you use a method belongs to java.util.PropertyPermission , which method do you use?",,"['method', 'java.util.PropertyPermission', 'method']"
java.util.PropertyPermission,"if you use a constructor belongs to  java.util.PropertyPermission,which type do you use？",,"['constructor', 'java.util.PropertyPermission']"
java.util.PropertyResourceBundle,"If you use a method belongs to java.util.PropertyResourceBundle , which method do you use?",,"['method', 'java.util.PropertyResourceBundle', 'method']"
java.util.PropertyResourceBundle,"if you use a constructor belongs to  java.util.PropertyResourceBundle,which type do you use？",,"['constructor', 'java.util.PropertyResourceBundle']"
java.util.Queue,"If you use a method belongs to java.util.Queue , which method do you use?",,"['method', 'java.util.Queue', 'method']"
java.util.Random,"If you use a method belongs to java.util.Random , which method do you use?",,"['method', 'java.util.Random', 'method']"
java.util.Random,"if you use a constructor belongs to  java.util.Random,which type do you use？",,"['constructor', 'java.util.Random']"
java.util.ResourceBundle.Control,"If you use a method belongs to java.util.ResourceBundle.Control , which method do you use?",,"['method', 'java.util.ResourceBundle.Control', 'method']"
java.util.ResourceBundle.Control,"if you use a constructor belongs to  java.util.ResourceBundle.Control,which type do you use？",,"['constructor', 'java.util.ResourceBundle.Control']"
java.util.ResourceBundle,"If you use a method belongs to java.util.ResourceBundle , which method do you use?",,"['method', 'java.util.ResourceBundle', 'method']"
java.util.ResourceBundle,"if you use a constructor belongs to  java.util.ResourceBundle,which type do you use？",,"['constructor', 'java.util.ResourceBundle']"
java.util.Scanner,"If you use a method belongs to java.util.Scanner , which method do you use?",,"['method', 'java.util.Scanner', 'method']"
java.util.Scanner,"if you use a constructor belongs to  java.util.Scanner,which type do you use？",,"['constructor', 'java.util.Scanner']"
java.util.ServiceConfigurationError,"If you use a method belongs to java.util.ServiceConfigurationError , which method do you use?",,"['method', 'java.util.ServiceConfigurationError', 'method']"
java.util.ServiceConfigurationError,"if you use a constructor belongs to  java.util.ServiceConfigurationError,which type do you use？",,"['constructor', 'java.util.ServiceConfigurationError']"
java.util.ServiceLoader,"If you use a method belongs to java.util.ServiceLoader , which method do you use?",,"['method', 'java.util.ServiceLoader', 'method']"
java.util.Set,"If you use a method belongs to java.util.Set , which method do you use?",,"['method', 'java.util.Set', 'method']"
java.util.SimpleTimeZone,Did your class or interface extends the java.util.TimeZone ?,,['java.util.TimeZone']
java.util.SimpleTimeZone,"If you use a method belongs to java.util.SimpleTimeZone , which method do you use?",,"['method', 'java.util.SimpleTimeZone', 'method']"
java.util.SimpleTimeZone,"if you use a constructor belongs to  java.util.SimpleTimeZone,which type do you use？",,"['constructor', 'java.util.SimpleTimeZone']"
java.util.SortedMap,Did your class or interface extends the java.util.Map ?,,['java.util.Map']
java.util.SortedMap,"If you use a method belongs to java.util.SortedMap , which method do you use?",,"['method', 'java.util.SortedMap', 'method']"
java.util.SortedSet,Did your class or interface extends the java.util.Set ?,,['java.util.Set']
java.util.SortedSet,"If you use a method belongs to java.util.SortedSet , which method do you use?",,"['method', 'java.util.SortedSet', 'method']"
java.util.Spliterator,"If you use a method belongs to java.util.Spliterator , which method do you use?",,"['method', 'java.util.Spliterator', 'method']"
java.util.Spliterator.OfDouble,Did your class or interface extends the java.util.Spliterator.OfPrimitive ?,,['java.util.Spliterator.OfPrimitive']
java.util.Spliterator.OfDouble,"If you use a method belongs to java.util.Spliterator.OfDouble , which method do you use?",,"['method', 'java.util.Spliterator.OfDouble', 'method']"
java.util.Spliterator.OfInt,"If you use a method belongs to java.util.Spliterator.OfInt , which method do you use?",,"['method', 'java.util.Spliterator.OfInt', 'method']"
java.util.Spliterator.OfLong,"If you use a method belongs to java.util.Spliterator.OfLong , which method do you use?",,"['method', 'java.util.Spliterator.OfLong', 'method']"
"java.util.Spliterator.OfPrimitive<T,T_CONS,T_SPLITR",Did your class or interface extends the java.util.Spliterator ?,,['java.util.Spliterator']
"java.util.Spliterator.OfPrimitive<T,T_CONS,T_SPLITR","If you use a method belongs to java.util.Spliterator.OfPrimitive<T,T_CONS,T_SPLITR , which method do you use?",,"['method', 'java.util.Spliterator.OfPrimitive<T,T_CONS,T_SPLITR', 'method']"
java.util.Spliterators.AbstractDoubleSpliterator,"If you use a method belongs to java.util.Spliterators.AbstractDoubleSpliterator , which method do you use?",,"['method', 'java.util.Spliterators.AbstractDoubleSpliterator', 'method']"
java.util.Spliterators.AbstractDoubleSpliterator,"if you use a constructor belongs to  java.util.Spliterators.AbstractDoubleSpliterator,which type do you use？",,"['constructor', 'java.util.Spliterators.AbstractDoubleSpliterator']"
java.util.Spliterators.AbstractIntSpliterator,"If you use a method belongs to java.util.Spliterators.AbstractIntSpliterator , which method do you use?",,"['method', 'java.util.Spliterators.AbstractIntSpliterator', 'method']"
java.util.Spliterators.AbstractIntSpliterator,"if you use a constructor belongs to  java.util.Spliterators.AbstractIntSpliterator,which type do you use？",,"['constructor', 'java.util.Spliterators.AbstractIntSpliterator']"
java.util.Spliterators.AbstractLongSpliterator,"If you use a method belongs to java.util.Spliterators.AbstractLongSpliterator , which method do you use?",,"['method', 'java.util.Spliterators.AbstractLongSpliterator', 'method']"
java.util.Spliterators.AbstractLongSpliterator,"if you use a constructor belongs to  java.util.Spliterators.AbstractLongSpliterator,which type do you use？",,"['constructor', 'java.util.Spliterators.AbstractLongSpliterator']"
java.util.Spliterators.AbstractSpliterator,"If you use a method belongs to java.util.Spliterators.AbstractSpliterator , which method do you use?",,"['method', 'java.util.Spliterators.AbstractSpliterator', 'method']"
java.util.Spliterators.AbstractSpliterator,"if you use a constructor belongs to  java.util.Spliterators.AbstractSpliterator,which type do you use？",,"['constructor', 'java.util.Spliterators.AbstractSpliterator']"
java.util.Spliterators,"If you use a method belongs to java.util.Spliterators , which method do you use?",,"['method', 'java.util.Spliterators', 'method']"
java.util.SplittableRandom,"If you use a method belongs to java.util.SplittableRandom , which method do you use?",,"['method', 'java.util.SplittableRandom', 'method']"
java.util.SplittableRandom,"if you use a constructor belongs to  java.util.SplittableRandom,which type do you use？",,"['constructor', 'java.util.SplittableRandom']"
java.util.Stack,Did your class or interface extends the java.util.Vector ?,,['java.util.Vector']
java.util.Stack,"If you use a method belongs to java.util.Stack , which method do you use?",,"['method', 'java.util.Stack', 'method']"
java.util.Stack,"if you use a constructor belongs to  java.util.Stack,which type do you use？",,"['constructor', 'java.util.Stack']"
java.util.StringJoiner,"If you use a method belongs to java.util.StringJoiner , which method do you use?",,"['method', 'java.util.StringJoiner', 'method']"
java.util.StringJoiner,"if you use a constructor belongs to  java.util.StringJoiner,which type do you use？",,"['constructor', 'java.util.StringJoiner']"
java.util.StringTokenizer,"If you use a method belongs to java.util.StringTokenizer , which method do you use?",,"['method', 'java.util.StringTokenizer', 'method']"
java.util.StringTokenizer,"if you use a constructor belongs to  java.util.StringTokenizer,which type do you use？",,"['constructor', 'java.util.StringTokenizer']"
java.util.Timer,"If you use a method belongs to java.util.Timer , which method do you use?",,"['method', 'java.util.Timer', 'method']"
java.util.Timer,"if you use a constructor belongs to  java.util.Timer,which type do you use？",,"['constructor', 'java.util.Timer']"
java.util.TimerTask,"If you use a method belongs to java.util.TimerTask , which method do you use?",,"['method', 'java.util.TimerTask', 'method']"
java.util.TimerTask,"if you use a constructor belongs to  java.util.TimerTask,which type do you use？",,"['constructor', 'java.util.TimerTask']"
java.util.TimeZone,"If you use a method belongs to java.util.TimeZone , which method do you use?",,"['method', 'java.util.TimeZone', 'method']"
java.util.TimeZone,"if you use a constructor belongs to  java.util.TimeZone,which type do you use？",,"['constructor', 'java.util.TimeZone']"
java.util.TooManyListenersException,"If you use a method belongs to java.util.TooManyListenersException , which method do you use?",,"['method', 'java.util.TooManyListenersException', 'method']"
java.util.TooManyListenersException,"if you use a constructor belongs to  java.util.TooManyListenersException,which type do you use？",,"['constructor', 'java.util.TooManyListenersException']"
java.util.TreeMap,"If you use a method belongs to java.util.TreeMap , which method do you use?",,"['method', 'java.util.TreeMap', 'method']"
java.util.TreeMap,"if you use a constructor belongs to  java.util.TreeMap,which type do you use？",,"['constructor', 'java.util.TreeMap']"
java.util.TreeSet,"If you use a method belongs to java.util.TreeSet , which method do you use?",,"['method', 'java.util.TreeSet', 'method']"
java.util.TreeSet,"if you use a constructor belongs to  java.util.TreeSet,which type do you use？",,"['constructor', 'java.util.TreeSet']"
java.util.UnknownFormatConversionException,"If you use a method belongs to java.util.UnknownFormatConversionException , which method do you use?",,"['method', 'java.util.UnknownFormatConversionException', 'method']"
java.util.UnknownFormatConversionException,"if you use a constructor belongs to  java.util.UnknownFormatConversionException,which type do you use？",,"['constructor', 'java.util.UnknownFormatConversionException']"
java.util.UnknownFormatFlagsException,"If you use a method belongs to java.util.UnknownFormatFlagsException , which method do you use?",,"['method', 'java.util.UnknownFormatFlagsException', 'method']"
java.util.UnknownFormatFlagsException,"if you use a constructor belongs to  java.util.UnknownFormatFlagsException,which type do you use？",,"['constructor', 'java.util.UnknownFormatFlagsException']"
java.util.UUID,"If you use a method belongs to java.util.UUID , which method do you use?",,"['method', 'java.util.UUID', 'method']"
java.util.UUID,"if you use a constructor belongs to  java.util.UUID,which type do you use？",,"['constructor', 'java.util.UUID']"
java.util.Vector,"If you use a method belongs to java.util.Vector , which method do you use?",,"['method', 'java.util.Vector', 'method']"
java.util.Vector,"if you use a constructor belongs to  java.util.Vector,which type do you use？",,"['constructor', 'java.util.Vector']"
java.util.WeakHashMap,"If you use a method belongs to java.util.WeakHashMap , which method do you use?",,"['method', 'java.util.WeakHashMap', 'method']"
java.util.WeakHashMap,"if you use a constructor belongs to  java.util.WeakHashMap,which type do you use？",,"['constructor', 'java.util.WeakHashMap']"
java.util.stream.Stream,Did your class or interface extends the java.util.stream.BaseStream ?,,['java.util.stream.BaseStream']
java.util.stream.Stream,"If you use a method belongs to java.util.stream.Stream , which method do you use?",,"['method', 'java.util.stream.Stream', 'method']"
